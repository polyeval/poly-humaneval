{
  "C++_humaneval-000": "bool hasCloseElements(vector<double> numbers, double threshold) {\n  for (int i = 0; i < numbers.size(); i++) {\n    for (int j = i + 1; j < numbers.size(); j++) {\n      if (abs(numbers[i] - numbers[j]) < threshold) {\n        return true;\n      }\n    }\n  }\n  return false;\n}",
  "Java_humaneval-000": "public static Boolean hasCloseElements(List<Double> numbers, Double threshold) {\n  for (int i = 0; i < numbers.size(); i++) {\n    for (int j = i + 1; j < numbers.size(); j++) {\n      if (Math.abs(numbers.get(i) - numbers.get(j)) < threshold) {\n        return true;\n      }\n    }\n  }\n  return false;\n}",
  "Python_humaneval-000": "def has_close_elements(numbers: List[float], threshold: float) -> bool:\n    for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            if abs(numbers[i] - numbers[j]) < threshold:\n                return True\n    return False",
  "C#_humaneval-000": "public static bool HasCloseElements(List<double> numbers, double threshold) {\n  for (int i = 0; i < numbers.Count; i++) {\n    for (int j = i + 1; j < numbers.Count; j++) {\n      if (Math.Abs(numbers[i] - numbers[j]) < threshold) {\n        return true;\n      }\n    }\n  }\n  return false;\n}",
  "JavaScript_humaneval-000": "function hasCloseElements(numbers, threshold) {\n  for (let i = 0; i < numbers.length; i++) {\n    for (let j = i + 1; j < numbers.length; j++) {\n      if (Math.abs(numbers[i] - numbers[j]) < threshold) {\n        return true;\n      }\n    }\n  }\n  return false;\n}",
  "Go_humaneval-000": "func hasCloseElements(numbers []float64, threshold float64) bool {\n    for i := 0; i < len(numbers); i++ {\n        for j := i + 1; j < len(numbers); j++ {\n            if math.Abs(numbers[i]-numbers[j]) < threshold {\n                return true\n            }\n        }\n    }\n    return false\n}",
  "PHP_humaneval-000": "function hasCloseElements(array $numbers, float $threshold): bool {\n    for ($i = 0; $i < count($numbers); $i++) {\n        for ($j = $i + 1; $j < count($numbers); $j++) {\n            if (abs($numbers[$i] - $numbers[$j]) < $threshold) {\n                return true;\n            }\n        }\n    }\n    return false;\n}",
  "Ruby_humaneval-000": "def has_close_elements(numbers, threshold)\n  numbers.each_with_index do |n1, i|\n    numbers[(i + 1)..-1].each { |n2| return true if (n1 - n2).abs < threshold }\n  end\n  false\nend",
  "Swift_humaneval-000": "func hasCloseElements(_ numbers: [Double], _ threshold: Double) -> Bool {\n  for i in 0..<numbers.count {\n    for j in i + 1..<numbers.count {\n      if abs(numbers[i] - numbers[j]) < threshold {\n        return true\n      }\n    }\n  }\n  return false\n}",
  "TypeScript_humaneval-000": "function hasCloseElements(numbers: number[], threshold: number): boolean {\n  for (let i = 0; i < numbers.length; i++) {\n    for (let j = i + 1; j < numbers.length; j++) {\n      if (Math.abs(numbers[i] - numbers[j]) < threshold) {\n        return true;\n      }\n    }\n  }\n  return false;\n}",
  "Dart_humaneval-000": "bool hasCloseElements(List<double> numbers, double threshold) {\n  for (int i = 0; i < numbers.length; i++) {\n    for (int j = i + 1; j < numbers.length; j++) {\n      if ((numbers[i] - numbers[j]).abs() < threshold) {\n        return true;\n      }\n    }\n  }\n  return false;\n}",
  "Rust_humaneval-000": "fn has_close_elements(numbers: Vec<f64>, threshold: f64) -> bool {\n    for i in 0..numbers.len() {\n        for j in i + 1..numbers.len() {\n            if (numbers[i] - numbers[j]).abs() < threshold {\n                return true;\n            }\n        }\n    }\n    false\n}",
  "Scala_humaneval-000": "def hasCloseElements(numbers: List[Double], threshold: Double): Boolean = {\n  for (i <- 0 until numbers.length) {\n    for (j <- i + 1 until numbers.length) {\n      if (abs(numbers(i) - numbers(j)) < threshold) {\n        return true\n      }\n    }\n  }\n  false\n}",
  "Kotlin_humaneval-000": "fun hasCloseElements(numbers: List<Double>, threshold: Double): Boolean {\n  for (i in numbers.indices) {\n    for (j in i + 1 until numbers.size) {\n      if (Math.abs(numbers[i] - numbers[j]) < threshold) {\n        return true\n      }\n    }\n  }\n  return false\n}",
  "C++_humaneval-001": "vector<string> separateParenGroups(string paren_string) {\n  vector<string> groups;\n  vector<char> stack;\n  string current_group = \"\";\n  for (char& c : paren_string) {\n    if (c == '(') {\n      stack.push_back(c);\n      current_group += c;\n    } else if (c == ')') {\n      stack.pop_back();\n      current_group += c;\n      if (stack.empty()) {\n        groups.push_back(current_group);\n        current_group = \"\";\n      }\n    }\n  }\n  return groups;\n}",
  "Java_humaneval-001": "public static List<String> separateParenGroups(String parenString) {\n  List<String> groups = new ArrayList<>();\n  Stack<Character> stack = new Stack<>();\n  String currentGroup = \"\";\n  for (char c : parenString.replaceAll(\" \", \"\").toCharArray()) {\n    if (c == '(') {\n      stack.push(c);\n      currentGroup += c;\n    } else if (c == ')') {\n      stack.pop();\n      currentGroup += c;\n      if (stack.empty()) {\n        groups.add(currentGroup);\n        currentGroup = \"\";\n      }\n    }\n  }\n  return groups;\n}",
  "Python_humaneval-001": "def separate_paren_groups(paren_string: str) -> List[str]:\n    groups = []\n    stack = []\n    current_group = \"\"\n    for char in paren_string.replace(\" \", \"\"):\n        if char == \"(\":\n            stack.append(char)\n            current_group += char\n        elif char == \")\":\n            stack.pop()\n            current_group += char\n            if not stack:\n                groups.append(current_group)\n                current_group = \"\"\n    return groups",
  "C#_humaneval-001": "public static List<string> SeparateParenGroups(string parenString) {\n  List<string> groups = new List<string>();\n  Stack<char> stack = new Stack<char>();\n  string currentGroup = \"\";\n  foreach (char c in parenString.Replace(\" \", \"\")) {\n    if (c == '(') {\n      stack.Push(c);\n      currentGroup += c;\n    } else if (c == ')') {\n      stack.Pop();\n      currentGroup += c;\n      if (stack.Count == 0) {\n        groups.Add(currentGroup);\n        currentGroup = \"\";\n      }\n    }\n  }\n  return groups;\n}",
  "JavaScript_humaneval-001": "function separateParenGroups(parenString) {\n  const groups = [];\n  const stack = [];\n  let currentGroup = \"\";\n  for (const char of parenString.replace(/ /g, \"\")) {\n    if (char === \"(\") {\n      stack.push(char);\n      currentGroup += char;\n    } else if (char === \")\") {\n      stack.pop();\n      currentGroup += char;\n      if (!stack.length) {\n        groups.push(currentGroup);\n        currentGroup = \"\";\n      }\n    }\n  }\n  return groups;\n}",
  "Go_humaneval-001": "func separateParenGroups(parenString string) []string {\n    var groups []string\n    var stack []rune\n    var currentGroup string\n    for _, char := range strings.ReplaceAll(parenString, \" \", \"\") {\n        if char == '(' {\n            stack = append(stack, char)\n            currentGroup += string(char)\n        } else if char == ')' {\n            stack = stack[:len(stack)-1]\n            currentGroup += string(char)\n            if len(stack) == 0 {\n                groups = append(groups, currentGroup)\n                currentGroup = \"\"\n            }\n        }\n    }\n    return groups\n}",
  "PHP_humaneval-001": "function separateParenGroups(string $parenString): array {\n    $groups = [];\n    $stack = [];\n    $currentGroup = \"\";\n    $parenString = str_replace(\" \", \"\", $parenString);\n    for ($i = 0; $i < strlen($parenString); $i++) {\n        $char = $parenString[$i];\n        if ($char == \"(\") {\n            array_push($stack, $char);\n            $currentGroup .= $char;\n        } elseif ($char == \")\") {\n            array_pop($stack);\n            $currentGroup .= $char;\n            if (empty($stack)) {\n                array_push($groups, $currentGroup);\n                $currentGroup = \"\";\n            }\n        }\n    }\n    return $groups;\n}",
  "Ruby_humaneval-001": "def separate_paren_groups(paren_string)\n  groups = []\n  stack = []\n  current_group = \"\"\n  paren_string\n    .gsub(\" \", \"\")\n    .each_char do |char|\n      if char == \"(\"\n        stack.push(char)\n        current_group += char\n      elsif char == \")\"\n        stack.pop\n        current_group += char\n        if stack.empty?\n          groups.push(current_group)\n          current_group = \"\"\n        end\n      end\n    end\n  groups\nend",
  "Swift_humaneval-001": "func separateParenGroups(_ parenString: String) -> [String] {\n  var groups = [String]()\n  var stack = [Character]()\n  var currentGroup = \"\"\n  for char in parenString.replacingOccurrences(of: \" \", with: \"\") {\n    if char == \"(\" {\n      stack.append(char)\n      currentGroup += String(char)\n    } else if char == \")\" {\n      stack.popLast()\n      currentGroup += String(char)\n      if stack.isEmpty {\n        groups.append(currentGroup)\n        currentGroup = \"\"\n      }\n    }\n  }\n  return groups\n}",
  "TypeScript_humaneval-001": "function separateParenGroups(parenString: string): string[] {\n  const groups: string[] = [];\n  const stack: string[] = [];\n  let currentGroup = \"\";\n  for (const char of parenString.replace(\" \", \"\")) {\n    if (char === \"(\") {\n      stack.push(char);\n      currentGroup += char;\n    } else if (char === \")\") {\n      stack.pop();\n      currentGroup += char;\n      if (!stack.length) {\n        groups.push(currentGroup);\n        currentGroup = \"\";\n      }\n    }\n  }\n  return groups;\n}",
  "Dart_humaneval-001": "List<String> separateParenGroups(String parenString) {\n  List<String> groups = [];\n  List<String> stack = [];\n  String currentGroup = \"\";\n  for (var char in parenString.replaceAll(\" \", \"\").split(\"\")) {\n    if (char == \"(\") {\n      stack.add(char);\n      currentGroup += char;\n    } else if (char == \")\") {\n      stack.removeLast();\n      currentGroup += char;\n      if (stack.isEmpty) {\n        groups.add(currentGroup);\n        currentGroup = \"\";\n      }\n    }\n  }\n  return groups;\n}",
  "Rust_humaneval-001": "fn separate_paren_groups(paren_string: String) -> Vec<String> {\n    let mut groups = Vec::new();\n    let mut stack = Vec::new();\n    let mut current_group = String::new();\n    for char in paren_string.replace(\" \", \"\").chars() {\n        if char == '(' {\n            stack.push(char);\n            current_group.push(char);\n        } else if char == ')' {\n            stack.pop();\n            current_group.push(char);\n            if stack.is_empty() {\n                groups.push(current_group.clone());\n                current_group.clear();\n            }\n        }\n    }\n    groups\n}",
  "Scala_humaneval-001": "def separateParenGroups(parenString: String): List[String] = {\n  var groups = new ListBuffer[String]()\n  var stack = new ListBuffer[Char]()\n  var currentGroup = \"\"\n  for (char <- parenString.replace(\" \", \"\")) {\n    if (char == '(') {\n      stack += char\n      currentGroup += char\n    } else if (char == ')') {\n      stack = stack.dropRight(1)\n      currentGroup += char\n      if (stack.isEmpty) {\n        groups += currentGroup\n        currentGroup = \"\"\n      }\n    }\n  }\n  groups.toList\n}",
  "Kotlin_humaneval-001": "fun separateParenGroups(parenString: String): List<String> {\n  val groups = mutableListOf<String>()\n  val stack = mutableListOf<Char>()\n  var currentGroup = \"\"\n  for (char in parenString.replace(\" \", \"\")) {\n    if (char == '(') {\n      stack.add(char)\n      currentGroup += char\n    } else if (char == ')') {\n      stack.removeLast()\n      currentGroup += char\n      if (stack.isEmpty()) {\n        groups.add(currentGroup)\n        currentGroup = \"\"\n      }\n    }\n  }\n  return groups\n}",
  "C++_humaneval-002": "double truncateNumber(double number) { return number - int(number); }",
  "Java_humaneval-002": "public static Double truncateNumber(Double number) {\n  return number - number.intValue();\n}",
  "Python_humaneval-002": "def truncate_number(number: float) -> float:\n    return number - int(number)",
  "C#_humaneval-002": "public static double TruncateNumber(double number) {\n  return number - Math.Floor(number);\n}",
  "JavaScript_humaneval-002": "function truncateNumber(number) {\n  return number - Math.floor(number);\n}",
  "Go_humaneval-002": "func truncateNumber(number float64) float64 {\n    return number - float64(int(number))\n}",
  "PHP_humaneval-002": "function truncateNumber(float $number): float {\n    return $number - (int)$number;\n}",
  "Ruby_humaneval-002": "def truncate_number(number)\n  number - number.to_i\nend",
  "Swift_humaneval-002": "func truncateNumber(_ number: Double) -> Double {\n  return number - Double(Int(number))\n}",
  "TypeScript_humaneval-002": "function truncateNumber(number: number): number {\n  return number - Math.floor(number);\n}",
  "Dart_humaneval-002": "double truncateNumber(double number) {\n  return number - number.floor();\n}",
  "Rust_humaneval-002": "fn truncate_number(number: f64) -> f64 {\n    number - number.floor()\n}",
  "Scala_humaneval-002": "def truncateNumber(number: Double): Double = {\n  number - number.toInt\n}",
  "Kotlin_humaneval-002": "fun truncateNumber(number: Double): Double {\n  return number - number.toInt()\n}",
  "C++_humaneval-003": "bool belowZero(vector<int> operations) {\n  int balance = 0;\n  for (int operation : operations) {\n    balance += operation;\n    if (balance < 0) {\n      return true;\n    }\n  }\n  return false;\n}",
  "Java_humaneval-003": "public static Boolean belowZero(List<Integer> operations) {\n  int balance = 0;\n  for (int operation : operations) {\n    balance += operation;\n    if (balance < 0) {\n      return true;\n    }\n  }\n  return false;\n}",
  "Python_humaneval-003": "def below_zero(operations: List[int]) -> bool:\n    balance = 0\n    for operation in operations:\n        balance += operation\n        if balance < 0:\n            return True\n    return False",
  "C#_humaneval-003": "public static bool BelowZero(List<int> operations) {\n  int balance = 0;\n  foreach (int operation in operations) {\n    balance += operation;\n    if (balance < 0) {\n      return true;\n    }\n  }\n  return false;\n}",
  "JavaScript_humaneval-003": "function belowZero(operations) {\n  let balance = 0;\n  for (let i = 0; i < operations.length; i++) {\n    balance += operations[i];\n    if (balance < 0) {\n      return true;\n    }\n  }\n  return false;\n}",
  "Go_humaneval-003": "func belowZero(operations []int) bool {\n    balance := 0\n    for _, operation := range operations {\n        balance += operation\n        if balance < 0 {\n            return true\n        }\n    }\n    return false\n}",
  "PHP_humaneval-003": "function belowZero(array $operations): bool {\n    $balance = 0;\n    foreach ($operations as $operation) {\n        $balance += $operation;\n        if ($balance < 0) {\n            return true;\n        }\n    }\n    return false;\n}",
  "Ruby_humaneval-003": "def below_zero(operations)\n  balance = 0\n  operations.each do |operation|\n    balance += operation\n    return true if balance < 0\n  end\n  false\nend",
  "Swift_humaneval-003": "func belowZero(_ operations: [Int]) -> Bool {\n  var balance = 0\n  for operation in operations {\n    balance += operation\n    if balance < 0 {\n      return true\n    }\n  }\n  return false\n}",
  "TypeScript_humaneval-003": "function belowZero(operations: number[]): boolean {\n  let balance = 0;\n  for (let operation of operations) {\n    balance += operation;\n    if (balance < 0) {\n      return true;\n    }\n  }\n  return false;\n}",
  "Dart_humaneval-003": "bool belowZero(List<int> operations) {\n  int balance = 0;\n  for (int operation in operations) {\n    balance += operation;\n    if (balance < 0) {\n      return true;\n    }\n  }\n  return false;\n}",
  "Rust_humaneval-003": "fn below_zero(operations: Vec<i32>) -> bool {\n    let mut balance = 0;\n    for operation in operations {\n        balance += operation;\n        if balance < 0 {\n            return true;\n        }\n    }\n    false\n}",
  "Scala_humaneval-003": "def belowZero(operations: List[Int]): Boolean = {\n  var balance = 0\n  for (operation <- operations) {\n    balance += operation\n    if (balance < 0) {\n      return true\n    }\n  }\n  false\n}",
  "Kotlin_humaneval-003": "fun belowZero(operations: List<Int>): Boolean {\n  var balance = 0\n  for (operation in operations) {\n    balance += operation\n    if (balance < 0) {\n      return true\n    }\n  }\n  return false\n}",
  "C++_humaneval-004": "double meanAbsoluteDeviation(vector<double> numbers) {\n  double mean = 0;\n  for (double x : numbers) {\n    mean += x;\n  }\n  mean /= numbers.size();\n  double sum = 0;\n  for (double x : numbers) {\n    sum += abs(x - mean);\n  }\n  return sum / numbers.size();\n}",
  "Java_humaneval-004": "public static Double meanAbsoluteDeviation(List<Double> numbers) {\n  Double mean = numbers.stream().mapToDouble(num -> num).average().orElse(0.0);\n  return numbers.stream().mapToDouble(num -> Math.abs(num - mean)).average().orElse(0.0);\n}",
  "Python_humaneval-004": "def mean_absolute_deviation(numbers: List[float]) -> float:\n    mean = sum(numbers) / len(numbers)\n    return sum(abs(x - mean) for x in numbers) / len(numbers)",
  "C#_humaneval-004": "public static double MeanAbsoluteDeviation(List<double> numbers) {\n  double mean = numbers.Sum() / numbers.Count;\n  return numbers.Select(x => Math.Abs(x - mean)).Sum() / numbers.Count;\n}",
  "JavaScript_humaneval-004": "function meanAbsoluteDeviation(numbers) {\n  const mean = numbers.reduce((a, b) => a + b, 0) / numbers.length;\n  return numbers.reduce((a, b) => a + Math.abs(b - mean), 0) / numbers.length;\n}",
  "Go_humaneval-004": "func meanAbsoluteDeviation(numbers []float64) float64 {\n    var sum float64\n    for _, x := range numbers {\n        sum += x\n    }\n    mean := sum / float64(len(numbers))\n    var absSum float64\n    for _, x := range numbers {\n        absSum += math.Abs(x - mean)\n    }\n    return absSum / float64(len(numbers))\n}",
  "PHP_humaneval-004": "function meanAbsoluteDeviation(array $numbers): float {\n    $mean = array_sum($numbers) / count($numbers);\n    return array_sum(array_map(function($x) use ($mean) {\n        return abs($x - $mean);\n    }, $numbers)) / count($numbers);\n}",
  "Ruby_humaneval-004": "def mean_absolute_deviation(numbers)\n  mean = numbers.sum / numbers.length\n  numbers.map { |x| (x - mean).abs }.sum / numbers.length\nend",
  "Swift_humaneval-004": "func meanAbsoluteDeviation(_ numbers: [Double]) -> Double {\n  let mean = numbers.reduce(0, +) / Double(numbers.count)\n  return numbers.reduce(0) { $0 + abs($1 - mean) } / Double(numbers.count)\n}",
  "TypeScript_humaneval-004": "function meanAbsoluteDeviation(numbers: number[]): number {\n  const mean = numbers.reduce((sum, x) => sum + x, 0) / numbers.length;\n  return (\n    numbers.reduce((sum, x) => sum + Math.abs(x - mean), 0) / numbers.length\n  );\n}",
  "Dart_humaneval-004": "double meanAbsoluteDeviation(List<double> numbers) {\n  double mean = numbers.reduce((a, b) => a + b) / numbers.length;\n  return numbers.map((x) => (x - mean).abs()).reduce((a, b) => a + b) /\n      numbers.length;\n}",
  "Rust_humaneval-004": "fn mean_absolute_deviation(numbers: Vec<f64>) -> f64 {\n    let mean = numbers.iter().sum::<f64>() / numbers.len() as f64;\n    numbers.iter().map(|x| (x - mean).abs()).sum::<f64>() / numbers.len() as f64\n}",
  "Scala_humaneval-004": "def meanAbsoluteDeviation(numbers: List[Double]): Double = {\n  val mean = numbers.sum / numbers.length\n  numbers.map(x => abs(x - mean)).sum / numbers.length\n}",
  "Kotlin_humaneval-004": "fun meanAbsoluteDeviation(numbers: List<Double>): Double {\n  val mean = numbers.sum() / numbers.size\n  return numbers.map { abs(it - mean) }.sum() / numbers.size\n}",
  "C++_humaneval-005": "vector<int> intersperse(vector<int> numbers, int delimiter) {\n  vector<int> result;\n  for (int i = 0; i < numbers.size(); i++) {\n    if (i != 0) {\n      result.push_back(delimiter);\n    }\n    result.push_back(numbers[i]);\n  }\n  return result;\n}",
  "Java_humaneval-005": "public static List<Integer> intersperse(List<Integer> numbers, Integer delimiter) {\n  List<Integer> result = new ArrayList<>();\n  for (int i = 0; i < numbers.size(); i++) {\n    if (i != 0) {\n      result.add(delimiter);\n    }\n    result.add(numbers.get(i));\n  }\n  return result;\n}",
  "Python_humaneval-005": "def intersperse(numbers: List[int], delimiter: int) -> List[int]:\n    result = []\n    for i in range(len(numbers)):\n        if i != 0:\n            result.append(delimiter)\n        result.append(numbers[i])\n    return result",
  "C#_humaneval-005": "public static List<int> Intersperse(List<int> numbers, int delimiter) {\n  List<int> result = new List<int>();\n  for (int i = 0; i < numbers.Count; i++) {\n    if (i != 0) {\n      result.Add(delimiter);\n    }\n    result.Add(numbers[i]);\n  }\n  return result;\n}",
  "JavaScript_humaneval-005": "function intersperse(numbers, delimiter) {\n  let result = [];\n  for (let i = 0; i < numbers.length; i++) {\n    if (i !== 0) {\n      result.push(delimiter);\n    }\n    result.push(numbers[i]);\n  }\n  return result;\n}",
  "Go_humaneval-005": "func intersperse(numbers []int, delimiter int) []int {\n    result := []int{}\n    for i, num := range numbers {\n        if i != 0 {\n            result = append(result, delimiter)\n        }\n        result = append(result, num)\n    }\n    return result\n}",
  "PHP_humaneval-005": "function intersperse(array $numbers, int $delimiter): array {\n    $result = [];\n    for ($i = 0; $i < count($numbers); $i++) {\n        if ($i != 0) {\n            array_push($result, $delimiter);\n        }\n        array_push($result, $numbers[$i]);\n    }\n    return $result;\n}",
  "Ruby_humaneval-005": "def intersperse(numbers, delimiter)\n  result = []\n  numbers.each_with_index do |num, i|\n    result << delimiter if i != 0\n    result << num\n  end\n  result\nend",
  "Swift_humaneval-005": "func intersperse(_ numbers: [Int], _ delimiter: Int) -> [Int] {\n  var result = [Int]()\n  for i in 0..<numbers.count {\n    if i != 0 {\n      result.append(delimiter)\n    }\n    result.append(numbers[i])\n  }\n  return result\n}",
  "TypeScript_humaneval-005": "function intersperse(numbers: number[], delimiter: number): number[] {\n  const result: number[] = [];\n  for (let i = 0; i < numbers.length; i++) {\n    if (i !== 0) {\n      result.push(delimiter);\n    }\n    result.push(numbers[i]);\n  }\n  return result;\n}",
  "Dart_humaneval-005": "List<int> intersperse(List<int> numbers, int delimiter) {\n  List<int> result = [];\n  for (int i = 0; i < numbers.length; i++) {\n    if (i != 0) {\n      result.add(delimiter);\n    }\n    result.add(numbers[i]);\n  }\n  return result;\n}",
  "Rust_humaneval-005": "fn intersperse(numbers: Vec<i32>, delimiter: i32) -> Vec<i32> {\n    let mut result = Vec::new();\n    for (i, num) in numbers.iter().enumerate() {\n        if i != 0 {\n            result.push(delimiter);\n        }\n        result.push(*num);\n    }\n    result\n}",
  "Scala_humaneval-005": "def intersperse(numbers: List[Int], delimiter: Int): List[Int] = {\n  var result = List[Int]()\n  for (i <- numbers.indices) {\n    if (i != 0) {\n      result = result :+ delimiter\n    }\n    result = result :+ numbers(i)\n  }\n  result\n}",
  "Kotlin_humaneval-005": "fun intersperse(numbers: List<Int>, delimiter: Int): List<Int> {\n  val result = mutableListOf<Int>()\n  for (i in numbers.indices) {\n    if (i != 0) {\n      result.add(delimiter)\n    }\n    result.add(numbers[i])\n  }\n  return result\n}",
  "C++_humaneval-006": "vector<int> parseNestedParens(string paren_string) {\n  vector<int> result;\n  stringstream ss(paren_string);\n  string group;\n  while (getline(ss, group, ' ')) {\n    int max_depth = 0;\n    int depth = 0;\n    for (char c : group) {\n      if (c == '(') {\n        depth++;\n        max_depth = max(max_depth, depth);\n      } else if (c == ')') {\n        depth--;\n      }\n    }\n    result.push_back(max_depth);\n  }\n  return result;\n}",
  "Java_humaneval-006": "public static List<Integer> parseNestedParens(String parenString) {\n  List<Integer> result = new ArrayList<>();\n  for (String group : parenString.split(\" \")) {\n    int maxDepth = 0;\n    int depth = 0;\n    for (char c : group.toCharArray()) {\n      if (c == '(') {\n        depth++;\n        maxDepth = Math.max(maxDepth, depth);\n      } else if (c == ')') {\n        depth--;\n      }\n    }\n    result.add(maxDepth);\n  }\n  return result;\n}",
  "Python_humaneval-006": "def parse_nested_parens(paren_string: str) -> List[int]:\n    result = []\n    for group in paren_string.split():\n        max_depth = 0\n        depth = 0\n        for char in group:\n            if char == \"(\":\n                depth += 1\n                max_depth = max(max_depth, depth)\n            elif char == \")\":\n                depth -= 1\n        result.append(max_depth)\n    return result",
  "C#_humaneval-006": "public static List<int> ParseNestedParens(string parenString) {\n  List<int> result = new List<int>();\n  foreach (string group in parenString.Split()) {\n    int maxDepth = 0;\n    int depth = 0;\n    foreach (char ch in group) {\n      if (ch == '(') {\n        depth++;\n        maxDepth = Math.Max(maxDepth, depth);\n      } else if (ch == ')') {\n        depth--;\n      }\n    }\n    result.Add(maxDepth);\n  }\n  return result;\n}",
  "JavaScript_humaneval-006": "function parseNestedParens(parenString) {\n  const result = [];\n  for (const group of parenString.split(\" \")) {\n    let maxDepth = 0;\n    let depth = 0;\n    for (const char of group) {\n      if (char === \"(\") {\n        depth++;\n        maxDepth = Math.max(maxDepth, depth);\n      } else if (char === \")\") {\n        depth--;\n      }\n    }\n    result.push(maxDepth);\n  }\n  return result;\n}",
  "Go_humaneval-006": "func parseNestedParens(parenString string) []int {\n    result := []int{}\n    for _, group := range strings.Split(parenString, \" \") {\n        maxDepth := 0\n        depth := 0\n        for _, char := range group {\n            if char == '(' {\n                depth++\n                if depth > maxDepth {\n                    maxDepth = depth\n                }\n            } else if char == ')' {\n                depth--\n            }\n        }\n        result = append(result, maxDepth)\n    }\n    return result\n}",
  "PHP_humaneval-006": "function parseNestedParens(string $parenString): array {\n    $result = [];\n    $groups = explode(\" \", $parenString);\n    foreach ($groups as $group) {\n        $maxDepth = 0;\n        $depth = 0;\n        for ($i = 0; $i < strlen($group); $i++) {\n            $char = $group[$i];\n            if ($char == \"(\") {\n                $depth++;\n                $maxDepth = max($maxDepth, $depth);\n            } elseif ($char == \")\") {\n                $depth--;\n            }\n        }\n        $result[] = $maxDepth;\n    }\n    return $result;\n}",
  "Ruby_humaneval-006": "def parse_nested_parens(paren_string)\n  result = []\n  paren_string.split.each do |group|\n    max_depth = 0\n    depth = 0\n    group.each_char do |char|\n      if char == \"(\"\n        depth += 1\n        max_depth = [max_depth, depth].max\n      elsif char == \")\"\n        depth -= 1\n      end\n    end\n    result << max_depth\n  end\n  result\nend",
  "Swift_humaneval-006": "func parseNestedParens(_ parenString: String) -> [Int] {\n  var result = [Int]()\n  for group in parenString.split(separator: \" \") {\n    var maxDepth = 0\n    var depth = 0\n    for char in group {\n      if char == \"(\" {\n        depth += 1\n        maxDepth = max(maxDepth, depth)\n      } else if char == \")\" {\n        depth -= 1\n      }\n    }\n    result.append(maxDepth)\n  }\n  return result\n}",
  "TypeScript_humaneval-006": "function parseNestedParens(parenString: string): number[] {\n  const result: number[] = [];\n  for (const group of parenString.split(\" \")) {\n    let maxDepth = 0;\n    let depth = 0;\n    for (const char of group) {\n      if (char === \"(\") {\n        depth += 1;\n        maxDepth = Math.max(maxDepth, depth);\n      } else if (char === \")\") {\n        depth -= 1;\n      }\n    }\n    result.push(maxDepth);\n  }\n  return result;\n}",
  "Dart_humaneval-006": "List<int> parseNestedParens(String parenString) {\n  List<int> result = [];\n  for (String group in parenString.split(\" \")) {\n    int maxDepth = 0;\n    int depth = 0;\n    for (int i = 0; i < group.length; i++) {\n      String char = group[i];\n      if (char == \"(\") {\n        depth += 1;\n        maxDepth = max(maxDepth, depth);\n      } else if (char == \")\") {\n        depth -= 1;\n      }\n    }\n    result.add(maxDepth);\n  }\n  return result;\n}",
  "Rust_humaneval-006": "fn parse_nested_parens(paren_string: String) -> Vec<i32> {\n    let mut result = Vec::new();\n    for group in paren_string.split_whitespace() {\n        let mut max_depth = 0;\n        let mut depth = 0;\n        for char in group.chars() {\n            if char == '(' {\n                depth += 1;\n                max_depth = max_depth.max(depth);\n            } else if char == ')' {\n                depth -= 1;\n            }\n        }\n        result.push(max_depth);\n    }\n    result\n}",
  "Scala_humaneval-006": "def parseNestedParens(parenString: String): List[Int] = {\n  var result = List[Int]()\n  for (group <- parenString.split(\" \")) {\n    var maxDepth = 0\n    var depth = 0\n    for (char <- group) {\n      if (char == '(') {\n        depth += 1\n        maxDepth = maxDepth.max(depth)\n      } else if (char == ')') {\n        depth -= 1\n      }\n    }\n    result = result :+ maxDepth\n  }\n  result\n}",
  "Kotlin_humaneval-006": "fun parseNestedParens(parenString: String): List<Int> {\n  val result = mutableListOf<Int>()\n  for (group in parenString.split(\" \")) {\n    var maxDepth = 0\n    var depth = 0\n    for (char in group) {\n      if (char == '(') {\n        depth++\n        maxDepth = maxOf(maxDepth, depth)\n      } else if (char == ')') {\n        depth--\n      }\n    }\n    result.add(maxDepth)\n  }\n  return result\n}",
  "C++_humaneval-007": "vector<string> filterBySubstring(vector<string> words, string substring) {\n  vector<string> result;\n  for (string s : words) {\n    if (s.find(substring) != string::npos) {\n      result.push_back(s);\n    }\n  }\n  return result;\n}",
  "Java_humaneval-007": "public static List<String> filterBySubstring(List<String> words, String substring) {\n  List<String> result = new ArrayList<>();\n  for (String s : words) {\n    if (s.contains(substring)) {\n      result.add(s);\n    }\n  }\n  return result;\n}",
  "Python_humaneval-007": "def filter_by_substring(words: List[str], substring: str) -> List[str]:\n    return [s for s in words if substring in s]",
  "C#_humaneval-007": "public static List<string> FilterBySubstring(List<string> words, string substring) {\n  return words.Where(s => s.Contains(substring)).ToList();\n}",
  "JavaScript_humaneval-007": "function filterBySubstring(words, substring) {\n  return words.filter((s) => s.includes(substring));\n}",
  "Go_humaneval-007": "func filterBySubstring(words []string, substring string) []string {\n    var filteredStrings []string\n    for _, s := range words {\n        if strings.Contains(s, substring) {\n            filteredStrings = append(filteredStrings, s)\n        }\n    }\n    return filteredStrings\n}",
  "PHP_humaneval-007": "function filterBySubstring(array $words, string $substring): array {\n    return array_values(array_filter($words, function($s) use ($substring) {\n        return strpos($s, $substring) !== false;\n    }));\n}",
  "Ruby_humaneval-007": "def filter_by_substring(words, substring)\n  words.select { |s| s.include?(substring) }\nend",
  "Swift_humaneval-007": "func filterBySubstring(_ words: [String], _ substring: String) -> [String] {\n  return words.filter { $0.contains(substring) }\n}",
  "TypeScript_humaneval-007": "function filterBySubstring(words: string[], substring: string): string[] {\n  return words.filter((s) => s.includes(substring));\n}",
  "Dart_humaneval-007": "List<String> filterBySubstring(List<String> words, String substring) {\n  return words.where((s) => s.contains(substring)).toList();\n}",
  "Rust_humaneval-007": "fn filter_by_substring(words: Vec<String>, substring: String) -> Vec<String> {\n    words\n        .into_iter()\n        .filter(|s| s.contains(&substring))\n        .collect()\n}",
  "Scala_humaneval-007": "def filterBySubstring(words: List[String], substring: String): List[String] = {\n  words.filter(_.contains(substring))\n}",
  "Kotlin_humaneval-007": "fun filterBySubstring(words: List<String>, substring: String): List<String> {\n  return words.filter { s -> substring in s }\n}",
  "C++_humaneval-008": "vector<int> sumProduct(vector<int> numbers) {\n  if (numbers.empty()) {\n    return {0, 1};\n  } else {\n    int product = 1;\n    for (int num : numbers) {\n      product *= num;\n    }\n    return {accumulate(numbers.begin(), numbers.end(), 0), product};\n  }\n}",
  "Java_humaneval-008": "public static List<Integer> sumProduct(List<Integer> numbers) {\n  if (numbers.isEmpty()) {\n    return List.of(0, 1);\n  } else {\n    int product = 1;\n    for (int num : numbers) {\n      product *= num;\n    }\n    int sum = numbers.stream().mapToInt(Integer::intValue).sum();\n    return List.of(sum, product);\n  }\n}",
  "Python_humaneval-008": "def sum_product(numbers: List[int]) -> List[int]:\n    if not numbers:\n        return [0, 1]\n    else:\n        product = 1\n        for num in numbers:\n            product *= num\n        return [sum(numbers), product]",
  "C#_humaneval-008": "public static List<int> SumProduct(List<int> numbers) {\n  if (numbers.Count == 0) {\n    return new List<int> { 0, 1 };\n  } else {\n    int product = 1;\n    foreach (int num in numbers) {\n      product *= num;\n    }\n    return new List<int> { numbers.Sum(), product };\n  }\n}",
  "JavaScript_humaneval-008": "function sumProduct(numbers) {\n  if (!numbers.length) {\n    return [0, 1];\n  } else {\n    let product = 1;\n    for (let num of numbers) {\n      product *= num;\n    }\n    return [numbers.reduce((a, b) => a + b), product];\n  }\n}",
  "Go_humaneval-008": "func sumProduct(numbers []int) []int {\n    if len(numbers) == 0 {\n        return []int{0, 1}\n    } else {\n        product := 1\n        for _, num := range numbers {\n            product *= num\n        }\n        sum := 0\n        for _, num := range numbers {\n            sum += num\n        }\n        return []int{sum, product}\n    }\n}",
  "PHP_humaneval-008": "function sumProduct(array $numbers): array {\n    if (empty($numbers)) {\n        return [0, 1];\n    } else {\n        $product = 1;\n        foreach ($numbers as $num) {\n            $product *= $num;\n        }\n        return [array_sum($numbers), $product];\n    }\n}",
  "Ruby_humaneval-008": "def sum_product(numbers)\n  if numbers.empty?\n    return 0, 1\n  else\n    product = 1\n    numbers.each { |num| product *= num }\n    return numbers.sum, product\n  end\nend",
  "Swift_humaneval-008": "func sumProduct(_ numbers: [Int]) -> [Int] {\n  if numbers.isEmpty {\n    return [0, 1]\n  } else {\n    var product = 1\n    for num in numbers {\n      product *= num\n    }\n    return [numbers.reduce(0, +), product]\n  }\n}",
  "TypeScript_humaneval-008": "function sumProduct(numbers: number[]): number[] {\n  if (!numbers.length) {\n    return [0, 1];\n  } else {\n    let product = 1;\n    for (const num of numbers) {\n      product *= num;\n    }\n    return [numbers.reduce((a, b) => a + b), product];\n  }\n}",
  "Dart_humaneval-008": "List<int> sumProduct(List<int> numbers) {\n  if (numbers.isEmpty) {\n    return [0, 1];\n  } else {\n    int product = 1;\n    for (int num in numbers) {\n      product *= num;\n    }\n    return [numbers.reduce((a, b) => a + b), product];\n  }\n}",
  "Rust_humaneval-008": "fn sum_product(numbers: Vec<i32>) -> Vec<i32> {\n    if numbers.is_empty() {\n        return vec![0, 1];\n    } else {\n        let product = numbers.iter().fold(1, |acc, x| acc * x);\n        let sum = numbers.iter().sum();\n        return vec![sum, product];\n    }\n}",
  "Scala_humaneval-008": "def sumProduct(numbers: List[Int]): List[Int] = {\n  if (numbers.isEmpty) {\n    List(0, 1)\n  } else {\n    val product = numbers.product\n    List(numbers.sum, product)\n  }\n}",
  "Kotlin_humaneval-008": "fun sumProduct(numbers: List<Int>): List<Int> {\n  if (numbers.isEmpty()) {\n    return listOf(0, 1)\n  } else {\n    var product = 1\n    for (num in numbers) {\n      product *= num\n    }\n    return listOf(numbers.sum(), product)\n  }\n}",
  "C++_humaneval-009": "vector<int> rollingMax(vector<int> numbers) {\n  int max_so_far = numeric_limits<int>::min();\n  vector<int> rolling_max_list;\n  for (int num : numbers) {\n    max_so_far = max(max_so_far, num);\n    rolling_max_list.push_back(max_so_far);\n  }\n  return rolling_max_list;\n}",
  "Java_humaneval-009": "public static List<Integer> rollingMax(List<Integer> numbers) {\n  int maxSoFar = Integer.MIN_VALUE;\n  List<Integer> rollingMaxList = new ArrayList<>();\n  for (int num : numbers) {\n    maxSoFar = Math.max(maxSoFar, num);\n    rollingMaxList.add(maxSoFar);\n  }\n  return rollingMaxList;\n}",
  "Python_humaneval-009": "def rolling_max(numbers: List[int]) -> List[int]:\n    max_so_far = float(\"-inf\")\n    rolling_max_list = []\n    for num in numbers:\n        max_so_far = max(max_so_far, num)\n        rolling_max_list.append(max_so_far)\n    return rolling_max_list",
  "C#_humaneval-009": "public static List<int> RollingMax(List<int> numbers) {\n  int maxSoFar = int.MinValue;\n  List<int> rollingMaxList = new List<int>();\n  foreach (int num in numbers) {\n    maxSoFar = Math.Max(maxSoFar, num);\n    rollingMaxList.Add(maxSoFar);\n  }\n  return rollingMaxList;\n}",
  "JavaScript_humaneval-009": "function rollingMax(numbers) {\n  let max_so_far = Number.NEGATIVE_INFINITY;\n  let rolling_max_list = [];\n  for (let num of numbers) {\n    max_so_far = Math.max(max_so_far, num);\n    rolling_max_list.push(max_so_far);\n  }\n  return rolling_max_list;\n}",
  "Go_humaneval-009": "func rollingMax(numbers []int) []int {\n    maxSoFar := math.Inf(-1)\n    rollingMaxList := []int{}\n    for _, num := range numbers {\n        maxSoFar = math.Max(maxSoFar, float64(num))\n        rollingMaxList = append(rollingMaxList, int(maxSoFar))\n    }\n    return rollingMaxList\n}",
  "PHP_humaneval-009": "function rollingMax(array $numbers): array {\n    $max_so_far = PHP_INT_MIN;\n    $rolling_max_list = [];\n    foreach ($numbers as $num) {\n        $max_so_far = max($max_so_far, $num);\n        $rolling_max_list[] = $max_so_far;\n    }\n    return $rolling_max_list;\n}",
  "Ruby_humaneval-009": "def rolling_max(numbers)\n  max_so_far = -Float::INFINITY\n  rolling_max_list = []\n  numbers.each do |num|\n    max_so_far = [max_so_far, num].max\n    rolling_max_list << max_so_far\n  end\n  rolling_max_list\nend",
  "Swift_humaneval-009": "func rollingMax(_ numbers: [Int]) -> [Int] {\n  var maxSoFar = Int.min\n  var rollingMaxList = [Int]()\n  for num in numbers {\n    maxSoFar = max(maxSoFar, num)\n    rollingMaxList.append(maxSoFar)\n  }\n  return rollingMaxList\n}",
  "TypeScript_humaneval-009": "function rollingMax(numbers: number[]): number[] {\n  let maxSoFar = Number.NEGATIVE_INFINITY;\n  const rollingMaxList = [];\n  for (const num of numbers) {\n    maxSoFar = Math.max(maxSoFar, num);\n    rollingMaxList.push(maxSoFar);\n  }\n  return rollingMaxList;\n}",
  "Dart_humaneval-009": "List<int> rollingMax(List<int> numbers) {\n  var maxSoFar = -double.maxFinite.toInt();\n  var rollingMaxList = <int>[];\n  for (var num in numbers) {\n    maxSoFar = num > maxSoFar ? num : maxSoFar;\n    rollingMaxList.add(maxSoFar.toInt());\n  }\n  return rollingMaxList;\n}",
  "Rust_humaneval-009": "fn rolling_max(numbers: Vec<i32>) -> Vec<i32> {\n    let mut max_so_far = std::i32::MIN;\n    let mut rolling_max_list = Vec::new();\n    for num in numbers {\n        max_so_far = max_so_far.max(num);\n        rolling_max_list.push(max_so_far);\n    }\n    rolling_max_list\n}",
  "Scala_humaneval-009": "def rollingMax(numbers: List[Int]): List[Int] = {\n  var maxSoFar = Int.MinValue\n  var rollingMaxList = List[Int]()\n  for (num <- numbers) {\n    maxSoFar = max(maxSoFar, num)\n    rollingMaxList = rollingMaxList :+ maxSoFar\n  }\n  rollingMaxList\n}",
  "Kotlin_humaneval-009": "fun rollingMax(numbers: List<Int>): List<Int> {\n  var maxSoFar = Int.MIN_VALUE\n  val rollingMaxList = mutableListOf<Int>()\n  for (num in numbers) {\n    maxSoFar = maxOf(maxSoFar, num)\n    rollingMaxList.add(maxSoFar)\n  }\n  return rollingMaxList\n}",
  "C++_humaneval-010": "bool isPalindrome(string s) { return s == string(s.rbegin(), s.rend()); }\nstring makePalindrome(string s) {\n  if (isPalindrome(s)) {\n    return s;\n  }\n  for (int i = 0; i < s.length(); i++) {\n    if (isPalindrome(s.substr(i))) {\n      return s + string(s.rbegin() + 1, s.rbegin() + i + 1);\n    }\n  }\n  return \"\";\n}",
  "Java_humaneval-010": "public static boolean isPalindrome(String s) {\n  return s.equals(new StringBuilder(s).reverse().toString());\n}\npublic static String makePalindrome(String s) {\n  if (isPalindrome(s)) {\n    return s;\n  }\n  for (int i = 0; i < s.length(); i++) {\n    if (isPalindrome(s.substring(i))) {\n      return s + new StringBuilder(s.substring(0, i)).reverse().toString();\n    }\n  }\n  return \"\";\n}",
  "Python_humaneval-010": "def is_palindrome(s):\n    return s == s[::-1]\ndef make_palindrome(s: str) -> str:\n    if is_palindrome(s):\n        return s\n    for i in range(len(s)):\n        if is_palindrome(s[i:]):\n            return s + s[:i][::-1]",
  "C#_humaneval-010": "public static bool IsPalindrome(string s) {\n  return s == new string(s.Reverse().ToArray());\n}\npublic static string MakePalindrome(string s) {\n  if (IsPalindrome(s)) {\n    return s;\n  }\n  for (int i = 0; i < s.Length; i++) {\n    if (IsPalindrome(s.Substring(i))) {\n      return s + new string(s.Substring(0, i).Reverse().ToArray());\n    }\n  }\n  return \"\";\n}",
  "JavaScript_humaneval-010": "function isPalindrome(s) {\n  return s === s.split(\"\").reverse().join(\"\");\n}\nfunction makePalindrome(s) {\n  if (isPalindrome(s)) {\n    return s;\n  }\n  for (let i = 0; i < s.length; i++) {\n    if (isPalindrome(s.slice(i))) {\n      return s + s.slice(0, i).split(\"\").reverse().join(\"\");\n    }\n  }\n}",
  "Go_humaneval-010": "func isPalindrome(s string) bool {\n    for i := 0; i < len(s)/2; i++ {\n        if s[i] != s[len(s)-i-1] {\n            return false\n        }\n    }\n    return true\n}\nfunc makePalindrome(s string) string {\n    if isPalindrome(s) {\n        return s\n    }\n    for i := range s {\n        if isPalindrome(s[i:]) {\n            return s + reverse(s[:i])\n        }\n    }\n    return \"\"\n}\nfunc reverse(s string) string {\n    runes := []rune(s)\n    for i, j := 0, len(runes)-1; i < j; i, j = i+1, j-1 {\n        runes[i], runes[j] = runes[j], runes[i]\n    }\n    return string(runes)\n}",
  "PHP_humaneval-010": "function is_palindrome($s) {\n    return $s == strrev($s);\n}\nfunction makePalindrome(string $s): string {\n    if (is_palindrome($s)) {\n        return $s;\n    }\n    for ($i = 0; $i < strlen($s); $i++) {\n        if (is_palindrome(substr($s, $i))) {\n            return $s . strrev(substr($s, 0, $i));\n        }\n    }\n}",
  "Ruby_humaneval-010": "def is_palindrome(s)\n  s == s.reverse\nend\ndef make_palindrome(s)\n  return s if is_palindrome(s)\n  (0...s.length).each do |i|\n    return s + s[0...i].reverse if is_palindrome(s[i..])\n  end\nend",
  "Swift_humaneval-010": "func isPalindrome(_ s: String) -> Bool {\n  return s == String(s.reversed())\n}\nfunc makePalindrome(_ s: String) -> String {\n  if isPalindrome(s) {\n    return s\n  }\n  for i in 0..<s.count {\n    let index = s.index(s.startIndex, offsetBy: i)\n    if isPalindrome(String(s[index...])) {\n      return s + String(s[..<index].reversed())\n    }\n  }\n  return s\n}",
  "TypeScript_humaneval-010": "function isPalindrome(s: string): boolean {\n  return s === s.split(\"\").reverse().join(\"\");\n}\nfunction makePalindrome(s: string): string {\n  if (isPalindrome(s)) {\n    return s;\n  }\n  for (let i = 0; i < s.length; i++) {\n    if (isPalindrome(s.slice(i))) {\n      return s + s.slice(0, i).split(\"\").reverse().join(\"\");\n    }\n  }\n}",
  "Dart_humaneval-010": "bool isPalindrome(String s) {\n  return s == s.split('').reversed.join('');\n}\nString makePalindrome(String s) {\n  if (isPalindrome(s)) {\n    return s;\n  }\n  for (int i = 0; i < s.length; i++) {\n    if (isPalindrome(s.substring(i))) {\n      return s + s.substring(0, i).split('').reversed.join('');\n    }\n  }\n  return '';\n}",
  "Rust_humaneval-010": "fn is_palindrome(s: &str) -> bool {\n    s == s.chars().rev().collect::<String>()\n}\nfn make_palindrome(s: String) -> String {\n    if is_palindrome(&s) {\n        return s;\n    }\n    for i in 0..s.len() {\n        if is_palindrome(&s[i..]) {\n            return s.to_owned() + &s[..i].chars().rev().collect::<String>();\n        }\n    }\n    s\n}",
  "Scala_humaneval-010": "def isPalindrome(s: String): Boolean = s == s.reverse\ndef makePalindrome(s: String): String = {\n  if (isPalindrome(s)) s\n  else {\n    for (i <- 0 until s.length) {\n      if (isPalindrome(s.substring(i))) {\n        return s + s.substring(0, i).reverse\n      }\n    }\n    s + s.reverse\n  }\n}",
  "Kotlin_humaneval-010": "fun isPalindrome(s: String): Boolean {\n  return s == s.reversed()\n}\nfun makePalindrome(s: String): String {\n  if (isPalindrome(s)) {\n    return s\n  }\n  for (i in s.indices) {\n    if (isPalindrome(s.substring(i))) {\n      return s + s.substring(0, i).reversed()\n    }\n  }\n  return s\n}",
  "C++_humaneval-011": "string stringXor(string a, string b) {\n  string result = \"\";\n  for (int i = 0; i < a.length(); i++) {\n    if (a[i] == b[i]) {\n      result += \"0\";\n    } else {\n      result += \"1\";\n    }\n  }\n  return result;\n}",
  "Java_humaneval-011": "public static String stringXor(String a, String b) {\n  String result = \"\";\n  for (int i = 0; i < a.length(); i++) {\n    if (a.charAt(i) == b.charAt(i)) {\n      result += \"0\";\n    } else {\n      result += \"1\";\n    }\n  }\n  return result;\n}",
  "Python_humaneval-011": "def string_xor(a: str, b: str) -> str:\n    result = \"\"\n    for i in range(len(a)):\n        if a[i] == b[i]:\n            result += \"0\"\n        else:\n            result += \"1\"\n    return result",
  "C#_humaneval-011": "public static string StringXor(string a, string b) {\n  string result = \"\";\n  for (int i = 0; i < a.Length; i++) {\n    if (a[i] == b[i]) {\n      result += \"0\";\n    } else {\n      result += \"1\";\n    }\n  }\n  return result;\n}",
  "JavaScript_humaneval-011": "function stringXor(a, b) {\n  let result = \"\";\n  for (let i = 0; i < a.length; i++) {\n    if (a[i] === b[i]) {\n      result += \"0\";\n    } else {\n      result += \"1\";\n    }\n  }\n  return result;\n}",
  "Go_humaneval-011": "func stringXor(a string, b string) string {\n    result := \"\"\n    for i := 0; i < len(a); i++ {\n        if a[i] == b[i] {\n            result += \"0\"\n        } else {\n            result += \"1\"\n        }\n    }\n    return result\n}",
  "PHP_humaneval-011": "function stringXor(string $a, string $b): string {\n    $result = \"\";\n    for ($i = 0; $i < strlen($a); $i++) {\n        if ($a[$i] == $b[$i]) {\n            $result .= \"0\";\n        } else {\n            $result .= \"1\";\n        }\n    }\n    return $result;\n}",
  "Ruby_humaneval-011": "def string_xor(a, b)\n  result = \"\"\n  for i in 0...a.length\n    if a[i] == b[i]\n      result += \"0\"\n    else\n      result += \"1\"\n    end\n  end\n  return result\nend",
  "Swift_humaneval-011": "func stringXor(_ a: String, _ b: String) -> String {\n  var result = \"\"\n  for i in 0..<a.count {\n    let index = a.index(a.startIndex, offsetBy: i)\n    if a[index] == b[index] {\n      result += \"0\"\n    } else {\n      result += \"1\"\n    }\n  }\n  return result\n}",
  "TypeScript_humaneval-011": "function stringXor(a: string, b: string): string {\n  let result = \"\";\n  for (let i = 0; i < a.length; i++) {\n    if (a[i] === b[i]) {\n      result += \"0\";\n    } else {\n      result += \"1\";\n    }\n  }\n  return result;\n}",
  "Dart_humaneval-011": "String stringXor(String a, String b) {\n  String result = \"\";\n  for (int i = 0; i < a.length; i++) {\n    if (a[i] == b[i]) {\n      result += \"0\";\n    } else {\n      result += \"1\";\n    }\n  }\n  return result;\n}",
  "Rust_humaneval-011": "fn string_xor(a: String, b: String) -> String {\n    let mut result = String::new();\n    for (char_a, char_b) in a.chars().zip(b.chars()) {\n        if char_a == char_b {\n            result.push('0');\n        } else {\n            result.push('1');\n        }\n    }\n    result\n}",
  "Scala_humaneval-011": "def stringXor(a: String, b: String): String = {\n  var result = \"\"\n  for (i <- 0 until a.length) {\n    if (a(i) == b(i)) {\n      result += \"0\"\n    } else {\n      result += \"1\"\n    }\n  }\n  result\n}",
  "Kotlin_humaneval-011": "fun stringXor(a: String, b: String): String {\n  var result = \"\"\n  for (i in a.indices) {\n    if (a[i] == b[i]) {\n      result += \"0\"\n    } else {\n      result += \"1\"\n    }\n  }\n  return result\n}",
  "C++_humaneval-012": "string longest(vector<string> words) {\n  if (words.empty()) {\n    return \"\";\n  }\n  string longest_string = words[0];\n  for (string s : words) {\n    if (s.length() > longest_string.length()) {\n      longest_string = s;\n    }\n  }\n  return longest_string;\n}",
  "Java_humaneval-012": "public static String longest(List<String> words) {\n  if (words.isEmpty()) {\n    return \"\";\n  }\n  String longestString = words.get(0);\n  for (String string : words) {\n    if (string.length() > longestString.length()) {\n      longestString = string;\n    }\n  }\n  return longestString;\n}",
  "Python_humaneval-012": "def longest(words: List[str]) -> str:\n    if not words:\n        return \"\"\n    longest_string = words[0]\n    for string in words:\n        if len(string) > len(longest_string):\n            longest_string = string\n    return longest_string",
  "C#_humaneval-012": "public static string Longest(List<string> words) {\n  if (words == null || words.Count == 0) {\n    return \"\";\n  }\n  string longestString = words[0];\n  foreach (string str in words) {\n    if (str.Length > longestString.Length) {\n      longestString = str;\n    }\n  }\n  return longestString;\n}",
  "JavaScript_humaneval-012": "function longest(words) {\n  if (!words.length) {\n    return \"\";\n  }\n  let longest_string = words[0];\n  for (let string of words) {\n    if (string.length > longest_string.length) {\n      longest_string = string;\n    }\n  }\n  return longest_string;\n}",
  "Go_humaneval-012": "func longest(words []string) string {\n    if len(words) == 0 {\n        return \"\"\n    }\n    longestString := words[0]\n    for _, s := range words {\n        if len(s) > len(longestString) {\n            longestString = s\n        }\n    }\n    return longestString\n}",
  "PHP_humaneval-012": "function longest(array $words): string {\n    if (empty($words)) {\n        return \"\";\n    }\n    $longest_string = $words[0];\n    foreach ($words as $string) {\n        if (strlen($string) > strlen($longest_string)) {\n            $longest_string = $string;\n        }\n    }\n    return $longest_string;\n}",
  "Ruby_humaneval-012": "def longest(words)\n  return \"\" if words.empty?\n  longest_string = words[0]\n  words.each do |string|\n    longest_string = string if string.length > longest_string.length\n  end\n  longest_string\nend",
  "Swift_humaneval-012": "func longest(_ words: [String]) -> String {\n  if words.isEmpty {\n    return \"\"\n  }\n  var longestString = words[0]\n  for string in words {\n    if string.count > longestString.count {\n      longestString = string\n    }\n  }\n  return longestString\n}",
  "TypeScript_humaneval-012": "function longest(words: string[]): string {\n  if (!words.length) {\n    return \"\";\n  }\n  let longestString = words[0];\n  for (const string of words) {\n    if (string.length > longestString.length) {\n      longestString = string;\n    }\n  }\n  return longestString;\n}",
  "Dart_humaneval-012": "String longest(List<String> words) {\n  if (words.isEmpty) {\n    return \"\";\n  }\n  String longestString = words[0];\n  for (String string in words) {\n    if (string.length > longestString.length) {\n      longestString = string;\n    }\n  }\n  return longestString;\n}",
  "Rust_humaneval-012": "fn longest(words: Vec<String>) -> String {\n    if words.is_empty() {\n        return \"\".to_string();\n    }\n    let mut longest_string = words[0].clone();\n    for string in words {\n        if string.len() > longest_string.len() {\n            longest_string = string;\n        }\n    }\n    longest_string\n}",
  "Scala_humaneval-012": "def longest(words: List[String]): String = {\n  if (words.isEmpty) {\n    return \"\"\n  }\n  var longestString = words.head\n  for (string <- words) {\n    if (string.length > longestString.length) {\n      longestString = string\n    }\n  }\n  longestString\n}",
  "Kotlin_humaneval-012": "fun longest(words: List<String>): String {\n  if (words.isEmpty()) {\n    return \"\"\n  }\n  var longestString = words[0]\n  for (string in words) {\n    if (string.length > longestString.length) {\n      longestString = string\n    }\n  }\n  return longestString\n}",
  "C++_humaneval-013": "int greatestCommonDivisor(int a, int b) {\n  if (b == 0) {\n    return a;\n  } else {\n    return greatest_common_divisor(b, a % b);\n  }\n}",
  "Java_humaneval-013": "public static Integer greatestCommonDivisor(Integer a, Integer b) {\n  if (b == 0) {\n    return a;\n  } else {\n    return greatestCommonDivisor(b, a % b);\n  }\n}",
  "Python_humaneval-013": "def greatest_common_divisor(a: int, b: int) -> int:\n    if b == 0:\n        return a\n    else:\n        return greatest_common_divisor(b, a % b)",
  "C#_humaneval-013": "public static int GreatestCommonDivisor(int a, int b) {\n  if (b == 0) {\n    return a;\n  } else {\n    return GreatestCommonDivisor(b, a % b);\n  }\n}",
  "JavaScript_humaneval-013": "function greatestCommonDivisor(a, b) {\n  if (b === 0) {\n    return a;\n  } else {\n    return greatestCommonDivisor(b, a % b);\n  }\n}",
  "Go_humaneval-013": "func greatestCommonDivisor(a int, b int) int {\n    if b == 0 {\n        return a\n    } else {\n        return greatestCommonDivisor(b, a%b)\n    }\n}",
  "PHP_humaneval-013": "function greatestCommonDivisor(int $a, int $b): int {\n    if ($b == 0) {\n        return $a;\n    } else {\n        return greatestCommonDivisor($b, $a % $b);\n    }\n}",
  "Ruby_humaneval-013": "def greatest_common_divisor(a, b)\n  if b == 0\n    return a\n  else\n    return greatest_common_divisor(b, a % b)\n  end\nend",
  "Swift_humaneval-013": "func greatestCommonDivisor(_ a: Int, _ b: Int) -> Int {\n  if b == 0 {\n    return a\n  } else {\n    return greatestCommonDivisor(b, a % b)\n  }\n}",
  "TypeScript_humaneval-013": "function greatestCommonDivisor(a: number, b: number): number {\n  if (b === 0) {\n    return a;\n  } else {\n    return greatestCommonDivisor(b, a % b);\n  }\n}",
  "Dart_humaneval-013": "int greatestCommonDivisor(int a, int b) {\n  if (b == 0) {\n    return a;\n  } else {\n    return greatestCommonDivisor(b, a % b);\n  }\n}",
  "Rust_humaneval-013": "fn greatest_common_divisor(a: i32, b: i32) -> i32 {\n    if b == 0 {\n        a\n    } else {\n        greatest_common_divisor(b, a % b)\n    }\n}",
  "Scala_humaneval-013": "def greatestCommonDivisor(a: Int, b: Int): Int = {\n  if (b == 0) {\n    a\n  } else {\n    greatestCommonDivisor(b, a % b)\n  }\n}",
  "Kotlin_humaneval-013": "fun greatestCommonDivisor(a: Int, b: Int): Int {\n  return if (b == 0) a else greatestCommonDivisor(b, a % b)\n}",
  "C++_humaneval-014": "vector<string> allPrefixes(string s) {\n  vector<string> prefixes;\n  for (int i = 0; i < s.length(); i++) {\n    prefixes.push_back(s.substr(0, i + 1));\n  }\n  return prefixes;\n}",
  "Java_humaneval-014": "public static List<String> allPrefixes(String s) {\n  List<String> prefixes = new ArrayList<>();\n  for (int i = 0; i < s.length(); i++) {\n    prefixes.add(s.substring(0, i + 1));\n  }\n  return prefixes;\n}",
  "Python_humaneval-014": "def all_prefixes(s: str) -> List[str]:\n    prefixes = []\n    for i in range(len(s)):\n        prefixes.append(s[: i + 1])\n    return prefixes",
  "C#_humaneval-014": "public static List<string> AllPrefixes(string s) {\n  List<string> prefixes = new List<string>();\n  for (int i = 0; i < s.Length; i++) {\n    prefixes.Add(s.Substring(0, i + 1));\n  }\n  return prefixes;\n}",
  "JavaScript_humaneval-014": "function allPrefixes(s) {\n  let prefixes = [];\n  for (let i = 0; i < s.length; i++) {\n    prefixes.push(s.slice(0, i + 1));\n  }\n  return prefixes;\n}",
  "Go_humaneval-014": "func allPrefixes(s string) []string {\n    var prefixes []string\n    for i := 0; i < len(s); i++ {\n        prefixes = append(prefixes, s[:i+1])\n    }\n    return prefixes\n}",
  "PHP_humaneval-014": "function allPrefixes(string $s): array {\n    $prefixes = [];\n    for ($i = 0; $i < strlen($s); $i++) {\n        $prefixes[] = substr($s, 0, $i+1);\n    }\n    return $prefixes;\n}",
  "Ruby_humaneval-014": "def all_prefixes(s)\n  prefixes = []\n  s.length.times { |i| prefixes << s[0..i] }\n  prefixes\nend",
  "Swift_humaneval-014": "func allPrefixes(_ s: String) -> [String] {\n  var prefixes = [String]()\n  for i in 0..<s.count {\n    let index = s.index(s.startIndex, offsetBy: i)\n    prefixes.append(String(s[...index]))\n  }\n  return prefixes\n}",
  "TypeScript_humaneval-014": "function allPrefixes(s: string): string[] {\n  const prefixes: string[] = [];\n  for (let i = 0; i < s.length; i++) {\n    prefixes.push(s.slice(0, i + 1));\n  }\n  return prefixes;\n}",
  "Dart_humaneval-014": "List<String> allPrefixes(String s) {\n  List<String> prefixes = [];\n  for (int i = 0; i < s.length; i++) {\n    prefixes.add(s.substring(0, i + 1));\n  }\n  return prefixes;\n}",
  "Rust_humaneval-014": "fn all_prefixes(s: String) -> Vec<String> {\n    let mut prefixes = Vec::new();\n    for i in 0..s.len() {\n        prefixes.push(s[..i + 1].to_string());\n    }\n    prefixes\n}",
  "Scala_humaneval-014": "def allPrefixes(s: String): List[String] = {\n  val prefixes = ListBuffer[String]()\n  for (i <- 0 until s.length) {\n    prefixes += s.substring(0, i + 1)\n  }\n  prefixes.toList\n}",
  "Kotlin_humaneval-014": "fun allPrefixes(s: String): List<String> {\n  val prefixes = mutableListOf<String>()\n  for (i in s.indices) {\n    prefixes.add(s.substring(0, i + 1))\n  }\n  return prefixes\n}",
  "C++_humaneval-015": "string stringSequence(int n) {\n  vector<int> sequence(n + 1);\n  for (int i = 0; i <= n; i++) {\n    sequence[i] = i;\n  }\n  stringstream ss;\n  for (int i = 0; i <= n; i++) {\n    ss << sequence[i];\n    if (i != n) {\n      ss << \" \";\n    }\n  }\n  return ss.str();\n}",
  "Java_humaneval-015": "public static String stringSequence(Integer n) {\n  StringBuilder sb = new StringBuilder();\n  for (int i = 0; i <= n; i++) {\n    sb.append(i).append(\" \");\n  }\n  return sb.toString().trim();\n}",
  "Python_humaneval-015": "def string_sequence(n: int) -> str:\n    return \" \".join([str(i) for i in range(n + 1)])",
  "C#_humaneval-015": "public static string StringSequence(int n) {\n  return string.Join(\" \", Enumerable.Range(0, n + 1).Select(i => i.ToString()));\n}",
  "JavaScript_humaneval-015": "function stringSequence(n) {\n  return Array.from(Array(n + 1), (_, i) => i).join(\" \");\n}",
  "Go_humaneval-015": "func stringSequence(n int) string {\n    var seq []string\n    for i := 0; i <= n; i++ {\n        seq = append(seq, strconv.Itoa(i))\n    }\n    return strings.Join(seq, \" \")\n}",
  "PHP_humaneval-015": "function stringSequence(int $n): string {\n    $result = [];\n    for ($i = 0; $i <= $n; $i++) {\n        $result[] = strval($i);\n    }\n    return implode(\" \", $result);\n}",
  "Ruby_humaneval-015": "def string_sequence(n)\n  (0..n).to_a.join(\" \")\nend",
  "Swift_humaneval-015": "func stringSequence(_ n: Int) -> String {\n  return (0...n).map { String($0) }.joined(separator: \" \")\n}",
  "TypeScript_humaneval-015": "function stringSequence(n: number): string {\n  return [...Array(n + 1).keys()].join(\" \");\n}",
  "Dart_humaneval-015": "String stringSequence(int n) {\n  return List.generate(n + 1, (i) => i.toString()).join(' ');\n}",
  "Rust_humaneval-015": "fn string_sequence(n: i32) -> String {\n    (0..=n)\n        .map(|i| i.to_string())\n        .collect::<Vec<String>>()\n        .join(\" \")\n}",
  "Scala_humaneval-015": "def stringSequence(n: Int): String = {\n  (0 to n).mkString(\" \")\n}",
  "Kotlin_humaneval-015": "fun stringSequence(n: Int): String {\n  return (0..n).joinToString(\" \")\n}",
  "C++_humaneval-016": "int countDistinctCharacters(string s) {\n  unordered_set<char> distinct_chars;\n  for (char c : s) {\n    distinct_chars.insert(tolower(c));\n  }\n  return distinct_chars.size();\n}",
  "Java_humaneval-016": "public static Integer countDistinctCharacters(String s) {\n  s = s.toLowerCase();\n  Set<Character> distinctChars = new HashSet<>();\n  for (char c : s.toCharArray()) {\n    distinctChars.add(c);\n  }\n  return distinctChars.size();\n}",
  "Python_humaneval-016": "def count_distinct_characters(s: str) -> int:\n    s = s.lower()\n    distinct_chars = set(s)\n    return len(distinct_chars)",
  "C#_humaneval-016": "public static int CountDistinctCharacters(string s) {\n  s = s.ToLower();\n  HashSet<char> distinctChars = new HashSet<char>(s);\n  return distinctChars.Count;\n}",
  "JavaScript_humaneval-016": "function countDistinctCharacters(s) {\n  s = s.toLowerCase();\n  let distinctChars = new Set(s);\n  return distinctChars.size;\n}",
  "Go_humaneval-016": "func countDistinctCharacters(s string) int {\n    s = strings.ToLower(s)\n    distinctChars := make(map[rune]bool)\n    for _, c := range s {\n        distinctChars[c] = true\n    }\n    return len(distinctChars)\n}",
  "PHP_humaneval-016": "function countDistinctCharacters(string $s): int {\n    $s = strtolower($s);\n    $distinct_chars = array_unique(str_split($s));\n    return count($distinct_chars);\n}",
  "Ruby_humaneval-016": "def count_distinct_characters(s)\n  s = s.downcase\n  distinct_chars = s.chars.to_set\n  distinct_chars.length\nend",
  "Swift_humaneval-016": "func countDistinctCharacters(_ s: String) -> Int {\n  let s = s.lowercased()\n  let distinctChars = Set(s)\n  return distinctChars.count\n}",
  "TypeScript_humaneval-016": "function countDistinctCharacters(s: string): number {\n  s = s.toLowerCase();\n  const distinctChars = new Set(s);\n  return distinctChars.size;\n}",
  "Dart_humaneval-016": "int countDistinctCharacters(String s) {\n  s = s.toLowerCase();\n  Set<String> distinctChars = s.split(\"\").toSet();\n  return distinctChars.length;\n}",
  "Rust_humaneval-016": "fn count_distinct_characters(s: String) -> i32 {\n    let s = s.to_lowercase();\n    let distinct_chars: HashSet<char> = s.chars().collect();\n    distinct_chars.len() as i32\n}",
  "Scala_humaneval-016": "def countDistinctCharacters(s: String): Int = {\n  val lowerCaseS = s.toLowerCase\n  val distinctChars = lowerCaseS.toSet\n  distinctChars.size\n}",
  "Kotlin_humaneval-016": "fun countDistinctCharacters(s: String): Int {\n  val lowerCaseS = s.toLowerCase()\n  val distinctChars = lowerCaseS.toSet()\n  return distinctChars.size\n}",
  "C++_humaneval-017": "vector<int> parseMusic(string music_string) {\n  map<string, int> durations = {{\"o\", 4}, {\"o|\", 2}, {\".|\", 1}};\n  vector<string> notes;\n  stringstream ss(music_string);\n  string note;\n  while (ss >> note) {\n    notes.push_back(note);\n  }\n  vector<int> parsed_music;\n  for (auto note : notes) {\n    parsed_music.push_back(durations[note]);\n  }\n  return parsed_music;\n}",
  "Java_humaneval-017": "public static List<Integer> parseMusic(String musicString) {\n  Map<String, Integer> durations = Map.of(\"o\", 4, \"o|\", 2, \".|\", 1);\n  String[] notes = musicString.split(\" \");\n  Integer[] durationsArray = new Integer[notes.length];\n  for (int i = 0; i < notes.length; i++) {\n    durationsArray[i] = durations.get(notes[i]);\n  }\n  return Arrays.asList(durationsArray);\n}",
  "Python_humaneval-017": "def parse_music(music_string: str) -> List[int]:\n    durations = {\"o\": 4, \"o|\": 2, \".|\": 1}\n    notes = music_string.split()\n    return [durations[note] for note in notes]",
  "C#_humaneval-017": "public static List<int> ParseMusic(string musicString) {\n  Dictionary<string, int> durations =\n      new Dictionary<string, int> { { \"o\", 4 }, { \"o|\", 2 }, { \".|\", 1 } };\n  string[] notes = musicString.Split();\n  List<int> result = new List<int>();\n  foreach (string note in notes) {\n    result.Add(durations[note]);\n  }\n  return result;\n}",
  "JavaScript_humaneval-017": "function parseMusic(musicString) {\n  const durations = { o: 4, \"o|\": 2, \".|\": 1 };\n  const notes = musicString.split(\" \");\n  return notes.map((note) => durations[note]);\n}",
  "Go_humaneval-017": "func parseMusic(musicString string) []int {\n    durations := map[string]int{\"o\": 4, \"o|\": 2, \".|\": 1}\n    notes := strings.Split(musicString, \" \")\n    var result []int\n    for _, note := range notes {\n        result = append(result, durations[note])\n    }\n    return result\n}",
  "PHP_humaneval-017": "function parseMusic(string $musicString): array {\n    $durations = [\"o\" => 4, \"o|\" => 2, \".|\" => 1];\n    $notes = explode(\" \", $musicString);\n    return array_map(function($note) use ($durations) {\n        return $durations[$note];\n    }, $notes);\n}",
  "Ruby_humaneval-017": "def parse_music(music_string)\n  durations = { \"o\" => 4, \"o|\" => 2, \".|\" => 1 }\n  notes = music_string.split\n  notes.map { |note| durations[note] }\nend",
  "Swift_humaneval-017": "func parseMusic(_ musicString: String) -> [Int] {\n  let durations = [\"o\": 4, \"o|\": 2, \".|\": 1]\n  let notes = musicString.split(separator: \" \")\n  return notes.map { durations[String($0)]! }\n}",
  "TypeScript_humaneval-017": "function parseMusic(musicString: string): number[] {\n  const durations: { [key: string]: number } = { o: 4, \"o|\": 2, \".|\": 1 };\n  const notes: string[] = musicString.split(\" \");\n  return notes.map((note) => durations[note]);\n}",
  "Dart_humaneval-017": "List<int> parseMusic(String musicString) {\n  Map<String, int> durations = {\"o\": 4, \"o|\": 2, \".|\": 1};\n  List<String> notes = musicString.split(\" \");\n  return notes.map((note) => durations[note]).nonNulls.toList();\n}",
  "Rust_humaneval-017": "fn parse_music(music_string: String) -> Vec<i32> {\n    let durations: HashMap<&str, i32> = [(\"o\", 4), (\"o|\", 2), (\".|\", 1)].iter().cloned().collect();\n    let notes: Vec<&str> = music_string.split_whitespace().collect();\n    notes.iter().map(|note| durations[note]).collect()\n}",
  "Scala_humaneval-017": "def parseMusic(musicString: String): List[Int] = {\n  val durations = Map(\"o\" -> 4, \"o|\" -> 2, \".|\" -> 1)\n  val notes = musicString.split(\" \")\n  notes.map(durations(_)).toList\n}",
  "Kotlin_humaneval-017": "fun parseMusic(musicString: String): List<Int> {\n  val durations = mapOf(\"o\" to 4, \"o|\" to 2, \".|\" to 1)\n  val notes = musicString.split(\" \")\n  return notes.map { durations[it]!! }\n}",
  "C++_humaneval-018": "int howManyTimes(string s, string substring) {\n  int count = 0;\n  if (substring.length() == 0) {\n    return 0;\n  }\n  for (int i = 0; i < s.length() - substring.length() + 1; i++) {\n    if (s.substr(i, substring.length()) == substring) {\n      count += 1;\n    }\n  }\n  return count;\n}",
  "Java_humaneval-018": "public static Integer howManyTimes(String s, String substring) {\n  int count = 0;\n  if (substring.length() == 0) {\n    return 0;\n  }\n  for (int i = 0; i <= s.length() - substring.length(); i++) {\n    if (s.substring(i, i + substring.length()).equals(substring)) {\n      count++;\n    }\n  }\n  return count;\n}",
  "Python_humaneval-018": "def how_many_times(s: str, substring: str) -> int:\n    count = 0\n    if len(substring) == 0:\n        return 0\n    for i in range(len(s) - len(substring) + 1):\n        if s[i : i + len(substring)] == substring:\n            count += 1\n    return count",
  "C#_humaneval-018": "public static int HowManyTimes(string s, string substring) {\n  int count = 0;\n  if (substring.Length == 0) {\n    return 0;\n  }\n  for (int i = 0; i <= s.Length - substring.Length; i++) {\n    if (s.Substring(i, substring.Length) == substring) {\n      count++;\n    }\n  }\n  return count;\n}",
  "JavaScript_humaneval-018": "function howManyTimes(s, substring) {\n  let count = 0;\n  if (substring.length === 0) {\n    return 0;\n  }\n  for (let i = 0; i <= s.length - substring.length; i++) {\n    if (s.slice(i, i + substring.length) === substring) {\n      count += 1;\n    }\n  }\n  return count;\n}",
  "Go_humaneval-018": "func howManyTimes(s string, substring string) int {\n    count := 0\n    if len(substring) == 0 {\n        return 0\n    }\n    for i := 0; i < len(s)-len(substring)+1; i++ {\n        if s[i:i+len(substring)] == substring {\n            count++\n        }\n    }\n    return count\n}",
  "PHP_humaneval-018": "function howManyTimes(string $s, string $substring): int {\n    $count = 0;\n    if (strlen($substring) == 0) {\n        return 0;\n    }\n    for ($i = 0; $i < strlen($s) - strlen($substring) + 1; $i++) {\n        if (substr($s, $i, strlen($substring)) == $substring) {\n            $count++;\n        }\n    }\n    return $count;\n}",
  "Ruby_humaneval-018": "def how_many_times(s, substring)\n  count = 0\n  return 0 if substring.length == 0\n  (0..s.length - substring.length).each do |i|\n    count += 1 if s[i, substring.length] == substring\n  end\n  count\nend",
  "Swift_humaneval-018": "func howManyTimes(_ s: String, _ substring: String) -> Int {\n  var count = 0\n  if substring.count == 0 {\n    return 0\n  }\n  for i in 0..<(s.count - substring.count + 1) {\n    let start = s.index(s.startIndex, offsetBy: i)\n    let end = s.index(start, offsetBy: substring.count)\n    if s[start..<end] == substring {\n      count += 1\n    }\n  }\n  return count\n}",
  "TypeScript_humaneval-018": "function howManyTimes(s: string, substring: string): number {\n  let count = 0;\n  if (substring.length === 0) {\n    return 0;\n  }\n  for (let i = 0; i <= s.length - substring.length; i++) {\n    if (s.slice(i, i + substring.length) === substring) {\n      count += 1;\n    }\n  }\n  return count;\n}",
  "Dart_humaneval-018": "int howManyTimes(String s, String substring) {\n  int count = 0;\n  if (substring.length == 0) {\n    return 0;\n  }\n  for (int i = 0; i <= s.length - substring.length; i++) {\n    if (s.substring(i, i + substring.length) == substring) {\n      count++;\n    }\n  }\n  return count;\n}",
  "Rust_humaneval-018": "fn how_many_times(s: String, substring: String) -> i32 {\n    let mut count = 0;\n    if substring.is_empty() {\n        return 0;\n    }\n    for i in 0..(1 + s.len()).checked_sub(substring.len()).unwrap_or(0) {\n        if &s[i..i + substring.len()] == &substring {\n            count += 1;\n        }\n    }\n    count\n}",
  "Scala_humaneval-018": "def howManyTimes(s: String, substring: String): Int = {\n  var count = 0\n  if (substring.length == 0) {\n    return 0\n  }\n  for (i <- 0 to s.length - substring.length) {\n    if (s.substring(i, i + substring.length) == substring) {\n      count += 1\n    }\n  }\n  count\n}",
  "Kotlin_humaneval-018": "fun howManyTimes(s: String, substring: String): Int {\n  var count = 0\n  if (substring.isEmpty()) {\n    return 0\n  }\n  for (i in 0..s.length - substring.length) {\n    if (s.substring(i, i + substring.length) == substring) {\n      count++\n    }\n  }\n  return count\n}",
  "C++_humaneval-019": "string sortNumbers(string numbers) {\n  unordered_map<string, int> num_dict = {\n      {\"zero\", 0}, {\"one\", 1}, {\"two\", 2},   {\"three\", 3}, {\"four\", 4},\n      {\"five\", 5}, {\"six\", 6}, {\"seven\", 7}, {\"eight\", 8}, {\"nine\", 9},\n  };\n  istringstream iss(numbers);\n  vector<string> num_list((istream_iterator<string>(iss)),\n                          istream_iterator<string>());\n  sort(num_list.begin(), num_list.end(), [&](const string& a, const string& b) {\n    return num_dict[a] < num_dict[b];\n  });\n  return accumulate(num_list.begin(), num_list.end(), string(),\n                    [](const string& a, const string& b) {\n                      return a.empty() ? b : a + \" \" + b;\n                    });\n}",
  "Java_humaneval-019": "public static String sortNumbers(String numbers) {\n  Map<String, Integer> numDict = new HashMap<String, Integer>() {\n    {\n      put(\"zero\", 0);\n      put(\"one\", 1);\n      put(\"two\", 2);\n      put(\"three\", 3);\n      put(\"four\", 4);\n      put(\"five\", 5);\n      put(\"six\", 6);\n      put(\"seven\", 7);\n      put(\"eight\", 8);\n      put(\"nine\", 9);\n    }\n  };\n  String[] numList = numbers.split(\" \");\n  Arrays.sort(numList, (a, b) -> numDict.get(a).compareTo(numDict.get(b)));\n  return String.join(\" \", numList);\n}",
  "Python_humaneval-019": "def sort_numbers(numbers: str) -> str:\n    num_dict = {\n        \"zero\": 0,\n        \"one\": 1,\n        \"two\": 2,\n        \"three\": 3,\n        \"four\": 4,\n        \"five\": 5,\n        \"six\": 6,\n        \"seven\": 7,\n        \"eight\": 8,\n        \"nine\": 9,\n    }\n    num_list = numbers.split()\n    num_list.sort(key=lambda x: num_dict[x])\n    return \" \".join(num_list)",
  "C#_humaneval-019": "public static string SortNumbers(string numbers) {\n  Dictionary<string, int> numDict =\n      new Dictionary<string, int>() { { \"zero\", 0 },  { \"one\", 1 },  { \"two\", 2 }, { \"three\", 3 },\n                                      { \"four\", 4 },  { \"five\", 5 }, { \"six\", 6 }, { \"seven\", 7 },\n                                      { \"eight\", 8 }, { \"nine\", 9 } };\n  string[] numList = numbers.Split();\n  Array.Sort(numList, (x, y) => numDict[x].CompareTo(numDict[y]));\n  return string.Join(\" \", numList);\n}",
  "JavaScript_humaneval-019": "function sortNumbers(numbers) {\n  const numDict = {\n    zero: 0,\n    one: 1,\n    two: 2,\n    three: 3,\n    four: 4,\n    five: 5,\n    six: 6,\n    seven: 7,\n    eight: 8,\n    nine: 9,\n  };\n  const numList = numbers.split(\" \");\n  numList.sort((a, b) => numDict[a] - numDict[b]);\n  return numList.join(\" \");\n}",
  "Go_humaneval-019": "func sortNumbers(numbers string) string {\n    numDict := map[string]int{\n        \"zero\":  0,\n        \"one\":   1,\n        \"two\":   2,\n        \"three\": 3,\n        \"four\":  4,\n        \"five\":  5,\n        \"six\":   6,\n        \"seven\": 7,\n        \"eight\": 8,\n        \"nine\":  9,\n    }\n    numList := strings.Split(numbers, \" \")\n    sort.Slice(numList, func(i, j int) bool {\n        return numDict[numList[i]] < numDict[numList[j]]\n    })\n    return strings.Join(numList, \" \")\n}",
  "PHP_humaneval-019": "function sortNumbers(string $numbers): string {\n    $num_dict = [\n        \"zero\" => 0,\n        \"one\" => 1,\n        \"two\" => 2,\n        \"three\" => 3,\n        \"four\" => 4,\n        \"five\" => 5,\n        \"six\" => 6,\n        \"seven\" => 7,\n        \"eight\" => 8,\n        \"nine\" => 9,\n    ];\n    $num_list = explode(\" \", $numbers);\n    usort($num_list, function($a, $b) use ($num_dict) {\n        return $num_dict[$a] - $num_dict[$b];\n    });\n    return implode(\" \", $num_list);\n}",
  "Ruby_humaneval-019": "def sort_numbers(numbers)\n  num_dict = {\n    \"zero\" => 0,\n    \"one\" => 1,\n    \"two\" => 2,\n    \"three\" => 3,\n    \"four\" => 4,\n    \"five\" => 5,\n    \"six\" => 6,\n    \"seven\" => 7,\n    \"eight\" => 8,\n    \"nine\" => 9\n  }\n  num_list = numbers.split\n  num_list.sort_by! { |x| num_dict[x] }\n  num_list.join(\" \")\nend",
  "Swift_humaneval-019": "func sortNumbers(_ numbers: String) -> String {\n  let numDict = [\n    \"zero\": 0,\n    \"one\": 1,\n    \"two\": 2,\n    \"three\": 3,\n    \"four\": 4,\n    \"five\": 5,\n    \"six\": 6,\n    \"seven\": 7,\n    \"eight\": 8,\n    \"nine\": 9,\n  ]\n  var numList = numbers.split(separator: \" \")\n  numList.sort { numDict[String($0)]! < numDict[String($1)]! }\n  return numList.joined(separator: \" \")\n}",
  "TypeScript_humaneval-019": "function sortNumbers(numbers: string): string {\n  const numDict: { [key: string]: number } = {\n    zero: 0,\n    one: 1,\n    two: 2,\n    three: 3,\n    four: 4,\n    five: 5,\n    six: 6,\n    seven: 7,\n    eight: 8,\n    nine: 9,\n  };\n  const numList: string[] = numbers.split(\" \");\n  numList.sort((a, b) => numDict[a] - numDict[b]);\n  return numList.join(\" \");\n}",
  "Dart_humaneval-019": "String sortNumbers(String numbers) {\n  Map<String, int> numDict = {\n    \"zero\": 0,\n    \"one\": 1,\n    \"two\": 2,\n    \"three\": 3,\n    \"four\": 4,\n    \"five\": 5,\n    \"six\": 6,\n    \"seven\": 7,\n    \"eight\": 8,\n    \"nine\": 9,\n  };\n  List<String> numList = numbers.split(\" \");\n  numList.sort((a, b) => numDict[a]!.compareTo(numDict[b]!));\n  return numList.join(\" \");\n}",
  "Rust_humaneval-019": "fn sort_numbers(numbers: String) -> String {\n    let mut num_dict = HashMap::new();\n    num_dict.insert(\"zero\", 0);\n    num_dict.insert(\"one\", 1);\n    num_dict.insert(\"two\", 2);\n    num_dict.insert(\"three\", 3);\n    num_dict.insert(\"four\", 4);\n    num_dict.insert(\"five\", 5);\n    num_dict.insert(\"six\", 6);\n    num_dict.insert(\"seven\", 7);\n    num_dict.insert(\"eight\", 8);\n    num_dict.insert(\"nine\", 9);\n    let mut num_list: Vec<&str> = numbers.split(\" \").collect();\n    num_list.sort_by_key(|x| num_dict[x]);\n    num_list.join(\" \")\n}",
  "Scala_humaneval-019": "def sortNumbers(numbers: String): String = {\n  val numDict = Map(\n    \"zero\" -> 0,\n    \"one\" -> 1,\n    \"two\" -> 2,\n    \"three\" -> 3,\n    \"four\" -> 4,\n    \"five\" -> 5,\n    \"six\" -> 6,\n    \"seven\" -> 7,\n    \"eight\" -> 8,\n    \"nine\" -> 9\n  )\n  val numList = numbers.split(\" \")\n  val sortedList = numList.sortBy(x => numDict(x))\n  sortedList.mkString(\" \")\n}",
  "Kotlin_humaneval-019": "fun sortNumbers(numbers: String): String {\n  val numDict = mapOf(\n    \"zero\" to 0,\n    \"one\" to 1,\n    \"two\" to 2,\n    \"three\" to 3,\n    \"four\" to 4,\n    \"five\" to 5,\n    \"six\" to 6,\n    \"seven\" to 7,\n    \"eight\" to 8,\n    \"nine\" to 9\n  )\n  val numList = numbers.split(\" \").toMutableList()\n  numList.sortBy { numDict[it] }\n  return numList.joinToString(\" \")\n}",
  "C++_humaneval-020": "vector<double> findClosestElements(vector<double> numbers) {\n  sort(numbers.begin(), numbers.end());\n  double min_diff = INFINITY;\n  vector<double> closest_pair;\n  for (int i = 0; i < numbers.size() - 1; i++) {\n    double diff = numbers[i + 1] - numbers[i];\n    if (diff < min_diff) {\n      min_diff = diff;\n      closest_pair = {numbers[i], numbers[i + 1]};\n    }\n  }\n  return closest_pair;\n}",
  "Java_humaneval-020": "public static List<Double> findClosestElements(List<Double> numbers) {\n  Collections.sort(numbers);\n  double minDiff = Double.POSITIVE_INFINITY;\n  List<Double> closestPair = new ArrayList<>();\n  for (int i = 0; i < numbers.size() - 1; i++) {\n    double diff = numbers.get(i + 1) - numbers.get(i);\n    if (diff < minDiff) {\n      minDiff = diff;\n      closestPair.clear();\n      closestPair.add(numbers.get(i));\n      closestPair.add(numbers.get(i + 1));\n    }\n  }\n  return closestPair;\n}",
  "Python_humaneval-020": "def find_closest_elements(numbers: List[float]) -> List[float]:\n    numbers.sort()\n    min_diff = float(\"inf\")\n    closest_pair = []\n    for i in range(len(numbers) - 1):\n        diff = numbers[i + 1] - numbers[i]\n        if diff < min_diff:\n            min_diff = diff\n            closest_pair = [numbers[i], numbers[i + 1]]\n    return closest_pair",
  "C#_humaneval-020": "public static List<double> FindClosestElements(List<double> numbers) {\n  numbers.Sort();\n  double minDiff = double.PositiveInfinity;\n  List<double> closestPair = new List<double>();\n  for (int i = 0; i < numbers.Count - 1; i++) {\n    double diff = numbers[i + 1] - numbers[i];\n    if (diff < minDiff) {\n      minDiff = diff;\n      closestPair = new List<double> { numbers[i], numbers[i + 1] };\n    }\n  }\n  return closestPair;\n}",
  "JavaScript_humaneval-020": "function findClosestElements(numbers) {\n  numbers.sort((a, b) => a - b);\n  let minDiff = Infinity;\n  let closestPair = [];\n  for (let i = 0; i < numbers.length - 1; i++) {\n    const diff = numbers[i + 1] - numbers[i];\n    if (diff < minDiff) {\n      minDiff = diff;\n      closestPair = [numbers[i], numbers[i + 1]];\n    }\n  }\n  return closestPair;\n}",
  "Go_humaneval-020": "func findClosestElements(numbers []float64) []float64 {\n    sort.Float64s(numbers)\n    minDiff := math.Inf(1)\n    closestPair := []float64{}\n    for i := 0; i < len(numbers)-1; i++ {\n        diff := numbers[i+1] - numbers[i]\n        if diff < minDiff {\n            minDiff = diff\n            closestPair = []float64{numbers[i], numbers[i+1]}\n        }\n    }\n    return closestPair\n}",
  "PHP_humaneval-020": "function findClosestElements(array $numbers): array {\n    sort($numbers);\n    $min_diff = INF;\n    $closest_pair = [];\n    for ($i = 0; $i < count($numbers) - 1; $i++) {\n        $diff = $numbers[$i + 1] - $numbers[$i];\n        if ($diff < $min_diff) {\n            $min_diff = $diff;\n            $closest_pair = [$numbers[$i], $numbers[$i + 1]];\n        }\n    }\n    return $closest_pair;\n}",
  "Ruby_humaneval-020": "def find_closest_elements(numbers)\n  numbers.sort!\n  min_diff = Float::INFINITY\n  closest_pair = []\n  (0...numbers.length - 1).each do |i|\n    diff = numbers[i + 1] - numbers[i]\n    if diff < min_diff\n      min_diff = diff\n      closest_pair = [numbers[i], numbers[i + 1]]\n    end\n  end\n  closest_pair\nend",
  "Swift_humaneval-020": "func findClosestElements(_ numbers: [Double]) -> [Double] {\n  var sortedNumbers = numbers.sorted()\n  var minDiff = Double.infinity\n  var closestPair: [Double] = []\n  for i in 0..<sortedNumbers.count - 1 {\n    let diff = sortedNumbers[i + 1] - sortedNumbers[i]\n    if diff < minDiff {\n      minDiff = diff\n      closestPair = [sortedNumbers[i], sortedNumbers[i + 1]]\n    }\n  }\n  return closestPair\n}",
  "TypeScript_humaneval-020": "function findClosestElements(numbers: number[]): number[] {\n  numbers.sort();\n  let minDiff = Number.POSITIVE_INFINITY;\n  let closestPair: number[] = [];\n  for (let i = 0; i < numbers.length - 1; i++) {\n    const diff = numbers[i + 1] - numbers[i];\n    if (diff < minDiff) {\n      minDiff = diff;\n      closestPair = [numbers[i], numbers[i + 1]];\n    }\n  }\n  return closestPair;\n}",
  "Dart_humaneval-020": "List<double> findClosestElements(List<double> numbers) {\n  numbers.sort();\n  double minDiff = double.infinity;\n  List<double> closestPair = [];\n  for (int i = 0; i < numbers.length - 1; i++) {\n    double diff = numbers[i + 1] - numbers[i];\n    if (diff < minDiff) {\n      minDiff = diff;\n      closestPair = [numbers[i], numbers[i + 1]];\n    }\n  }\n  return closestPair;\n}",
  "Rust_humaneval-020": "fn find_closest_elements(numbers: Vec<f64>) -> Vec<f64> {\n    let mut numbers = numbers;\n    numbers.sort_by(|a, b| a.partial_cmp(b).unwrap());\n    let mut min_diff = f64::INFINITY;\n    let mut closest_pair = Vec::new();\n    for i in 0..numbers.len() - 1 {\n        let diff = numbers[i + 1] - numbers[i];\n        if diff < min_diff {\n            min_diff = diff;\n            closest_pair = vec![numbers[i], numbers[i + 1]];\n        }\n    }\n    closest_pair\n}",
  "Scala_humaneval-020": "def findClosestElements(numbers: List[Double]): List[Double] = {\n  val sortedNumbers = numbers.sorted\n  var minDiff = Double.PositiveInfinity\n  var closestPair = List[Double]()\n  for (i <- 0 until sortedNumbers.length - 1) {\n    val diff = sortedNumbers(i + 1) - sortedNumbers(i)\n    if (diff < minDiff) {\n      minDiff = diff\n      closestPair = List(sortedNumbers(i), sortedNumbers(i + 1))\n    }\n  }\n  closestPair\n}",
  "Kotlin_humaneval-020": "fun findClosestElements(numbers: List<Double>): List<Double> {\n  val sortedNumbers = numbers.sorted()\n  var minDiff = Double.POSITIVE_INFINITY\n  var closestPair = emptyList<Double>()\n  for (i in 0 until sortedNumbers.size - 1) {\n    val diff = sortedNumbers[i + 1] - sortedNumbers[i]\n    if (diff < minDiff) {\n      minDiff = diff\n      closestPair = listOf(sortedNumbers[i], sortedNumbers[i + 1])\n    }\n  }\n  return closestPair\n}",
  "C++_humaneval-021": "vector<double> rescaleToUnit(vector<double> numbers) {\n  double min_num = *min_element(numbers.begin(), numbers.end());\n  double max_num = *max_element(numbers.begin(), numbers.end());\n  if (min_num == max_num) {\n    return vector<double>(numbers.size(), 0.0);\n  } else {\n    vector<double> result;\n    for (double num : numbers) {\n      result.push_back((num - min_num) / (max_num - min_num));\n    }\n    return result;\n  }\n}",
  "Java_humaneval-021": "public static List<Double> rescaleToUnit(List<Double> numbers) {\n  double minNum = Collections.min(numbers);\n  double maxNum = Collections.max(numbers);\n  if (minNum == maxNum) {\n    List<Double> result = new ArrayList<>(Collections.nCopies(numbers.size(), 0.0));\n    return result;\n  } else {\n    List<Double> result = new ArrayList<>();\n    for (double num : numbers) {\n      result.add((num - minNum) / (maxNum - minNum));\n    }\n    return result;\n  }\n}",
  "Python_humaneval-021": "def rescale_to_unit(numbers: List[float]) -> List[float]:\n    min_num = min(numbers)\n    max_num = max(numbers)\n    if min_num == max_num:\n        return [0.0] * len(numbers)\n    else:\n        return [(num - min_num) / (max_num - min_num) for num in numbers]",
  "C#_humaneval-021": "public static List<double> RescaleToUnit(List<double> numbers) {\n  double minNum = numbers.Min();\n  double maxNum = numbers.Max();\n  if (minNum == maxNum) {\n    return Enumerable.Repeat(0.0, numbers.Count).ToList();\n  } else {\n    return numbers.Select(num => (num - minNum) / (maxNum - minNum)).ToList();\n  }\n}",
  "JavaScript_humaneval-021": "function rescaleToUnit(numbers) {\n  let minNum = Math.min(...numbers);\n  let maxNum = Math.max(...numbers);\n  if (minNum === maxNum) {\n    return Array(numbers.length).fill(0);\n  } else {\n    return numbers.map((num) => (num - minNum) / (maxNum - minNum));\n  }\n}",
  "Go_humaneval-021": "func rescaleToUnit(numbers []float64) []float64 {\n    minNum := numbers[0]\n    maxNum := numbers[0]\n    for _, num := range numbers {\n        if num < minNum {\n            minNum = num\n        }\n        if num > maxNum {\n            maxNum = num\n        }\n    }\n    if minNum == maxNum {\n        return make([]float64, len(numbers))\n    } else {\n        rescaled := make([]float64, len(numbers))\n        for i, num := range numbers {\n            rescaled[i] = (num - minNum) / (maxNum - minNum)\n        }\n        return rescaled\n    }\n}",
  "PHP_humaneval-021": "function rescaleToUnit(array $numbers): array {\n    $min_num = min($numbers);\n    $max_num = max($numbers);\n    if ($min_num == $max_num) {\n        return array_fill(0, count($numbers), 0.0);\n    } else {\n        return array_map(function($num) use ($min_num, $max_num) {\n            return ($num - $min_num) / ($max_num - $min_num);\n        }, $numbers);\n    }\n}",
  "Ruby_humaneval-021": "def rescale_to_unit(numbers)\n  min_num = numbers.min\n  max_num = numbers.max\n  if min_num == max_num\n    [0.0] * numbers.length\n  else\n    numbers.map { |num| (num - min_num) / (max_num - min_num) }\n  end\nend",
  "Swift_humaneval-021": "func rescaleToUnit(_ numbers: [Double]) -> [Double] {\n  let minNum = numbers.min()!\n  let maxNum = numbers.max()!\n  if minNum == maxNum {\n    return [Double](repeating: 0.0, count: numbers.count)\n  } else {\n    return numbers.map { ($0 - minNum) / (maxNum - minNum) }\n  }\n}",
  "TypeScript_humaneval-021": "function rescaleToUnit(numbers: number[]): number[] {\n  const minNum = Math.min(...numbers);\n  const maxNum = Math.max(...numbers);\n  if (minNum === maxNum) {\n    return Array(numbers.length).fill(0);\n  } else {\n    return numbers.map((num) => (num - minNum) / (maxNum - minNum));\n  }\n}",
  "Dart_humaneval-021": "List<double> rescaleToUnit(List<double> numbers) {\n  double minNum = numbers.reduce(min);\n  double maxNum = numbers.reduce(max);\n  if (minNum == maxNum) {\n    return List.filled(numbers.length, 0.0);\n  } else {\n    return numbers.map((num) => (num - minNum) / (maxNum - minNum)).toList();\n  }\n}",
  "Rust_humaneval-021": "fn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let min_num = numbers.iter().fold(f64::INFINITY, |a, &b| a.min(b));\n    let max_num = numbers.iter().fold(f64::NEG_INFINITY, |a, &b| a.max(b));\n    if min_num == max_num {\n        vec![0.0; numbers.len()]\n    } else {\n        numbers\n            .iter()\n            .map(|num| (num - min_num) / (max_num - min_num))\n            .collect()\n    }\n}",
  "Scala_humaneval-021": "def rescaleToUnit(numbers: List[Double]): List[Double] = {\n  val minNum = numbers.min\n  val maxNum = numbers.max\n  if (minNum == maxNum) {\n    List.fill(numbers.length)(0.0)\n  } else {\n    numbers.map(num => (num - minNum) / (maxNum - minNum))\n  }\n}",
  "Kotlin_humaneval-021": "fun rescaleToUnit(numbers: List<Double>): List<Double> {\n  val minNum = numbers.minOrNull() ?: return List(numbers.size) { 0.0 }\n  val maxNum = numbers.maxOrNull() ?: return List(numbers.size) { 0.0 }\n  return numbers.map { (it - minNum) / (maxNum - minNum) }\n}",
  "C++_humaneval-023": "int lenString(string s) { return s.length(); }",
  "Java_humaneval-023": "public static Integer lenString(String s) {\n  return s.length();\n}",
  "Python_humaneval-023": "def len_string(s: str) -> int:\n    return len(s)",
  "C#_humaneval-023": "public static int LenString(string s) {\n  return s.Length;\n}",
  "JavaScript_humaneval-023": "function lenString(s) {\n  return s.length;\n}",
  "Go_humaneval-023": "func lenString(s string) int {\n    return len(s)\n}",
  "PHP_humaneval-023": "function lenString(string $s): int {\n    return strlen($s);\n}",
  "Ruby_humaneval-023": "def len_string(s)\n  s.length\nend",
  "Swift_humaneval-023": "func lenString(_ s: String) -> Int {\n  return s.count\n}",
  "TypeScript_humaneval-023": "function lenString(s: string): number {\n  return s.length;\n}",
  "Dart_humaneval-023": "int lenString(String s) {\n  return s.length;\n}",
  "Rust_humaneval-023": "fn len_string(s: String) -> i32 {\n    s.len() as i32\n}",
  "Scala_humaneval-023": "def lenString(s: String): Int = {\n  s.length()\n}",
  "Kotlin_humaneval-023": "fun lenString(s: String): Int {\n  return s.length\n}",
  "C++_humaneval-024": "int largestDivisor(int n) {\n  for (int i = n - 1; i > 0; i--) {\n    if (n % i == 0) {\n      return i;\n    }\n  }\n  return 1;\n}",
  "Java_humaneval-024": "public static Integer largestDivisor(Integer n) {\n  for (int i = n - 1; i > 0; i--) {\n    if (n % i == 0) {\n      return i;\n    }\n  }\n  return 1;\n}",
  "Python_humaneval-024": "def largest_divisor(n: int) -> int:\n    for i in range(n - 1, 0, -1):\n        if n % i == 0:\n            return i\n    return 1",
  "C#_humaneval-024": "public static int LargestDivisor(int n) {\n  for (int i = n - 1; i > 0; i--) {\n    if (n % i == 0) {\n      return i;\n    }\n  }\n  return 1;\n}",
  "JavaScript_humaneval-024": "function largestDivisor(n) {\n  for (let i = n - 1; i > 0; i--) {\n    if (n % i === 0) {\n      return i;\n    }\n  }\n  return 1;\n}",
  "Go_humaneval-024": "func largestDivisor(n int) int {\n    for i := n - 1; i > 0; i-- {\n        if n%i == 0 {\n            return i\n        }\n    }\n    return 1\n}",
  "PHP_humaneval-024": "function largestDivisor(int $n): int {\n    for ($i = $n - 1; $i > 0; $i--) {\n        if ($n % $i == 0) {\n            return $i;\n        }\n    }\n    return 1;\n}",
  "Ruby_humaneval-024": "def largest_divisor(n)\n  (n - 1).downto(1) { |i| return i if n % i == 0 }\n  return 1\nend",
  "Swift_humaneval-024": "func largestDivisor(_ n: Int) -> Int {\n  for i in stride(from: n - 1, to: 0, by: -1) {\n    if n % i == 0 {\n      return i\n    }\n  }\n  return 1\n}",
  "TypeScript_humaneval-024": "function largestDivisor(n: number): number {\n  for (let i = n - 1; i > 0; i--) {\n    if (n % i === 0) {\n      return i;\n    }\n  }\n  return 1;\n}",
  "Dart_humaneval-024": "int largestDivisor(int n) {\n  for (int i = n - 1; i > 0; i--) {\n    if (n % i == 0) {\n      return i;\n    }\n  }\n  return 1;\n}",
  "Rust_humaneval-024": "fn largest_divisor(n: i32) -> i32 {\n    for i in (1..n).rev() {\n        if n % i == 0 {\n            return i;\n        }\n    }\n    1\n}",
  "Scala_humaneval-024": "def largestDivisor(n: Int): Int = {\n  for (i <- n - 1 to 1 by -1) {\n    if (n % i == 0) {\n      return i\n    }\n  }\n  return 1\n}",
  "Kotlin_humaneval-024": "fun largestDivisor(n: Int): Int {\n  for (i in n - 1 downTo 1) {\n    if (n % i == 0) {\n      return i\n    }\n  }\n  return 1\n}",
  "C++_humaneval-025": "vector<int> factorize(int n) {\n  vector<int> factors;\n  int divisor = 2;\n  while (divisor <= n) {\n    if (n % divisor == 0) {\n      factors.push_back(divisor);\n      n /= divisor;\n    } else {\n      divisor++;\n    }\n  }\n  return factors;\n}",
  "Java_humaneval-025": "public static List<Integer> factorize(Integer n) {\n  List<Integer> factors = new ArrayList<>();\n  int divisor = 2;\n  while (divisor <= n) {\n    if (n % divisor == 0) {\n      factors.add(divisor);\n      n /= divisor;\n    } else {\n      divisor++;\n    }\n  }\n  return factors;\n}",
  "Python_humaneval-025": "def factorize(n: int) -> List[int]:\n    factors = []\n    divisor = 2\n    while divisor <= n:\n        if n % divisor == 0:\n            factors.append(divisor)\n            n //= divisor\n        else:\n            divisor += 1\n    return factors",
  "C#_humaneval-025": "public static List<int> Factorize(int n) {\n  List<int> factors = new List<int>();\n  int divisor = 2;\n  while (divisor <= n) {\n    if (n % divisor == 0) {\n      factors.Add(divisor);\n      n /= divisor;\n    } else {\n      divisor++;\n    }\n  }\n  return factors;\n}",
  "JavaScript_humaneval-025": "function factorize(n) {\n  let factors = [];\n  let divisor = 2;\n  while (divisor <= n) {\n    if (n % divisor === 0) {\n      factors.push(divisor);\n      n = Math.floor(n / divisor);\n    } else {\n      divisor++;\n    }\n  }\n  return factors;\n}",
  "Go_humaneval-025": "func factorize(n int) []int {\n    factors := []int{}\n    divisor := 2\n    for divisor <= n {\n        if n%divisor == 0 {\n            factors = append(factors, divisor)\n            n /= divisor\n        } else {\n            divisor++\n        }\n    }\n    return factors\n}",
  "PHP_humaneval-025": "function factorize(int $n): array {\n    $factors = [];\n    $divisor = 2;\n    while ($divisor <= $n) {\n        if ($n % $divisor == 0) {\n            $factors[] = $divisor;\n            $n /= $divisor;\n        } else {\n            $divisor++;\n        }\n    }\n    return $factors;\n}",
  "Ruby_humaneval-025": "def factorize(n)\n  factors = []\n  divisor = 2\n  while divisor <= n\n    if n % divisor == 0\n      factors << divisor\n      n /= divisor\n    else\n      divisor += 1\n    end\n  end\n  factors\nend",
  "Swift_humaneval-025": "func factorize(_ n: Int) -> [Int] {\n  var factors = [Int]()\n  var divisor = 2\n  var num = n\n  while divisor <= num {\n    if num % divisor == 0 {\n      factors.append(divisor)\n      num /= divisor\n    } else {\n      divisor += 1\n    }\n  }\n  return factors\n}",
  "TypeScript_humaneval-025": "function factorize(n: number): number[] {\n  const factors: number[] = [];\n  let divisor = 2;\n  while (divisor <= n) {\n    if (n % divisor === 0) {\n      factors.push(divisor);\n      n /= divisor;\n    } else {\n      divisor++;\n    }\n  }\n  return factors;\n}",
  "Dart_humaneval-025": "List<int> factorize(int n) {\n  List<int> factors = [];\n  int divisor = 2;\n  while (divisor <= n) {\n    if (n % divisor == 0) {\n      factors.add(divisor);\n      n ~/= divisor;\n    } else {\n      divisor++;\n    }\n  }\n  return factors;\n}",
  "Rust_humaneval-025": "fn factorize(n: i32) -> Vec<i32> {\n    let mut n = n;\n    let mut factors = Vec::new();\n    let mut divisor = 2;\n    while divisor <= n {\n        if n % divisor == 0 {\n            factors.push(divisor);\n            n /= divisor;\n        } else {\n            divisor += 1;\n        }\n    }\n    factors\n}",
  "Scala_humaneval-025": "def factorize(n: Int): List[Int] = {\n  var factors = new ListBuffer[Int]()\n  var divisor = 2\n  var num = n\n  while (divisor <= num) {\n    if (num % divisor == 0) {\n      factors += divisor\n      num /= divisor\n    } else {\n      divisor += 1\n    }\n  }\n  factors.toList\n}",
  "Kotlin_humaneval-025": "fun factorize(n: Int): List<Int> {\n  val factors = mutableListOf<Int>()\n  var divisor = 2\n  var num = n\n  while (divisor <= num) {\n    if (num % divisor == 0) {\n      factors.add(divisor)\n      num /= divisor\n    } else {\n      divisor++\n    }\n  }\n  return factors\n}",
  "C++_humaneval-026": "vector<int> removeDuplicates(vector<int> numbers) {\n  unordered_map<int, int> frequency;\n  for (int num : numbers) {\n    if (frequency.find(num) != frequency.end()) {\n      frequency[num]++;\n    } else {\n      frequency[num] = 1;\n    }\n  }\n  vector<int> result;\n  for (int num : numbers) {\n    if (frequency[num] == 1) {\n      result.push_back(num);\n    }\n  }\n  return result;\n}",
  "Java_humaneval-026": "public static List<Integer> removeDuplicates(List<Integer> numbers) {\n  Map<Integer, Integer> frequency = new HashMap<>();\n  for (int num : numbers) {\n    frequency.put(num, frequency.getOrDefault(num, 0) + 1);\n  }\n  List<Integer> result = new ArrayList<>();\n  for (int num : numbers) {\n    if (frequency.get(num) == 1) {\n      result.add(num);\n    }\n  }\n  return result;\n}",
  "Python_humaneval-026": "def remove_duplicates(numbers: List[int]) -> List[int]:\n    frequency = {}\n    for num in numbers:\n        if num in frequency:\n            frequency[num] += 1\n        else:\n            frequency[num] = 1\n    result = [num for num in numbers if frequency[num] == 1]\n    return result",
  "C#_humaneval-026": "public static List<int> RemoveDuplicates(List<int> numbers) {\n  Dictionary<int, int> frequency = new Dictionary<int, int>();\n  foreach (int num in numbers) {\n    if (frequency.ContainsKey(num)) {\n      frequency[num]++;\n    } else {\n      frequency[num] = 1;\n    }\n  }\n  List<int> result = new List<int>();\n  foreach (int num in numbers) {\n    if (frequency[num] == 1) {\n      result.Add(num);\n    }\n  }\n  return result;\n}",
  "JavaScript_humaneval-026": "function removeDuplicates(numbers) {\n  const frequency = {};\n  for (let num of numbers) {\n    if (num in frequency) {\n      frequency[num] += 1;\n    } else {\n      frequency[num] = 1;\n    }\n  }\n  const result = numbers.filter((num) => frequency[num] === 1);\n  return result;\n}",
  "Go_humaneval-026": "func removeDuplicates(numbers []int) []int {\n    frequency := make(map[int]int)\n    for _, num := range numbers {\n        frequency[num]++\n    }\n    var result []int\n    for _, num := range numbers {\n        if frequency[num] == 1 {\n            result = append(result, num)\n        }\n    }\n    return result\n}",
  "PHP_humaneval-026": "function removeDuplicates(array $numbers): array {\n    $frequency = array();\n    foreach ($numbers as $num) {\n        if (isset($frequency[$num])) {\n            $frequency[$num]++;\n        } else {\n            $frequency[$num] = 1;\n        }\n    }\n    $result = array();\n    foreach ($numbers as $num) {\n        if ($frequency[$num] == 1) {\n            array_push($result, $num);\n        }\n    }\n    return $result;\n}",
  "Ruby_humaneval-026": "def remove_duplicates(numbers)\n  frequency = {}\n  numbers.each do |num|\n    if frequency.key?(num)\n      frequency[num] += 1\n    else\n      frequency[num] = 1\n    end\n  end\n  result = numbers.select { |num| frequency[num] == 1 }\n  result\nend",
  "Swift_humaneval-026": "func removeDuplicates(_ numbers: [Int]) -> [Int] {\n  var frequency = [Int: Int]()\n  for num in numbers {\n    frequency[num, default: 0] += 1\n  }\n  let result = numbers.filter { frequency[$0] == 1 }\n  return result\n}",
  "TypeScript_humaneval-026": "function removeDuplicates(numbers: number[]): number[] {\n  const frequency: { [key: number]: number } = {};\n  for (const num of numbers) {\n    if (num in frequency) {\n      frequency[num] += 1;\n    } else {\n      frequency[num] = 1;\n    }\n  }\n  const result = numbers.filter((num) => frequency[num] === 1);\n  return result;\n}",
  "Dart_humaneval-026": "List<int> removeDuplicates(List<int> numbers) {\n  var frequency = {};\n  for (var num in numbers) {\n    if (frequency.containsKey(num)) {\n      frequency[num]++;\n    } else {\n      frequency[num] = 1;\n    }\n  }\n  var result = [\n    for (var num in numbers)\n      if (frequency[num] == 1) num\n  ];\n  return result;\n}",
  "Rust_humaneval-026": "fn remove_duplicates(numbers: Vec<i32>) -> Vec<i32> {\n    let mut frequency = HashMap::new();\n    for &num in &numbers {\n        *frequency.entry(num).or_insert(0) += 1;\n    }\n    let result: Vec<i32> = numbers\n        .into_iter()\n        .filter(|&num| frequency[&num] == 1)\n        .collect();\n    result\n}",
  "Scala_humaneval-026": "def removeDuplicates(numbers: List[Int]): List[Int] = {\n  val frequency = numbers.groupBy(identity).mapValues(_.size)\n  val result = numbers.filter(num => frequency(num) == 1)\n  result\n}",
  "Kotlin_humaneval-026": "fun removeDuplicates(numbers: List<Int>): List<Int> {\n  val frequency = mutableMapOf<Int, Int>()\n  for (num in numbers) {\n    if (num in frequency) {\n      frequency[num] = frequency[num]!! + 1\n    } else {\n      frequency[num] = 1\n    }\n  }\n  val result = numbers.filter { frequency[it] == 1 }\n  return result\n}",
  "C++_humaneval-027": "string flipCase(string s) {\n  string flipped = \"\";\n  for (char c : s) {\n    if (islower(c)) {\n      flipped += toupper(c);\n    } else if (isupper(c)) {\n      flipped += tolower(c);\n    } else {\n      flipped += c;\n    }\n  }\n  return flipped;\n}",
  "Java_humaneval-027": "public static String flipCase(String s) {\n  String flipped = \"\";\n  for (char c : s.toCharArray()) {\n    if (Character.isLowerCase(c)) {\n      flipped += Character.toUpperCase(c);\n    } else if (Character.isUpperCase(c)) {\n      flipped += Character.toLowerCase(c);\n    } else {\n      flipped += c;\n    }\n  }\n  return flipped;\n}",
  "Python_humaneval-027": "def flip_case(s: str) -> str:\n    flipped = \"\"\n    for char in s:\n        if char.islower():\n            flipped += char.upper()\n        elif char.isupper():\n            flipped += char.lower()\n        else:\n            flipped += char\n    return flipped",
  "C#_humaneval-027": "public static string FlipCase(string s) {\n  string flipped = \"\";\n  foreach (char c in s) {\n    if (char.IsLower(c)) {\n      flipped += char.ToUpper(c);\n    } else if (char.IsUpper(c)) {\n      flipped += char.ToLower(c);\n    } else {\n      flipped += c;\n    }\n  }\n  return flipped;\n}",
  "JavaScript_humaneval-027": "function flipCase(s) {\n  let flipped = \"\";\n  for (let i = 0; i < s.length; i++) {\n    const char = s[i];\n    if (char.match(/[a-z]/)) {\n      flipped += char.toUpperCase();\n    } else if (char.match(/[A-Z]/)) {\n      flipped += char.toLowerCase();\n    } else {\n      flipped += char;\n    }\n  }\n  return flipped;\n}",
  "Go_humaneval-027": "func flipCase(s string) string {\n    flipped := \"\"\n    for _, char := range s {\n        if unicode.IsLower(char) {\n            flipped += strings.ToUpper(string(char))\n        } else if unicode.IsUpper(char) {\n            flipped += strings.ToLower(string(char))\n        } else {\n            flipped += string(char)\n        }\n    }\n    return flipped\n}",
  "PHP_humaneval-027": "function flipCase(string $s): string {\n    $flipped = \"\";\n    for ($i = 0; $i < strlen($s); $i++) {\n        $char = $s[$i];\n        if (ctype_lower($char)) {\n            $flipped .= strtoupper($char);\n        } elseif (ctype_upper($char)) {\n            $flipped .= strtolower($char);\n        } else {\n            $flipped .= $char;\n        }\n    }\n    return $flipped;\n}",
  "Ruby_humaneval-027": "def flip_case(s)\n  flipped = \"\"\n  s.each_char do |char|\n    if char.match?(/[a-z]/)\n      flipped += char.upcase\n    elsif char.match?(/[A-Z]/)\n      flipped += char.downcase\n    else\n      flipped += char\n    end\n  end\n  flipped\nend",
  "Swift_humaneval-027": "func flipCase(_ s: String) -> String {\n  var flipped = \"\"\n  for char in s {\n    if char.isLowercase {\n      flipped += char.uppercased()\n    } else if char.isUppercase {\n      flipped += char.lowercased()\n    } else {\n      flipped += String(char)\n    }\n  }\n  return flipped\n}",
  "TypeScript_humaneval-027": "function flipCase(s: string): string {\n  let flipped = \"\";\n  for (let char of s) {\n    if (char.toLowerCase() === char) {\n      flipped += char.toUpperCase();\n    } else if (char.toUpperCase() === char) {\n      flipped += char.toLowerCase();\n    } else {\n      flipped += char;\n    }\n  }\n  return flipped;\n}",
  "Dart_humaneval-027": "String flipCase(String s) {\n  String flipped = \"\";\n  for (int i = 0; i < s.length; i++) {\n    if (s[i].toLowerCase() == s[i]) {\n      flipped += s[i].toUpperCase();\n    } else if (s[i].toUpperCase() == s[i]) {\n      flipped += s[i].toLowerCase();\n    } else {\n      flipped += s[i];\n    }\n  }\n  return flipped;\n}",
  "Rust_humaneval-027": "fn flip_case(s: String) -> String {\n    let mut flipped = String::new();\n    for char in s.chars() {\n        if char.is_ascii_lowercase() {\n            flipped.push(char.to_ascii_uppercase());\n        } else if char.is_ascii_uppercase() {\n            flipped.push(char.to_ascii_lowercase());\n        } else {\n            flipped.push(char);\n        }\n    }\n    flipped\n}",
  "Scala_humaneval-027": "def flipCase(s: String): String = {\n  var flipped = \"\"\n  for (char <- s) {\n    if (char.isLower) {\n      flipped += char.toUpper\n    } else if (char.isUpper) {\n      flipped += char.toLower\n    } else {\n      flipped += char\n    }\n  }\n  flipped\n}",
  "Kotlin_humaneval-027": "fun flipCase(s: String): String {\n  var flipped = \"\"\n  for (char in s) {\n    if (char.isLowerCase()) {\n      flipped += char.toUpperCase()\n    } else if (char.isUpperCase()) {\n      flipped += char.toLowerCase()\n    } else {\n      flipped += char\n    }\n  }\n  return flipped\n}",
  "C++_humaneval-028": "string concatenate(vector<string> words) {\n  string result = \"\";\n  for (string s : words) {\n    result += s;\n  }\n  return result;\n}",
  "Java_humaneval-028": "public static String concatenate(List<String> words) {\n  return String.join(\"\", words);\n}",
  "Python_humaneval-028": "def concatenate(words: List[str]) -> str:\n    return \"\".join(words)",
  "C#_humaneval-028": "public static string Concatenate(List<string> words) {\n  return string.Concat(words);\n}",
  "JavaScript_humaneval-028": "function concatenate(words) {\n  return words.join(\"\");\n}",
  "Go_humaneval-028": "func concatenate(words []string) string {\n    return strings.Join(words, \"\")\n}",
  "PHP_humaneval-028": "function concatenate(array $words): string {\n    return implode(\"\", $words);\n}",
  "Ruby_humaneval-028": "def concatenate(words)\n  words.join(\"\")\nend",
  "Swift_humaneval-028": "func concatenate(_ words: [String]) -> String {\n  return words.joined()\n}",
  "TypeScript_humaneval-028": "function concatenate(words: string[]): string {\n  return words.join(\"\");\n}",
  "Dart_humaneval-028": "String concatenate(List<String> words) {\n  return words.join();\n}",
  "Rust_humaneval-028": "fn concatenate(words: Vec<String>) -> String {\n    words.join(\"\")\n}",
  "Scala_humaneval-028": "def concatenate(words: List[String]): String = {\n  words.mkString(\"\")\n}",
  "Kotlin_humaneval-028": "fun concatenate(words: List<String>): String {\n  return words.joinToString(\"\")\n}",
  "C++_humaneval-029": "vector<string> filterByPrefix(vector<string> words, string prefix) {\n  vector<string> result;\n  for (string s : words) {\n    if (s.substr(0, prefix.size()) == prefix) {\n      result.push_back(s);\n    }\n  }\n  return result;\n}",
  "Java_humaneval-029": "public static List<String> filterByPrefix(List<String> words, String prefix) {\n  List<String> filteredStrings = new ArrayList<>();\n  for (String s : words) {\n    if (s.startsWith(prefix)) {\n      filteredStrings.add(s);\n    }\n  }\n  return filteredStrings;\n}",
  "Python_humaneval-029": "def filter_by_prefix(words: List[str], prefix: str) -> List[str]:\n    return [s for s in words if s.startswith(prefix)]",
  "C#_humaneval-029": "public static List<string> FilterByPrefix(List<string> words, string prefix) {\n  return words.Where(s => s.StartsWith(prefix)).ToList();\n}",
  "JavaScript_humaneval-029": "function filterByPrefix(words, prefix) {\n  return words.filter((s) => s.startsWith(prefix));\n}",
  "Go_humaneval-029": "func filterByPrefix(words []string, prefix string) []string {\n    var filteredStrings []string\n    for _, s := range words {\n        if strings.HasPrefix(s, prefix) {\n            filteredStrings = append(filteredStrings, s)\n        }\n    }\n    return filteredStrings\n}",
  "PHP_humaneval-029": "function filterByPrefix(array $words, string $prefix): array {\n    return array_values(array_filter($words, function($s) use ($prefix) {\n        return strpos($s, $prefix) === 0;\n    }));\n}",
  "Ruby_humaneval-029": "def filter_by_prefix(words, prefix)\n  words.select { |s| s.start_with?(prefix) }\nend",
  "Swift_humaneval-029": "func filterByPrefix(_ words: [String], _ prefix: String) -> [String] {\n  return words.filter { $0.hasPrefix(prefix) }\n}",
  "TypeScript_humaneval-029": "function filterByPrefix(words: string[], prefix: string): string[] {\n  return words.filter((s) => s.startsWith(prefix));\n}",
  "Dart_humaneval-029": "List<String> filterByPrefix(List<String> words, String prefix) {\n  return [\n    for (var s in words)\n      if (s.startsWith(prefix)) s\n  ];\n}",
  "Rust_humaneval-029": "fn filter_by_prefix(words: Vec<String>, prefix: String) -> Vec<String> {\n    words\n        .into_iter()\n        .filter(|s| s.starts_with(&prefix))\n        .collect()\n}",
  "Scala_humaneval-029": "def filterByPrefix(words: List[String], prefix: String): List[String] = {\n  words.filter(_.startsWith(prefix))\n}",
  "Kotlin_humaneval-029": "fun filterByPrefix(words: List<String>, prefix: String): List<String> {\n  return words.filter { it.startsWith(prefix) }\n}",
  "C++_humaneval-030": "vector<int> getPositive(vector<int> l) {\n  vector<int> result;\n  for (int num : l) {\n    if (num > 0) {\n      result.push_back(num);\n    }\n  }\n  return result;\n}",
  "Java_humaneval-030": "public static List<Integer> getPositive(List<Integer> l) {\n  List<Integer> result = new ArrayList<Integer>();\n  for (int num : l) {\n    if (num > 0) {\n      result.add(num);\n    }\n  }\n  return result;\n}",
  "Python_humaneval-030": "def get_positive(l: List[int]) -> List[int]:\n    return [num for num in l if num > 0]",
  "C#_humaneval-030": "public static List<int> GetPositive(List<int> l) {\n  return l.Where(num => num > 0).ToList();\n}",
  "JavaScript_humaneval-030": "function getPositive(l) {\n  return l.filter((num) => num > 0);\n}",
  "Go_humaneval-030": "func getPositive(l []int) []int {\n    var res []int\n    for _, num := range l {\n        if num > 0 {\n            res = append(res, num)\n        }\n    }\n    return res\n}",
  "PHP_humaneval-030": "function getPositive(array $l): array {\n    return array_values(array_filter($l, function($num) {\n        return $num > 0;\n    }));\n}",
  "Ruby_humaneval-030": "def get_positive(l)\n  l.select { |num| num > 0 }\nend",
  "Swift_humaneval-030": "func getPositive(_ l: [Int]) -> [Int] {\n  return l.filter { $0 > 0 }\n}",
  "TypeScript_humaneval-030": "function getPositive(l: number[]): number[] {\n  return l.filter((num) => num > 0);\n}",
  "Dart_humaneval-030": "List<int> getPositive(List<int> l) {\n  return [\n    for (int num in l)\n      if (num > 0) num\n  ];\n}",
  "Rust_humaneval-030": "fn get_positive(l: Vec<i32>) -> Vec<i32> {\n    l.into_iter().filter(|&num| num > 0).collect()\n}",
  "Scala_humaneval-030": "def getPositive(l: List[Int]): List[Int] = {\n  l.filter(_ > 0)\n}",
  "Kotlin_humaneval-030": "fun getPositive(l: List<Int>): List<Int> {\n  return l.filter { it > 0 }\n}",
  "C++_humaneval-031": "bool isPrime(int n) {\n  if (n < 2) {\n    return false;\n  }\n  for (int i = 2; i <= sqrt(n); ++i) {\n    if (n % i == 0) {\n      return false;\n    }\n  }\n  return true;\n}",
  "Java_humaneval-031": "public static Boolean isPrime(Integer n) {\n  if (n < 2) {\n    return false;\n  }\n  for (int i = 2; i <= Math.sqrt(n); i++) {\n    if (n % i == 0) {\n      return false;\n    }\n  }\n  return true;\n}",
  "Python_humaneval-031": "def is_prime(n: int) -> bool:\n    if n < 2:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True",
  "C#_humaneval-031": "public static bool IsPrime(int n) {\n  if (n < 2) {\n    return false;\n  }\n  for (int i = 2; i <= Math.Sqrt(n); i++) {\n    if (n % i == 0) {\n      return false;\n    }\n  }\n  return true;\n}",
  "JavaScript_humaneval-031": "function isPrime(n) {\n  if (n < 2) {\n    return false;\n  }\n  for (let i = 2; i <= Math.sqrt(n); i++) {\n    if (n % i === 0) {\n      return false;\n    }\n  }\n  return true;\n}",
  "Go_humaneval-031": "func isPrime(n int) bool {\n    if n < 2 {\n        return false\n    }\n    for i := 2; i <= int(math.Sqrt(float64(n))); i++ {\n        if n%i == 0 {\n            return false\n        }\n    }\n    return true\n}",
  "PHP_humaneval-031": "function isPrime(int $n): bool {\n    if ($n < 2) {\n        return false;\n    }\n    for ($i = 2; $i <= sqrt($n); $i++) {\n        if ($n % $i == 0) {\n            return false;\n        }\n    }\n    return true;\n}",
  "Ruby_humaneval-031": "def is_prime(n)\n  return false if n < 2\n  (2..Math.sqrt(n).to_i).each { |i| return false if n % i == 0 }\n  true\nend",
  "Swift_humaneval-031": "func isPrime(_ n: Int) -> Bool {\n  if n < 2 {\n    return false\n  }\n  for i in 2...Int(sqrt(Double(n))) {\n    if n % i == 0 {\n      return false\n    }\n  }\n  return true\n}",
  "TypeScript_humaneval-031": "function isPrime(n: number): boolean {\n  if (n < 2) {\n    return false;\n  }\n  for (let i = 2; i <= Math.sqrt(n); i++) {\n    if (n % i === 0) {\n      return false;\n    }\n  }\n  return true;\n}",
  "Dart_humaneval-031": "bool isPrime(int n) {\n  if (n < 2) {\n    return false;\n  }\n  for (int i = 2; i <= sqrt(n); i++) {\n    if (n % i == 0) {\n      return false;\n    }\n  }\n  return true;\n}",
  "Rust_humaneval-031": "fn is_prime(n: i32) -> bool {\n    if n < 2 {\n        return false;\n    }\n    for i in 2..=(n as f32).sqrt() as i32 {\n        if n % i == 0 {\n            return false;\n        }\n    }\n    true\n}",
  "Scala_humaneval-031": "def isPrime(n: Int): Boolean = {\n  if (n < 2) {\n    return false\n  }\n  for (i <- 2 to (sqrt(n).toInt)) {\n    if (n % i == 0) {\n      return false\n    }\n  }\n  return true\n}",
  "Kotlin_humaneval-031": "fun isPrime(n: Int): Boolean {\n  if (n < 2) {\n    return false\n  }\n  for (i in 2..(n.toDouble().pow(0.5)).toInt()) {\n    if (n % i == 0) {\n      return false\n    }\n  }\n  return true\n}",
  "C++_humaneval-032": "double poly(vector<int> xs, double x) {\n  double result = 0;\n  for (int i = 0; i < xs.size(); i++) {\n    result += xs[i] * pow(x, i);\n  }\n  return result;\n}\ndouble findZero(vector<int> xs) {\n  double x1 = 1.0, x2 = -1.0;\n  while (poly(xs, x1) * poly(xs, x2) > 0) {\n    x1 *= 2;\n    x2 *= 2;\n  }\n  while (abs(x1 - x2) > 1e-10) {\n    double mid = (x1 + x2) / 2;\n    if (poly(xs, mid) == 0) {\n      return mid;\n    } else if (poly(xs, mid) * poly(xs, x1) < 0) {\n      x2 = mid;\n    } else {\n      x1 = mid;\n    }\n  }\n  return (x1 + x2) / 2;\n}",
  "Java_humaneval-032": "public static double poly(List<Integer> xs, double x) {\n  double sum = 0.0;\n  for (int i = 0; i < xs.size(); i++) {\n    sum += xs.get(i) * Math.pow(x, i);\n  }\n  return sum;\n}\npublic static Double findZero(List<Integer> xs) {\n  double x1 = 1.0, x2 = -1.0;\n  while (poly(xs, x1) * poly(xs, x2) > 0) {\n    x1 *= 2;\n    x2 *= 2;\n  }\n  while (Math.abs(x1 - x2) > 1e-10) {\n    double mid = (x1 + x2) / 2;\n    if (poly(xs, mid) == 0) {\n      return mid;\n    } else if (poly(xs, mid) * poly(xs, x1) < 0) {\n      x2 = mid;\n    } else {\n      x1 = mid;\n    }\n  }\n  return (x1 + x2) / 2;\n}",
  "Python_humaneval-032": "def poly(xs, x):\n    return sum([coeff * math.pow(x, i) for i, coeff in enumerate(xs)])\ndef find_zero(xs: List[int]) -> float:\n    x1, x2 = 1.0, -1.0\n    while poly(xs, x1) * poly(xs, x2) > 0:\n        x1 *= 2\n        x2 *= 2\n    while abs(x1 - x2) > 1e-10:\n        mid = (x1 + x2) / 2\n        if poly(xs, mid) == 0:\n            return mid\n        elif poly(xs, mid) * poly(xs, x1) < 0:\n            x2 = mid\n        else:\n            x1 = mid\n    return (x1 + x2) / 2",
  "C#_humaneval-032": "public static double Poly(List<int> xs, double x) {\n  double result = 0;\n  for (int i = 0; i < xs.Count; i++) {\n    result += xs[i] * Math.Pow(x, i);\n  }\n  return result;\n}\npublic static double FindZero(List<int> xs) {\n  double x1 = 1.0, x2 = -1.0;\n  while (Poly(xs, x1) * Poly(xs, x2) > 0) {\n    x1 *= 2;\n    x2 *= 2;\n  }\n  while (Math.Abs(x1 - x2) > 1e-10) {\n    double mid = (x1 + x2) / 2;\n    if (Poly(xs, mid) == 0) {\n      return mid;\n    } else if (Poly(xs, mid) * Poly(xs, x1) < 0) {\n      x2 = mid;\n    } else {\n      x1 = mid;\n    }\n  }\n  return (x1 + x2) / 2;\n}",
  "JavaScript_humaneval-032": "function poly(xs, x) {\n  return xs.reduce((sum, coeff, i) => sum + coeff * Math.pow(x, i), 0);\n}\nfunction findZero(xs) {\n  let x1 = 1.0,\n    x2 = -1.0;\n  while (poly(xs, x1) * poly(xs, x2) > 0) {\n    x1 *= 2;\n    x2 *= 2;\n  }\n  while (Math.abs(x1 - x2) > 1e-10) {\n    const mid = (x1 + x2) / 2;\n    if (poly(xs, mid) === 0) {\n      return mid;\n    } else if (poly(xs, mid) * poly(xs, x1) < 0) {\n      x2 = mid;\n    } else {\n      x1 = mid;\n    }\n  }\n  return (x1 + x2) / 2;\n}",
  "Go_humaneval-032": "func poly(xs []int, x float64) float64 {\n    sum := 0.0\n    for i, coeff := range xs {\n        sum += float64(coeff) * math.Pow(x, float64(i))\n    }\n    return sum\n}\nfunc findZero(xs []int) float64 {\n    x1, x2 := 1.0, -1.0\n    for poly(xs, x1)*poly(xs, x2) > 0 {\n        x1 *= 2\n        x2 *= 2\n    }\n    for math.Abs(x1-x2) > 1e-10 {\n        mid := (x1 + x2) / 2\n        if poly(xs, mid) == 0 {\n            return mid\n        } else if poly(xs, mid)*poly(xs, x1) < 0 {\n            x2 = mid\n        } else {\n            x1 = mid\n        }\n    }\n    return (x1 + x2) / 2\n}",
  "PHP_humaneval-032": "function poly(array $xs, float $x): float {\n    $sum = 0.0;\n    foreach ($xs as $i => $coeff) {\n        $sum += $coeff * pow($x, $i);\n    }\n    return $sum;\n}\nfunction findZero(array $xs): float {\n    $x1 = 1.0;\n    $x2 = -1.0;\n    while (poly($xs, $x1) * poly($xs, $x2) > 0) {\n        $x1 *= 2;\n        $x2 *= 2;\n    }\n    while (abs($x1 - $x2) > 1e-10) {\n        $mid = ($x1 + $x2) / 2;\n        if (poly($xs, $mid) == 0) {\n            return $mid;\n        } elseif (poly($xs, $mid) * poly($xs, $x1) < 0) {\n            $x2 = $mid;\n        } else {\n            $x1 = $mid;\n        }\n    }\n    return ($x1 + $x2) / 2;\n}",
  "Ruby_humaneval-032": "def poly(xs, x)\n  xs.each_with_index.inject(0) { |sum, (coeff, i)| sum + coeff * x**i }\nend\ndef find_zero(xs)\n  x1, x2 = 1.0, -1.0\n  while poly(xs, x1) * poly(xs, x2) > 0\n    x1 *= 2\n    x2 *= 2\n  end\n  while (x1 - x2).abs > 1e-10\n    mid = (x1 + x2) / 2\n    if poly(xs, mid) == 0\n      return mid\n    elsif poly(xs, mid) * poly(xs, x1) < 0\n      x2 = mid\n    else\n      x1 = mid\n    end\n  end\n  (x1 + x2) / 2\nend",
  "Swift_humaneval-032": "func poly(_ xs: [Int], _ x: Double) -> Double {\n  return xs.enumerated().map { (i, coeff) in\n    Double(coeff) * pow(x, Double(i))\n  }.reduce(0, +)\n}\nfunc findZero(_ xs: [Int]) -> Double {\n  var x1 = 1.0\n  var x2 = -1.0\n  while poly(xs, x1) * poly(xs, x2) > 0 {\n    x1 *= 2\n    x2 *= 2\n  }\n  while abs(x1 - x2) > 1e-10 {\n    let mid = (x1 + x2) / 2\n    if poly(xs, mid) == 0 {\n      return mid\n    } else if poly(xs, mid) * poly(xs, x1) < 0 {\n      x2 = mid\n    } else {\n      x1 = mid\n    }\n  }\n  return (x1 + x2) / 2\n}",
  "TypeScript_humaneval-032": "function poly(xs: number[], x: number): number {\n  return xs.reduce((acc, coeff, i) => acc + coeff * Math.pow(x, i), 0);\n}\nfunction findZero(xs: number[]): number {\n  let x1 = 1.0,\n    x2 = -1.0;\n  while (poly(xs, x1) * poly(xs, x2) > 0) {\n    x1 *= 2;\n    x2 *= 2;\n  }\n  while (Math.abs(x1 - x2) > 1e-10) {\n    const mid = (x1 + x2) / 2;\n    if (poly(xs, mid) === 0) {\n      return mid;\n    } else if (poly(xs, mid) * poly(xs, x1) < 0) {\n      x2 = mid;\n    } else {\n      x1 = mid;\n    }\n  }\n  return (x1 + x2) / 2;\n}",
  "Dart_humaneval-032": "double poly(List<int> xs, double x) {\n  return xs.asMap().entries.fold(0.0, (sum, entry) {\n    final i = entry.key;\n    final coeff = entry.value;\n    return sum + coeff * pow(x, i);\n  });\n}\ndouble findZero(List<int> xs) {\n  double x1 = 1.0, x2 = -1.0;\n  while (poly(xs, x1) * poly(xs, x2) > 0) {\n    x1 *= 2;\n    x2 *= 2;\n  }\n  while ((x1 - x2).abs() > 1e-10) {\n    final mid = (x1 + x2) / 2;\n    if (poly(xs, mid) == 0) {\n      return mid;\n    } else if (poly(xs, mid) * poly(xs, x1) < 0) {\n      x2 = mid;\n    } else {\n      x1 = mid;\n    }\n  }\n  return (x1 + x2) / 2;\n}",
  "Rust_humaneval-032": "fn poly(xs: &Vec<i32>, x: f64) -> f64 {\n    xs.iter().enumerate().fold(0.0, |acc, (i, &coeff)| {\n        acc + (coeff as f64) * x.powi(i as i32)\n    })\n}\nfn find_zero(xs: Vec<i32>) -> f64 {\n    let mut x1 = 1.0;\n    let mut x2 = -1.0;\n    while poly(&xs, x1) * poly(&xs, x2) > 0.0 {\n        x1 *= 2.0;\n        x2 *= 2.0;\n    }\n    while (x1 - x2).abs() > 1e-10 {\n        let mid = (x1 + x2) / 2.0;\n        if poly(&xs, mid) == 0.0 {\n            return mid;\n        } else if poly(&xs, mid) * poly(&xs, x1) < 0.0 {\n            x2 = mid;\n        } else {\n            x1 = mid;\n        }\n    }\n    (x1 + x2) / 2.0\n}",
  "Scala_humaneval-032": "def poly(xs: List[Int], x: Double): Double = {\n  xs.zipWithIndex.map { case (coeff, i) => coeff * pow(x, i) }.sum\n}\ndef findZero(xs: List[Int]): Double = {\n  var x1 = 1.0\n  var x2 = -1.0\n  while (poly(xs, x1) * poly(xs, x2) > 0) {\n    x1 *= 2\n    x2 *= 2\n  }\n  while (abs(x1 - x2) > 1e-10) {\n    val mid = (x1 + x2) / 2\n    if (poly(xs, mid) == 0) {\n      return mid\n    } else if (poly(xs, mid) * poly(xs, x1) < 0) {\n      x2 = mid\n    } else {\n      x1 = mid\n    }\n  }\n  (x1 + x2) / 2\n}",
  "Kotlin_humaneval-032": "fun poly(xs: List<Int>, x: Double): Double {\n  return xs.mapIndexed { i, coeff -> coeff * x.pow(i) }.sum()\n}\nfun findZero(xs: List<Int>): Double {\n  var x1 = 1.0\n  var x2 = -1.0\n  while (poly(xs, x1) * poly(xs, x2) > 0) {\n    x1 *= 2\n    x2 *= 2\n  }\n  while (Math.abs(x1 - x2) > 1e-10) {\n    val mid = (x1 + x2) / 2\n    if (poly(xs, mid) == 0.0) {\n      return mid\n    } else if (poly(xs, mid) * poly(xs, x1) < 0) {\n      x2 = mid\n    } else {\n      x1 = mid\n    }\n  }\n  return (x1 + x2) / 2\n}",
  "C++_humaneval-033": "vector<int> sortThird(vector<int> l) {\n  vector<int> divisible_by_three;\n  vector<int> not_divisible_by_three;\n  for (int i = 0; i < l.size(); i++) {\n    if (i % 3 == 0) {\n      divisible_by_three.push_back(l[i]);\n    } else {\n      not_divisible_by_three.push_back(l[i]);\n    }\n  }\n  sort(divisible_by_three.begin(), divisible_by_three.end());\n  vector<int> result;\n  int j = 0;\n  int k = 0;\n  for (int i = 0; i < l.size(); i++) {\n    if (i % 3 == 0) {\n      result.push_back(divisible_by_three[j]);\n      j++;\n    } else {\n      result.push_back(not_divisible_by_three[k]);\n      k++;\n    }\n  }\n  return result;\n}",
  "Java_humaneval-033": "public static List<Integer> sortThird(List<Integer> l) {\n  List<Integer> divisibleByThree = new ArrayList<>();\n  List<Integer> notDivisibleByThree = new ArrayList<>();\n  for (int i = 0; i < l.size(); i++) {\n    if (i % 3 == 0) {\n      divisibleByThree.add(l.get(i));\n    } else {\n      notDivisibleByThree.add(l.get(i));\n    }\n  }\n  Collections.sort(divisibleByThree);\n  List<Integer> result = new ArrayList<>();\n  int j = 0;\n  int k = 0;\n  for (int i = 0; i < l.size(); i++) {\n    if (i % 3 == 0) {\n      result.add(divisibleByThree.get(j));\n      j++;\n    } else {\n      result.add(notDivisibleByThree.get(k));\n      k++;\n    }\n  }\n  return result;\n}",
  "Python_humaneval-033": "def sort_third(l: List[int]) -> List[int]:\n    divisible_by_three = []\n    not_divisible_by_three = []\n    for i in range(len(l)):\n        if i % 3 == 0:\n            divisible_by_three.append(l[i])\n        else:\n            not_divisible_by_three.append(l[i])\n    divisible_by_three.sort()\n    result = []\n    j = 0\n    k = 0\n    for i in range(len(l)):\n        if i % 3 == 0:\n            result.append(divisible_by_three[j])\n            j += 1\n        else:\n            result.append(not_divisible_by_three[k])\n            k += 1\n    return result",
  "C#_humaneval-033": "public static List<int> SortThird(List<int> l) {\n  List<int> divisible_by_three = new List<int>();\n  List<int> not_divisible_by_three = new List<int>();\n  for (int i = 0; i < l.Count; i++) {\n    if (i % 3 == 0) {\n      divisible_by_three.Add(l[i]);\n    } else {\n      not_divisible_by_three.Add(l[i]);\n    }\n  }\n  divisible_by_three.Sort();\n  List<int> result = new List<int>();\n  int j = 0;\n  int k = 0;\n  for (int i = 0; i < l.Count; i++) {\n    if (i % 3 == 0) {\n      result.Add(divisible_by_three[j]);\n      j++;\n    } else {\n      result.Add(not_divisible_by_three[k]);\n      k++;\n    }\n  }\n  return result;\n}",
  "JavaScript_humaneval-033": "function sortThird(l) {\n  let divisible_by_three = [];\n  let not_divisible_by_three = [];\n  for (let i = 0; i < l.length; i++) {\n    if (i % 3 === 0) {\n      divisible_by_three.push(l[i]);\n    } else {\n      not_divisible_by_three.push(l[i]);\n    }\n  }\n  divisible_by_three.sort();\n  let result = [];\n  let j = 0;\n  let k = 0;\n  for (let i = 0; i < l.length; i++) {\n    if (i % 3 === 0) {\n      result.push(divisible_by_three[j]);\n      j++;\n    } else {\n      result.push(not_divisible_by_three[k]);\n      k++;\n    }\n  }\n  return result;\n}",
  "Go_humaneval-033": "func sortThird(l []int) []int {\n    divisibleByThree := []int{}\n    notDivisibleByThree := []int{}\n    for i := range l {\n        if i%3 == 0 {\n            divisibleByThree = append(divisibleByThree, l[i])\n        } else {\n            notDivisibleByThree = append(notDivisibleByThree, l[i])\n        }\n    }\n    sort.Ints(divisibleByThree)\n    result := []int{}\n    j := 0\n    k := 0\n    for i := range l {\n        if i%3 == 0 {\n            result = append(result, divisibleByThree[j])\n            j++\n        } else {\n            result = append(result, notDivisibleByThree[k])\n            k++\n        }\n    }\n    return result\n}",
  "PHP_humaneval-033": "function sortThird(array $l): array {\n    $divisible_by_three = [];\n    $not_divisible_by_three = [];\n    for ($i = 0; $i < count($l); $i++) {\n        if ($i % 3 === 0) {\n            $divisible_by_three[] = $l[$i];\n        } else {\n            $not_divisible_by_three[] = $l[$i];\n        }\n    }\n    sort($divisible_by_three);\n    $result = [];\n    $j = 0;\n    $k = 0;\n    for ($i = 0; $i < count($l); $i++) {\n        if ($i % 3 === 0) {\n            $result[] = $divisible_by_three[$j];\n            $j++;\n        } else {\n            $result[] = $not_divisible_by_three[$k];\n            $k++;\n        }\n    }\n    return $result;\n}",
  "Ruby_humaneval-033": "def sort_third(l)\n  divisible_by_three = []\n  not_divisible_by_three = []\n  l.each_with_index do |num, i|\n    if i % 3 == 0\n      divisible_by_three << num\n    else\n      not_divisible_by_three << num\n    end\n  end\n  divisible_by_three.sort!\n  result = []\n  j = 0\n  k = 0\n  l.each_with_index do |_, i|\n    if i % 3 == 0\n      result << divisible_by_three[j]\n      j += 1\n    else\n      result << not_divisible_by_three[k]\n      k += 1\n    end\n  end\n  result\nend",
  "Swift_humaneval-033": "func sortThird(_ l: [Int]) -> [Int] {\n  var divisibleByThree = [Int]()\n  var notDivisibleByThree = [Int]()\n  for i in 0..<l.count {\n    if i % 3 == 0 {\n      divisibleByThree.append(l[i])\n    } else {\n      notDivisibleByThree.append(l[i])\n    }\n  }\n  divisibleByThree.sort()\n  var result = [Int]()\n  var j = 0\n  var k = 0\n  for i in 0..<l.count {\n    if i % 3 == 0 {\n      result.append(divisibleByThree[j])\n      j += 1\n    } else {\n      result.append(notDivisibleByThree[k])\n      k += 1\n    }\n  }\n  return result\n}",
  "TypeScript_humaneval-033": "function sortThird(l: number[]): number[] {\n  const divisibleByThree: number[] = [];\n  const notDivisibleByThree: number[] = [];\n  for (let i = 0; i < l.length; i++) {\n    if (i % 3 === 0) {\n      divisibleByThree.push(l[i]);\n    } else {\n      notDivisibleByThree.push(l[i]);\n    }\n  }\n  divisibleByThree.sort();\n  const result: number[] = [];\n  let j = 0;\n  let k = 0;\n  for (let i = 0; i < l.length; i++) {\n    if (i % 3 === 0) {\n      result.push(divisibleByThree[j]);\n      j++;\n    } else {\n      result.push(notDivisibleByThree[k]);\n      k++;\n    }\n  }\n  return result;\n}",
  "Dart_humaneval-033": "List<int> sortThird(List<int> l) {\n  List<int> divisibleByThree = [];\n  List<int> notDivisibleByThree = [];\n  for (int i = 0; i < l.length; i++) {\n    if (i % 3 == 0) {\n      divisibleByThree.add(l[i]);\n    } else {\n      notDivisibleByThree.add(l[i]);\n    }\n  }\n  divisibleByThree.sort();\n  List<int> result = [];\n  int j = 0;\n  int k = 0;\n  for (int i = 0; i < l.length; i++) {\n    if (i % 3 == 0) {\n      result.add(divisibleByThree[j]);\n      j++;\n    } else {\n      result.add(notDivisibleByThree[k]);\n      k++;\n    }\n  }\n  return result;\n}",
  "Rust_humaneval-033": "fn sort_third(l: Vec<i32>) -> Vec<i32> {\n    let mut divisible_by_three = Vec::new();\n    let mut not_divisible_by_three = Vec::new();\n    for i in 0..l.len() {\n        if i % 3 == 0 {\n            divisible_by_three.push(l[i]);\n        } else {\n            not_divisible_by_three.push(l[i]);\n        }\n    }\n    divisible_by_three.sort();\n    let mut result = Vec::new();\n    let mut j = 0;\n    let mut k = 0;\n    for i in 0..l.len() {\n        if i % 3 == 0 {\n            result.push(divisible_by_three[j]);\n            j += 1;\n        } else {\n            result.push(not_divisible_by_three[k]);\n            k += 1;\n        }\n    }\n    result\n}",
  "Scala_humaneval-033": "def sortThird(l: List[Int]): List[Int] = {\n  var divisibleByThree = List[Int]()\n  var notDivisibleByThree = List[Int]()\n  for (i <- 0 until l.length) {\n    if (i % 3 == 0) divisibleByThree = divisibleByThree :+ l(i)\n    else notDivisibleByThree = notDivisibleByThree :+ l(i)\n  }\n  divisibleByThree = divisibleByThree.sorted\n  var result = List[Int]()\n  var j = 0\n  var k = 0\n  for (i <- 0 until l.length) {\n    if (i % 3 == 0) {\n      result = result :+ divisibleByThree(j)\n      j += 1\n    } else {\n      result = result :+ notDivisibleByThree(k)\n      k += 1\n    }\n  }\n  result\n}",
  "Kotlin_humaneval-033": "fun sortThird(l: List<Int>): List<Int> {\n  val divisibleByThree = mutableListOf<Int>()\n  val notDivisibleByThree = mutableListOf<Int>()\n  for (i in l.indices) {\n    if (i % 3 == 0) {\n      divisibleByThree.add(l[i])\n    } else {\n      notDivisibleByThree.add(l[i])\n    }\n  }\n  divisibleByThree.sort()\n  val result = mutableListOf<Int>()\n  var j = 0\n  var k = 0\n  for (i in l.indices) {\n    if (i % 3 == 0) {\n      result.add(divisibleByThree[j])\n      j++\n    } else {\n      result.add(notDivisibleByThree[k])\n      k++\n    }\n  }\n  return result\n}",
  "C++_humaneval-034": "vector<int> unique(vector<int> l) {\n  sort(l.begin(), l.end());\n  auto it = unique(l.begin(), l.end());\n  l.resize(distance(l.begin(), it));\n  return l;\n}",
  "Java_humaneval-034": "public static List<Integer> unique(List<Integer> l) {\n  List<Integer> uniqueList = new ArrayList<>(new HashSet<>(l));\n  Collections.sort(uniqueList);\n  return uniqueList;\n}",
  "Python_humaneval-034": "def unique(l: List[int]) -> List[int]:\n    return sorted(list(set(l)))",
  "C#_humaneval-034": "public static List<int> Unique(List<int> l) {\n  return l.Distinct().OrderBy(x => x).ToList();\n}",
  "JavaScript_humaneval-034": "function unique(l) {\n  return Array.from(new Set(l)).sort((a, b) => a - b);\n}",
  "Go_humaneval-034": "func unique(l []int) []int {\n    uniqueMap := make(map[int]bool)\n    for _, v := range l {\n        uniqueMap[v] = true\n    }\n    uniqueList := []int{}\n    for k := range uniqueMap {\n        uniqueList = append(uniqueList, k)\n    }\n    sort.Ints(uniqueList)\n    return uniqueList\n}",
  "PHP_humaneval-034": "function unique(array $l): array {\n    $uniqueList = array_values(array_unique($l));\n    sort($uniqueList);\n    return $uniqueList;\n}",
  "Ruby_humaneval-034": "def unique(l)\n  l.uniq.sort\nend",
  "Swift_humaneval-034": "func unique(_ l: [Int]) -> [Int] {\n  return Array(Set(l)).sorted()\n}",
  "TypeScript_humaneval-034": "function unique(l: number[]): number[] {\n  return Array.from(new Set(l)).sort((a, b) => a - b);\n}",
  "Dart_humaneval-034": "List<int> unique(List<int> l) {\n  return l.toSet().toList()..sort();\n}",
  "Rust_humaneval-034": "fn unique(l: Vec<i32>) -> Vec<i32> {\n    let mut l = l;\n    l.sort();\n    l.dedup();\n    l\n}",
  "Scala_humaneval-034": "def unique(l: List[Int]): List[Int] = {\n  l.distinct.sorted\n}",
  "Kotlin_humaneval-034": "fun unique(l: List<Int>): List<Int> {\n  return l.toSet().sorted()\n}",
  "C++_humaneval-035": "int maxElement(vector<int> l) {\n  if (l.empty()) {\n    return 0;\n  }\n  return *max_element(l.begin(), l.end());\n}",
  "Java_humaneval-035": "public static Integer maxElement(List<Integer> l) {\n  if (l.isEmpty()) {\n    return 0;\n  }\n  return Collections.max(l);\n}",
  "Python_humaneval-035": "def max_element(l: List[int]) -> int:\n    if not l:\n        return 0\n    return max(l)",
  "C#_humaneval-035": "public static int MaxElement(List<int> l) {\n  if (!l.Any()) {\n    return 0;\n  }\n  return l.Max();\n}",
  "JavaScript_humaneval-035": "function maxElement(l) {\n  if (!l.length) {\n    return 0;\n  }\n  return Math.max(...l);\n}",
  "Go_humaneval-035": "func maxElement(l []int) int {\n    if len(l) == 0 {\n        return 0\n    }\n    max := l[0]\n    for _, v := range l {\n        if v > max {\n            max = v\n        }\n    }\n    return max\n}",
  "PHP_humaneval-035": "function maxElement(array $l): int {\n    if (empty($l)) {\n        return 0;\n    }\n    return max($l);\n}",
  "Ruby_humaneval-035": "def max_element(l)\n  return 0 if l.empty?\n  l.max\nend",
  "Swift_humaneval-035": "func maxElement(_ l: [Int]) -> Int {\n  if l.isEmpty {\n    return 0\n  }\n  return l.max()!\n}",
  "TypeScript_humaneval-035": "function maxElement(l: number[]): number {\n  if (!l.length) {\n    return 0;\n  }\n  return Math.max(...l);\n}",
  "Dart_humaneval-035": "int maxElement(List<int> l) {\n  if (l.isEmpty) {\n    return 0;\n  }\n  return l.reduce((a, b) => a > b ? a : b);\n}",
  "Rust_humaneval-035": "fn max_element(l: Vec<i32>) -> i32 {\n    if l.is_empty() {\n        return 0;\n    }\n    *l.iter().max().unwrap()\n}",
  "Scala_humaneval-035": "def maxElement(l: List[Int]): Int = {\n  if (l.isEmpty) 0\n  else l.max\n}",
  "Kotlin_humaneval-035": "fun maxElement(l: List<Int>): Int {\n  if (l.isEmpty()) {\n    return 0\n  }\n  return l.maxOrNull()!!\n}",
  "C++_humaneval-036": "int fizzBuzz(int n) {\n  int count = 0;\n  for (int i = 0; i < n; i++) {\n    if (i % 11 == 0 || i % 13 == 0) {\n      string s = to_string(i);\n      count += std::count(s.begin(), s.end(), '7');\n    }\n  }\n  return count;\n}",
  "Java_humaneval-036": "public static Integer fizzBuzz(Integer n) {\n  Integer count = 0;\n  for (Integer i = 0; i < n; i++) {\n    if (i % 11 == 0 || i % 13 == 0) {\n      count += String.valueOf(i).split(\"7\", -1).length - 1;\n    }\n  }\n  return count;\n}",
  "Python_humaneval-036": "def fizz_buzz(n: int) -> int:\n    count = 0\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count(\"7\")\n    return count",
  "C#_humaneval-036": "public static int FizzBuzz(int n) {\n  int count = 0;\n  for (int i = 0; i < n; i++) {\n    if (i % 11 == 0 || i % 13 == 0) {\n      count += i.ToString().Count(c => c == '7');\n    }\n  }\n  return count;\n}",
  "JavaScript_humaneval-036": "function fizzBuzz(n) {\n  let count = 0;\n  for (let i = 0; i < n; i++) {\n    if (i % 11 === 0 || i % 13 === 0) {\n      count += String(i).split(\"7\").length - 1;\n    }\n  }\n  return count;\n}",
  "Go_humaneval-036": "func fizzBuzz(n int) int {\n    count := 0\n    for i := 0; i < n; i++ {\n        if i%11 == 0 || i%13 == 0 {\n            count += strings.Count(strconv.Itoa(i), \"7\")\n        }\n    }\n    return count\n}",
  "PHP_humaneval-036": "function fizzBuzz(int $n): int {\n    $count = 0;\n    for ($i = 0; $i < $n; $i++) {\n        if ($i % 11 == 0 || $i % 13 == 0) {\n            $count += substr_count((string)$i, \"7\");\n        }\n    }\n    return $count;\n}",
  "Ruby_humaneval-036": "def fizz_buzz(n)\n  count = 0\n  (0...n).each { |i| count += i.to_s.count(\"7\") if i % 11 == 0 || i % 13 == 0 }\n  count\nend",
  "Swift_humaneval-036": "func fizzBuzz(_ n: Int) -> Int {\n  var count = 0\n  for i in 0..<n {\n    if i % 11 == 0 || i % 13 == 0 {\n      count += String(i).filter { $0 == \"7\" }.count\n    }\n  }\n  return count\n}",
  "TypeScript_humaneval-036": "function fizzBuzz(n: number): number {\n  let count = 0;\n  for (let i = 0; i < n; i++) {\n    if (i % 11 === 0 || i % 13 === 0) {\n      count += String(i).split(\"7\").length - 1;\n    }\n  }\n  return count;\n}",
  "Dart_humaneval-036": "int fizzBuzz(int n) {\n  int count = 0;\n  for (int i = 0; i < n; i++) {\n    if (i % 11 == 0 || i % 13 == 0) {\n      count += i.toString().split(\"7\").length - 1;\n    }\n  }\n  return count;\n}",
  "Rust_humaneval-036": "fn fizz_buzz(n: i32) -> i32 {\n    let mut count = 0;\n    for i in 0..n {\n        if i % 11 == 0 || i % 13 == 0 {\n            count += i.to_string().matches(\"7\").count() as i32;\n        }\n    }\n    count\n}",
  "Scala_humaneval-036": "def fizzBuzz(n: Int): Int = {\n  var count = 0\n  for (i <- 0 until n) {\n    if (i % 11 == 0 || i % 13 == 0) {\n      count += i.toString.count(_ == '7')\n    }\n  }\n  count\n}",
  "Kotlin_humaneval-036": "fun fizzBuzz(n: Int): Int {\n  var count = 0\n  for (i in 0 until n) {\n    if (i % 11 == 0 || i % 13 == 0) {\n      count += i.toString().count { it == '7' }\n    }\n  }\n  return count\n}",
  "C++_humaneval-037": "vector<int> sortEven(vector<int> l) {\n  vector<int> even_indices;\n  for (int i = 0; i < l.size(); i++) {\n    if (i % 2 == 0) {\n      even_indices.push_back(i);\n    }\n  }\n  vector<int> even_values;\n  for (int i : even_indices) {\n    even_values.push_back(l[i]);\n  }\n  sort(even_values.begin(), even_values.end());\n  vector<int> result = l;\n  for (int i : even_indices) {\n    result[i] = even_values.front();\n    even_values.erase(even_values.begin());\n  }\n  return result;\n}",
  "Java_humaneval-037": "public static List<Integer> sortEven(List<Integer> l) {\n  List<Integer> evenIndices = new ArrayList<>();\n  for (int i = 0; i < l.size(); i++) {\n    if (i % 2 == 0) {\n      evenIndices.add(i);\n    }\n  }\n  List<Integer> evenValues = new ArrayList<>();\n  for (int i : evenIndices) {\n    evenValues.add(l.get(i));\n  }\n  Collections.sort(evenValues);\n  List<Integer> result = new ArrayList<>(l);\n  for (int i : evenIndices) {\n    result.set(i, evenValues.remove(0));\n  }\n  return result;\n}",
  "Python_humaneval-037": "def sort_even(l: List[int]) -> List[int]:\n    even_indices = [i for i in range(len(l)) if i % 2 == 0]\n    even_values = [l[i] for i in even_indices]\n    even_values.sort()\n    result = l.copy()\n    for i in even_indices:\n        result[i] = even_values.pop(0)\n    return result",
  "C#_humaneval-037": "public static List<int> SortEven(List<int> l) {\n  List<int> evenIndices = new List<int>();\n  for (int i = 0; i < l.Count; i++) {\n    if (i % 2 == 0) {\n      evenIndices.Add(i);\n    }\n  }\n  List<int> evenValues = new List<int>();\n  foreach (int i in evenIndices) {\n    evenValues.Add(l[i]);\n  }\n  evenValues.Sort();\n  List<int> result = new List<int>(l);\n  foreach (int i in evenIndices) {\n    result[i] = evenValues[0];\n    evenValues.RemoveAt(0);\n  }\n  return result;\n}",
  "JavaScript_humaneval-037": "function sortEven(l) {\n  let evenIndices = l.map((_, i) => i).filter((i) => i % 2 === 0);\n  let evenValues = evenIndices.map((i) => l[i]).sort((a, b) => a - b);\n  let result = [...l];\n  evenIndices.forEach((i, idx) => (result[i] = evenValues[idx]));\n  return result;\n}",
  "Go_humaneval-037": "func sortEven(l []int) []int {\n    evenIndices := make([]int, 0)\n    for i := range l {\n        if i%2 == 0 {\n            evenIndices = append(evenIndices, i)\n        }\n    }\n    evenValues := make([]int, len(evenIndices))\n    for i, index := range evenIndices {\n        evenValues[i] = l[index]\n    }\n    sort.Ints(evenValues)\n    result := make([]int, len(l))\n    copy(result, l)\n    for i, index := range evenIndices {\n        result[index] = evenValues[i]\n    }\n    return result\n}",
  "PHP_humaneval-037": "function sortEven(array $l): array {\n    $even_indices = array_filter(array_keys($l), function($i) {\n        return $i % 2 == 0;\n    });\n    $even_values = array_intersect_key($l, array_flip($even_indices));\n    sort($even_values);\n    $result = $l;\n    foreach ($even_indices as $i) {\n        $result[$i] = array_shift($even_values);\n    }\n    return $result;\n}",
  "Ruby_humaneval-037": "def sort_even(l)\n  even_indices = (0...l.length).select { |i| i.even? }\n  even_values = even_indices.map { |i| l[i] }.sort\n  result = l.dup\n  even_indices.each { |i| result[i] = even_values.shift }\n  result\nend",
  "Swift_humaneval-037": "func sortEven(_ l: [Int]) -> [Int] {\n  var evenIndices = [Int]()\n  for i in 0..<l.count where i % 2 == 0 {\n    evenIndices.append(i)\n  }\n  var evenValues = [Int]()\n  for i in evenIndices {\n    evenValues.append(l[i])\n  }\n  evenValues.sort()\n  var result = l\n  for i in evenIndices {\n    result[i] = evenValues.removeFirst()\n  }\n  return result\n}",
  "TypeScript_humaneval-037": "function sortEven(l: number[]): number[] {\n  const evenIndices = l.map((_, i) => i).filter((i) => i % 2 === 0);\n  const evenValues = evenIndices.map((i) => l[i]).sort((a, b) => a - b);\n  const result = [...l];\n  evenIndices.forEach((i, j) => {\n    result[i] = evenValues[j];\n  });\n  return result;\n}",
  "Dart_humaneval-037": "List<int> sortEven(List<int> l) {\n  List<int> evenIndices = [for (int i = 0; i < l.length; i += 2) i];\n  List<int> evenValues = [for (int i in evenIndices) l[i]];\n  evenValues.sort();\n  List<int> result = [...l];\n  for (int i in evenIndices) {\n    result[i] = evenValues.removeAt(0);\n  }\n  return result;\n}",
  "Rust_humaneval-037": "fn sort_even(l: Vec<i32>) -> Vec<i32> {\n    let mut l = l;\n    let even_indices: Vec<usize> = (0..l.len()).filter(|i| i % 2 == 0).collect();\n    let mut even_values: Vec<i32> = even_indices.iter().map(|i| l[*i]).collect();\n    even_values.sort();\n    for i in even_indices {\n        l[i] = even_values.remove(0);\n    }\n    l\n}",
  "Scala_humaneval-037": "def sortEven(l: List[Int]): List[Int] = {\n  val evenIndices = (0 until l.length by 2).toList\n  val evenValues = evenIndices.map(l(_)).sorted\n  val result = l.toArray\n  for (i <- evenIndices) {\n    result(i) = evenValues(i / 2)\n  }\n  result.toList\n}",
  "Kotlin_humaneval-037": "fun sortEven(l: List<Int>): List<Int> {\n  val evenIndices = l.indices.filter { it % 2 == 0 }\n  val evenValues = evenIndices.map { l[it] }.sorted()\n  val result = l.toMutableList()\n  evenIndices.forEachIndexed { index, i -> result[i] = evenValues[index] }\n  return result\n}",
  "C++_humaneval-038": "string encodeCyclic(string s) {\n  string encoded_groups = \"\";\n  for (int i = 0; i < s.length(); i += 3) {\n    string group = s.substr(i, 3);\n    if (group.length() == 3) {\n      string rotated_group = group.substr(1) + group[0];\n      encoded_groups += rotated_group;\n    } else {\n      encoded_groups += group;\n    }\n  }\n  return encoded_groups;\n}",
  "Java_humaneval-038": "public static String encodeCyclic(String s) {\n  List<String> encodedGroups = new ArrayList<>();\n  for (int i = 0; i < s.length(); i += 3) {\n    String group = s.substring(i, Math.min(i + 3, s.length()));\n    if (group.length() == 3) {\n      String rotatedGroup = group.substring(1) + group.charAt(0);\n      encodedGroups.add(rotatedGroup);\n    } else {\n      encodedGroups.add(group);\n    }\n  }\n  return String.join(\"\", encodedGroups);\n}",
  "Python_humaneval-038": "def encode_cyclic(s: str) -> str:\n    encoded_groups = []\n    for i in range(0, len(s), 3):\n        group = s[i : i + 3]\n        if len(group) == 3:\n            rotated_group = group[1:] + group[0]\n            encoded_groups.append(rotated_group)\n        else:\n            encoded_groups.append(group)\n    return \"\".join(encoded_groups)",
  "C#_humaneval-038": "public static string EncodeCyclic(string s) {\n  List<string> encodedGroups = new List<string>();\n  for (int i = 0; i < s.Length; i += 3) {\n    string group = s.Substring(i, Math.Min(3, s.Length - i));\n    if (group.Length == 3) {\n      string rotatedGroup = group.Substring(1) + group[0];\n      encodedGroups.Add(rotatedGroup);\n    } else {\n      encodedGroups.Add(group);\n    }\n  }\n  return string.Concat(encodedGroups);\n}",
  "JavaScript_humaneval-038": "function encodeCyclic(s) {\n  let encodedGroups = [];\n  for (let i = 0; i < s.length; i += 3) {\n    let group = s.slice(i, i + 3);\n    if (group.length === 3) {\n      let rotatedGroup = group.slice(1) + group[0];\n      encodedGroups.push(rotatedGroup);\n    } else {\n      encodedGroups.push(group);\n    }\n  }\n  return encodedGroups.join(\"\");\n}",
  "Go_humaneval-038": "func encodeCyclic(s string) string {\n    var encodedGroups []string\n    for i := 0; i < len(s); i += 3 {\n        end := i + 3\n        if end > len(s) {\n            end = len(s)\n        }\n        group := s[i:end]\n        if len(group) == 3 {\n            rotatedGroup := group[1:] + string(group[0])\n            encodedGroups = append(encodedGroups, rotatedGroup)\n        } else {\n            encodedGroups = append(encodedGroups, group)\n        }\n    }\n    return strings.Join(encodedGroups, \"\")\n}",
  "PHP_humaneval-038": "function encodeCyclic(string $s): string {\n    $encoded_groups = [];\n    for ($i = 0; $i < strlen($s); $i += 3) {\n        $group = substr($s, $i, 3);\n        if (strlen($group) == 3) {\n            $rotated_group = substr($group, 1) . $group[0];\n            $encoded_groups[] = $rotated_group;\n        } else {\n            $encoded_groups[] = $group;\n        }\n    }\n    return implode($encoded_groups);\n}",
  "Ruby_humaneval-038": "def encode_cyclic(s)\n  encoded_groups = []\n  (0...s.length).step(3) do |i|\n    group = s[i, 3]\n    if group.length == 3\n      rotated_group = group[1..2] + group[0]\n      encoded_groups << rotated_group\n    else\n      encoded_groups << group\n    end\n  end\n  encoded_groups.join\nend",
  "Swift_humaneval-038": "func encodeCyclic(_ s: String) -> String {\n  var encodedGroups = [String]()\n  for i in stride(from: 0, to: s.count, by: 3) {\n    let startIndex = s.index(s.startIndex, offsetBy: i)\n    let endIndex = s.index(startIndex, offsetBy: 3, limitedBy: s.endIndex) ?? s.endIndex\n    let group = String(s[startIndex..<endIndex])\n    if group.count == 3 {\n      let rotatedGroup = group.dropFirst() + String(group.first!)\n      encodedGroups.append(String(rotatedGroup))\n    } else {\n      encodedGroups.append(group)\n    }\n  }\n  return encodedGroups.joined()\n}",
  "TypeScript_humaneval-038": "function encodeCyclic(s: string): string {\n  const encodedGroups: string[] = [];\n  for (let i = 0; i < s.length; i += 3) {\n    const group = s.slice(i, i + 3);\n    if (group.length === 3) {\n      const rotatedGroup = group.slice(1) + group[0];\n      encodedGroups.push(rotatedGroup);\n    } else {\n      encodedGroups.push(group);\n    }\n  }\n  return encodedGroups.join(\"\");\n}",
  "Dart_humaneval-038": "String encodeCyclic(String s) {\n  List<String> encodedGroups = [];\n  for (int i = 0; i < s.length; i += 3) {\n    String group = s.substring(i, min(i + 3, s.length));\n    if (group.length == 3) {\n      String rotatedGroup = group.substring(1) + group[0];\n      encodedGroups.add(rotatedGroup);\n    } else {\n      encodedGroups.add(group);\n    }\n  }\n  return encodedGroups.join();\n}",
  "Rust_humaneval-038": "fn encode_cyclic(s: String) -> String {\n    let mut encoded_groups: Vec<String> = Vec::new();\n    let mut i = 0;\n    while i < s.len() {\n        let group = &s[i..std::cmp::min(i + 3, s.len())];\n        if group.len() == 3 {\n            let rotated_group = format!(\"{}{}\", &group[1..], &group[0..1]);\n            encoded_groups.push(rotated_group);\n        } else {\n            encoded_groups.push(group.to_string());\n        }\n        i += 3;\n    }\n    encoded_groups.join(\"\")\n}",
  "Scala_humaneval-038": "def encodeCyclic(s: String): String = {\n  var encodedGroups = List[String]()\n  for (i <- Range(0, s.length, 3)) {\n    val group = s.slice(i, i + 3)\n    if (group.length == 3) {\n      val rotatedGroup = group.tail + group.head\n      encodedGroups = encodedGroups :+ rotatedGroup\n    } else {\n      encodedGroups = encodedGroups :+ group\n    }\n  }\n  encodedGroups.mkString(\"\")\n}",
  "Kotlin_humaneval-038": "fun encodeCyclic(s: String): String {\n  val encodedGroups = mutableListOf<String>()\n  for (i in 0 until s.length step 3) {\n    val group = s.substring(i, min(i + 3, s.length))\n    val rotatedGroup = if (group.length == 3) group.substring(1) + group[0] else group\n    encodedGroups.add(rotatedGroup)\n  }\n  return encodedGroups.joinToString(\"\")\n}",
  "C++_humaneval-039": "bool isPrime(int p) {\n  if (p < 2) {\n    return false;\n  }\n  for (int k = 2; k <= sqrt(p); k++) {\n    if (p % k == 0) {\n      return false;\n    }\n  }\n  return true;\n}\nint primeFib(int n) {\n  vector<int> f = {0, 1};\n  while (true) {\n    f.push_back(f.back() + f[f.size() - 2]);\n    if (isPrime(f.back())) {\n      n--;\n    }\n    if (n == 0) {\n      return f.back();\n    }\n  }\n}",
  "Java_humaneval-039": "public static boolean isPrime(int p) {\n  if (p < 2) {\n    return false;\n  }\n  for (int k = 2; k <= (int) Math.sqrt(p); k++) {\n    if (p % k == 0) {\n      return false;\n    }\n  }\n  return true;\n}\npublic static Integer primeFib(Integer n) {\n  int[] f = {0, 1};\n  while (true) {\n    f = Arrays.copyOf(f, f.length + 1);\n    f[f.length - 1] = f[f.length - 2] + f[f.length - 3];\n    if (isPrime(f[f.length - 1])) {\n      n--;\n    }\n    if (n == 0) {\n      return f[f.length - 1];\n    }\n  }\n}",
  "Python_humaneval-039": "def is_prime(p):\n    if p < 2:\n        return False\n    for k in range(2, int(math.sqrt(p)) + 1):\n        if p % k == 0:\n            return False\n    return True\ndef prime_fib(n: int) -> int:\n    f = [0, 1]\n    while True:\n        f.append(f[-1] + f[-2])\n        if is_prime(f[-1]):\n            n -= 1\n        if n == 0:\n            return f[-1]",
  "C#_humaneval-039": "public static bool IsPrime(int p) {\n  if (p < 2) {\n    return false;\n  }\n  for (int k = 2; k <= Math.Sqrt(p); k++) {\n    if (p % k == 0) {\n      return false;\n    }\n  }\n  return true;\n}\npublic static int PrimeFib(int n) {\n  int[] f = new int[] { 0, 1 };\n  while (true) {\n    Array.Resize(ref f, f.Length + 1);\n    f[f.Length - 1] = f[f.Length - 2] + f[f.Length - 3];\n    if (IsPrime(f[f.Length - 1])) {\n      n -= 1;\n    }\n    if (n == 0) {\n      return f[f.Length - 1];\n    }\n  }\n}",
  "JavaScript_humaneval-039": "function isPrime(p) {\n  if (p < 2) {\n    return false;\n  }\n  for (let k = 2; k <= Math.sqrt(p); k++) {\n    if (p % k === 0) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction primeFib(n) {\n  const f = [0, 1];\n  while (true) {\n    f.push(f[f.length - 1] + f[f.length - 2]);\n    if (isPrime(f[f.length - 1])) {\n      n--;\n    }\n    if (n === 0) {\n      return f[f.length - 1];\n    }\n  }\n}",
  "Go_humaneval-039": "func isPrime(p int) bool {\n    if p < 2 {\n        return false\n    }\n    for k := 2; k <= int(math.Sqrt(float64(p))); k++ {\n        if p%k == 0 {\n            return false\n        }\n    }\n    return true\n}\nfunc primeFib(n int) int {\n    f := []int{0, 1}\n    for {\n        f = append(f, f[len(f)-1]+f[len(f)-2])\n        if isPrime(f[len(f)-1]) {\n            n--\n        }\n        if n == 0 {\n            return f[len(f)-1]\n        }\n    }\n}",
  "PHP_humaneval-039": "function is_prime($p) {\n    if ($p < 2) {\n        return false;\n    }\n    for ($k = 2; $k <= sqrt($p); $k++) {\n        if ($p % $k == 0) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction primeFib(int $n): int {\n    $f = [0, 1];\n    while (true) {\n        $f[] = $f[count($f) - 1] + $f[count($f) - 2];\n        if (is_prime($f[count($f) - 1])) {\n            $n--;\n        }\n        if ($n == 0) {\n            return $f[count($f) - 1];\n        }\n    }\n}",
  "Ruby_humaneval-039": "def is_prime(p)\n  return false if p < 2\n  (2..Math.sqrt(p).to_i).each { |k| return false if p % k == 0 }\n  true\nend\ndef prime_fib(n)\n  f = [0, 1]\n  loop do\n    f << f[-1] + f[-2]\n    n -= 1 if is_prime(f[-1])\n    return f[-1] if n == 0\n  end\nend",
  "Swift_humaneval-039": "func isPrime(_ p: Int) -> Bool {\n  if p < 2 {\n    return false\n  }\n  for k in 2..<Int(sqrt(Double(p)) + 1) {\n    if p % k == 0 {\n      return false\n    }\n  }\n  return true\n}\nfunc primeFib(_ n: Int) -> Int {\n  var f = [0, 1]\n  var num = n\n  while true {\n    f.append(f[f.count - 1] + f[f.count - 2])\n    if isPrime(f[f.count - 1]) {\n      if num == 1 {\n        return f[f.count - 1]\n      }\n      num -= 1\n    }\n  }\n}",
  "TypeScript_humaneval-039": "function isPrime(p: number): boolean {\n  if (p < 2) {\n    return false;\n  }\n  for (let k = 2; k <= Math.sqrt(p); k++) {\n    if (p % k === 0) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction primeFib(n: number): number {\n  const f: number[] = [0, 1];\n  while (true) {\n    f.push(f[f.length - 1] + f[f.length - 2]);\n    if (isPrime(f[f.length - 1])) {\n      n -= 1;\n    }\n    if (n === 0) {\n      return f[f.length - 1];\n    }\n  }\n}",
  "Dart_humaneval-039": "bool isPrime(int p) {\n  if (p < 2) {\n    return false;\n  }\n  for (int k = 2; k <= sqrt(p); k++) {\n    if (p % k == 0) {\n      return false;\n    }\n  }\n  return true;\n}\nint primeFib(int n) {\n  List<int> f = [0, 1];\n  while (true) {\n    f.add(f[f.length - 1] + f[f.length - 2]);\n    if (isPrime(f[f.length - 1])) {\n      n--;\n    }\n    if (n == 0) {\n      return f[f.length - 1];\n    }\n  }\n}",
  "Rust_humaneval-039": "fn is_prime(p: i32) -> bool {\n    if p < 2 {\n        return false;\n    }\n    for k in 2..=((p as f64).sqrt() as i32) {\n        if p % k == 0 {\n            return false;\n        }\n    }\n    true\n}\nfn prime_fib(n: i32) -> i32 {\n    let mut f = vec![0, 1];\n    let mut num = n;\n    loop {\n        let next_fib = f[f.len() - 1] + f[f.len() - 2];\n        f.push(next_fib);\n        if is_prime(next_fib) {\n            if num == 1 {\n                return next_fib;\n            }\n            num -= 1;\n        }\n    }\n}",
  "Scala_humaneval-039": "def isPrime(p: Int): Boolean = {\n  if (p < 2) false\n  else {\n    for (k <- 2 to sqrt(p).toInt) {\n      if (p % k == 0) return false\n    }\n    true\n  }\n}\ndef primeFib(n: Int): Int = {\n  var f = List(0, 1)\n  var num = n\n  while (true) {\n    f = f :+ (f.takeRight(2).sum)\n    if (isPrime(f.last)) num -= 1\n    if (num == 0) return f.last\n  }\n  0\n}",
  "Kotlin_humaneval-039": "fun isPrime(p: Int): Boolean {\n  if (p < 2) {\n    return false\n  }\n  for (k in 2..sqrt(p.toDouble()).toInt()) {\n    if (p % k == 0) {\n      return false\n    }\n  }\n  return true\n}\nfun primeFib(n: Int): Int {\n  val f = mutableListOf(0, 1)\n  var num = n\n  while (true) {\n    f.add(f[f.size - 1] + f[f.size - 2])\n    if (isPrime(f[f.size - 1])) {\n      num -= 1\n    }\n    if (num == 0) {\n      return f[f.size - 1]\n    }\n  }\n}",
  "C++_humaneval-040": "bool triplesSumToZero(vector<int> l) {\n  if (l.size() < 3) {\n    return false;\n  }\n  sort(l.begin(), l.end());\n  for (int i = 0; i < l.size() - 2; i++) {\n    int left = i + 1;\n    int right = l.size() - 1;\n    while (left < right) {\n      int total = l[i] + l[left] + l[right];\n      if (total == 0) {\n        return true;\n      } else if (total < 0) {\n        left++;\n      } else {\n        right--;\n      }\n    }\n  }\n  return false;\n}",
  "Java_humaneval-040": "public static Boolean triplesSumToZero(List<Integer> l) {\n  if (l.size() < 3) {\n    return false;\n  }\n  Collections.sort(l);\n  for (int i = 0; i < l.size() - 2; i++) {\n    int left = i + 1;\n    int right = l.size() - 1;\n    while (left < right) {\n      int total = l.get(i) + l.get(left) + l.get(right);\n      if (total == 0) {\n        return true;\n      } else if (total < 0) {\n        left++;\n      } else {\n        right--;\n      }\n    }\n  }\n  return false;\n}",
  "Python_humaneval-040": "def triples_sum_to_zero(l: List[int]) -> bool:\n    if len(l) < 3:\n        return False\n    l.sort()\n    for i in range(len(l) - 2):\n        left = i + 1\n        right = len(l) - 1\n        while left < right:\n            total = l[i] + l[left] + l[right]\n            if total == 0:\n                return True\n            elif total < 0:\n                left += 1\n            else:\n                right -= 1\n    return False",
  "C#_humaneval-040": "public static bool TriplesSumToZero(List<int> l) {\n  if (l.Count < 3) {\n    return false;\n  }\n  l.Sort();\n  for (int i = 0; i < l.Count - 2; i++) {\n    int left = i + 1;\n    int right = l.Count - 1;\n    while (left < right) {\n      int total = l[i] + l[left] + l[right];\n      if (total == 0) {\n        return true;\n      } else if (total < 0) {\n        left += 1;\n      } else {\n        right -= 1;\n      }\n    }\n  }\n  return false;\n}",
  "JavaScript_humaneval-040": "function triplesSumToZero(l) {\n  if (l.length < 3) {\n    return false;\n  }\n  l.sort((a, b) => a - b);\n  for (let i = 0; i < l.length - 2; i++) {\n    let left = i + 1;\n    let right = l.length - 1;\n    while (left < right) {\n      let total = l[i] + l[left] + l[right];\n      if (total === 0) {\n        return true;\n      } else if (total < 0) {\n        left++;\n      } else {\n        right--;\n      }\n    }\n  }\n  return false;\n}",
  "Go_humaneval-040": "func triplesSumToZero(l []int) bool {\n    if len(l) < 3 {\n        return false\n    }\n    sort.Ints(l)\n    for i := 0; i < len(l)-2; i++ {\n        left := i + 1\n        right := len(l) - 1\n        for left < right {\n            total := l[i] + l[left] + l[right]\n            if total == 0 {\n                return true\n            } else if total < 0 {\n                left++\n            } else {\n                right--\n            }\n        }\n    }\n    return false\n}",
  "PHP_humaneval-040": "function triplesSumToZero(array $l): bool {\n    if (count($l) < 3) {\n        return false;\n    }\n    sort($l);\n    for ($i = 0; $i < count($l) - 2; $i++) {\n        $left = $i + 1;\n        $right = count($l) - 1;\n        while ($left < $right) {\n            $total = $l[$i] + $l[$left] + $l[$right];\n            if ($total == 0) {\n                return true;\n            } elseif ($total < 0) {\n                $left++;\n            } else {\n                $right--;\n            }\n        }\n    }\n    return false;\n}",
  "Ruby_humaneval-040": "def triples_sum_to_zero(l)\n  return false if l.length < 3\n  l.sort!\n  (0..l.length - 3).each do |i|\n    left = i + 1\n    right = l.length - 1\n    while left < right\n      total = l[i] + l[left] + l[right]\n      return true if total == 0\n      total < 0 ? left += 1 : right -= 1\n    end\n  end\n  false\nend",
  "Swift_humaneval-040": "func triplesSumToZero(_ l: [Int]) -> Bool {\n  if l.count < 3 {\n    return false\n  }\n  var sortedL = l.sorted()\n  for i in 0..<(sortedL.count - 2) {\n    var left = i + 1\n    var right = sortedL.count - 1\n    while left < right {\n      let total = sortedL[i] + sortedL[left] + sortedL[right]\n      if total == 0 {\n        return true\n      } else if total < 0 {\n        left += 1\n      } else {\n        right -= 1\n      }\n    }\n  }\n  return false\n}",
  "TypeScript_humaneval-040": "function triplesSumToZero(l: number[]): boolean {\n  if (l.length < 3) {\n    return false;\n  }\n  l.sort();\n  for (let i = 0; i < l.length - 2; i++) {\n    let left = i + 1;\n    let right = l.length - 1;\n    while (left < right) {\n      const total = l[i] + l[left] + l[right];\n      if (total === 0) {\n        return true;\n      } else if (total < 0) {\n        left++;\n      } else {\n        right--;\n      }\n    }\n  }\n  return false;\n}",
  "Dart_humaneval-040": "bool triplesSumToZero(List<int> l) {\n  if (l.length < 3) {\n    return false;\n  }\n  l.sort();\n  for (var i = 0; i < l.length - 2; i++) {\n    var left = i + 1;\n    var right = l.length - 1;\n    while (left < right) {\n      var total = l[i] + l[left] + l[right];\n      if (total == 0) {\n        return true;\n      } else if (total < 0) {\n        left++;\n      } else {\n        right--;\n      }\n    }\n  }\n  return false;\n}",
  "Rust_humaneval-040": "fn triples_sum_to_zero(l: Vec<i32>) -> bool {\n    let mut l = l;\n    if l.len() < 3 {\n        return false;\n    }\n    l.sort();\n    for i in 0..l.len() - 2 {\n        let mut left = i + 1;\n        let mut right = l.len() - 1;\n        while left < right {\n            let total = l[i] + l[left] + l[right];\n            if total == 0 {\n                return true;\n            } else if total < 0 {\n                left += 1;\n            } else {\n                right -= 1;\n            }\n        }\n    }\n    false\n}",
  "Scala_humaneval-040": "def triplesSumToZero(l: List[Int]): Boolean = {\n  if (l.length < 3) {\n    return false\n  }\n  val sortedList = l.sorted\n  for (i <- 0 until sortedList.length - 2) {\n    var left = i + 1\n    var right = sortedList.length - 1\n    while (left < right) {\n      val total = sortedList(i) + sortedList(left) + sortedList(right)\n      if (total == 0) {\n        return true\n      } else if (total < 0) {\n        left += 1\n      } else {\n        right -= 1\n      }\n    }\n  }\n  false\n}",
  "Kotlin_humaneval-040": "fun triplesSumToZero(l: List<Int>): Boolean {\n  if (l.size < 3) {\n    return false\n  }\n  val sortedList = l.sorted()\n  for (i in 0..l.size - 3) {\n    var left = i + 1\n    var right = l.size - 1\n    while (left < right) {\n      val total = sortedList[i] + sortedList[left] + sortedList[right]\n      when {\n        total == 0 -> return true\n        total < 0 -> left++\n        else -> right--\n      }\n    }\n  }\n  return false\n}",
  "C++_humaneval-041": "int carRaceCollision(int n) { return n * n; }",
  "Java_humaneval-041": "public static Integer carRaceCollision(Integer n) {\n  return n * n;\n}",
  "Python_humaneval-041": "def car_race_collision(n: int) -> int:\n    return n * n",
  "C#_humaneval-041": "public static int CarRaceCollision(int n) {\n  return n * n;\n}",
  "JavaScript_humaneval-041": "function carRaceCollision(n) {\n  return n * n;\n}",
  "Go_humaneval-041": "func carRaceCollision(n int) int {\n    return n * n\n}",
  "PHP_humaneval-041": "function carRaceCollision(int $n): int {\n    return $n * $n;\n}",
  "Ruby_humaneval-041": "def car_race_collision(n)\n  return n * n\nend",
  "Swift_humaneval-041": "func carRaceCollision(_ n: Int) -> Int {\n  return n * n\n}",
  "TypeScript_humaneval-041": "function carRaceCollision(n: number): number {\n  return n * n;\n}",
  "Dart_humaneval-041": "int carRaceCollision(int n) {\n  return n * n;\n}",
  "Rust_humaneval-041": "fn car_race_collision(n: i32) -> i32 {\n    n * n\n}",
  "Scala_humaneval-041": "def carRaceCollision(n: Int): Int = {\n  n * n\n}",
  "Kotlin_humaneval-041": "fun carRaceCollision(n: Int): Int {\n  return n * n\n}",
  "C++_humaneval-042": "vector<int> incrList(vector<int> l) {\n  vector<int> res;\n  for (int i = 0; i < l.size(); i++) {\n    res.push_back(l[i] + 1);\n  }\n  return res;\n}",
  "Java_humaneval-042": "public static List<Integer> incrList(List<Integer> l) {\n  List<Integer> result = new ArrayList<>();\n  for (int i : l) {\n    result.add(i + 1);\n  }\n  return result;\n}",
  "Python_humaneval-042": "def incr_list(l: List[int]) -> List[int]:\n    return [i + 1 for i in l]",
  "C#_humaneval-042": "public static List<int> IncrList(List<int> l) {\n  return l.Select(i => i + 1).ToList();\n}",
  "JavaScript_humaneval-042": "function incrList(l) {\n  return l.map((i) => i + 1);\n}",
  "Go_humaneval-042": "func incrList(l []int) []int {\n    res := make([]int, len(l))\n    for i, v := range l {\n        res[i] = v + 1\n    }\n    return res\n}",
  "PHP_humaneval-042": "function incrList(array $l): array {\n    return array_map(function($i){ return $i + 1; }, $l);\n}",
  "Ruby_humaneval-042": "def incr_list(l)\n  l.map { |i| i + 1 }\nend",
  "Swift_humaneval-042": "func incrList(_ l: [Int]) -> [Int] {\n  return l.map { $0 + 1 }\n}",
  "TypeScript_humaneval-042": "function incrList(l: number[]): number[] {\n  return l.map((i) => i + 1);\n}",
  "Dart_humaneval-042": "List<int> incrList(List<int> l) {\n  return [for (int i in l) i + 1];\n}",
  "Rust_humaneval-042": "fn incr_list(l: Vec<i32>) -> Vec<i32> {\n    l.iter().map(|&x| x + 1).collect()\n}",
  "Scala_humaneval-042": "def incrList(l: List[Int]): List[Int] = {\n  l.map(_ + 1)\n}",
  "Kotlin_humaneval-042": "fun incrList(l: List<Int>): List<Int> {\n  return l.map { it + 1 }\n}",
  "C++_humaneval-043": "bool pairsSumToZero(vector<int> l) {\n  unordered_set<int> seen;\n  for (int num : l) {\n    if (seen.count(-num)) {\n      return true;\n    }\n    seen.insert(num);\n  }\n  return false;\n}",
  "Java_humaneval-043": "public static Boolean pairsSumToZero(List<Integer> l) {\n  Set<Integer> seen = new HashSet<>();\n  for (int num : l) {\n    if (seen.contains(-num)) {\n      return true;\n    }\n    seen.add(num);\n  }\n  return false;\n}",
  "Python_humaneval-043": "def pairs_sum_to_zero(l: List[int]) -> bool:\n    seen = set()\n    for num in l:\n        if -num in seen:\n            return True\n        seen.add(num)\n    return False",
  "C#_humaneval-043": "public static bool PairsSumToZero(List<int> l) {\n  HashSet<int> seen = new HashSet<int>();\n  foreach (int num in l) {\n    if (seen.Contains(-num)) {\n      return true;\n    }\n    seen.Add(num);\n  }\n  return false;\n}",
  "JavaScript_humaneval-043": "function pairsSumToZero(l) {\n  const seen = new Set();\n  for (let num of l) {\n    if (seen.has(-num)) {\n      return true;\n    }\n    seen.add(num);\n  }\n  return false;\n}",
  "Go_humaneval-043": "func pairsSumToZero(l []int) bool {\n    seen := make(map[int]bool)\n    for _, num := range l {\n        if seen[-num] {\n            return true\n        }\n        seen[num] = true\n    }\n    return false\n}",
  "PHP_humaneval-043": "function pairsSumToZero(array $l): bool {\n    $seen = [];\n    foreach ($l as $num) {\n        if (in_array(-$num, $seen)) {\n            return true;\n        }\n        $seen[] = $num;\n    }\n    return false;\n}",
  "Ruby_humaneval-043": "def pairs_sum_to_zero(l)\n  seen = Set.new\n  l.each do |num|\n    return true if seen.include?(-num)\n    seen.add(num)\n  end\n  false\nend",
  "Swift_humaneval-043": "func pairsSumToZero(_ l: [Int]) -> Bool {\n  var seen = Set<Int>()\n  for num in l {\n    if seen.contains(-num) {\n      return true\n    }\n    seen.insert(num)\n  }\n  return false\n}",
  "TypeScript_humaneval-043": "function pairsSumToZero(l: number[]): boolean {\n  const seen = new Set<number>();\n  for (const num of l) {\n    if (seen.has(-num)) {\n      return true;\n    }\n    seen.add(num);\n  }\n  return false;\n}",
  "Dart_humaneval-043": "bool pairsSumToZero(List<int> l) {\n  Set<int> seen = {};\n  for (int num in l) {\n    if (seen.contains(-num)) {\n      return true;\n    }\n    seen.add(num);\n  }\n  return false;\n}",
  "Rust_humaneval-043": "fn pairs_sum_to_zero(l: Vec<i32>) -> bool {\n    let mut seen = HashSet::new();\n    for num in l {\n        if seen.contains(&(-num)) {\n            return true;\n        }\n        seen.insert(num);\n    }\n    false\n}",
  "Scala_humaneval-043": "def pairsSumToZero(l: List[Int]): Boolean = {\n  var seen = Set[Int]()\n  for (num <- l) {\n    if (seen.contains(-num)) {\n      return true\n    }\n    seen += num\n  }\n  false\n}",
  "Kotlin_humaneval-043": "fun pairsSumToZero(l: List<Int>): Boolean {\n  val seen = HashSet<Int>()\n  for (num in l) {\n    if (-num in seen) {\n      return true\n    }\n    seen.add(num)\n  }\n  return false\n}",
  "C++_humaneval-044": "string changeBase(int x, int b) {\n  if (x == 0) {\n    return \"0\";\n  }\n  string digits = \"\";\n  while (x > 0) {\n    digits += to_string(x % b);\n    x /= b;\n  }\n  reverse(digits.begin(), digits.end());\n  return digits;\n}",
  "Java_humaneval-044": "public static String changeBase(Integer x, Integer b) {\n  if (x == 0) {\n    return \"0\";\n  }\n  List<String> digits = new ArrayList<>();\n  while (x > 0) {\n    digits.add(String.valueOf(x % b));\n    x /= b;\n  }\n  Collections.reverse(digits);\n  return String.join(\"\", digits);\n}",
  "Python_humaneval-044": "def change_base(x: int, b: int) -> str:\n    if x == 0:\n        return \"0\"\n    digits = []\n    while x > 0:\n        digits.append(str(x % b))\n        x //= b\n    return \"\".join(digits[::-1])",
  "C#_humaneval-044": "public static string ChangeBase(int x, int b) {\n  if (x == 0) {\n    return \"0\";\n  }\n  List<string> digits = new List<string>();\n  while (x > 0) {\n    digits.Add((x % b).ToString());\n    x /= b;\n  }\n  digits.Reverse();\n  return string.Join(\"\", digits);\n}",
  "JavaScript_humaneval-044": "function changeBase(x, b) {\n  if (x === 0) {\n    return \"0\";\n  }\n  let digits = [];\n  while (x > 0) {\n    digits.push(String(x % b));\n    x = Math.floor(x / b);\n  }\n  return digits.reverse().join(\"\");\n}",
  "Go_humaneval-044": "func changeBase(x int, b int) string {\n    if x == 0 {\n        return \"0\"\n    }\n    digits := []string{}\n    for x > 0 {\n        digits = append(digits, strconv.Itoa(x%b))\n        x /= b\n    }\n    reversed := []string{}\n    for i := len(digits) - 1; i >= 0; i-- {\n        reversed = append(reversed, digits[i])\n    }\n    return strings.Join(reversed, \"\")\n}",
  "PHP_humaneval-044": "function changeBase(int $x, int $b): string {\n    if ($x == 0) {\n        return \"0\";\n    }\n    $digits = [];\n    while ($x > 0) {\n        array_push($digits, strval($x % $b));\n        $x = intdiv($x, $b);\n    }\n    return join(array_reverse($digits));\n}",
  "Ruby_humaneval-044": "def change_base(x, b)\n  return \"0\" if x == 0\n  digits = []\n  while x > 0\n    digits << (x % b).to_s\n    x /= b\n  end\n  digits.reverse.join(\"\")\nend",
  "Swift_humaneval-044": "func changeBase(_ x: Int, _ b: Int) -> String {\n  if x == 0 {\n    return \"0\"\n  }\n  var digits = [String]()\n  var xCopy = x\n  while xCopy > 0 {\n    digits.append(String(xCopy % b))\n    xCopy /= b\n  }\n  return digits.reversed().joined()\n}",
  "TypeScript_humaneval-044": "function changeBase(x: number, b: number): string {\n  if (x === 0) {\n    return \"0\";\n  }\n  const digits: string[] = [];\n  while (x > 0) {\n    digits.push(String(x % b));\n    x = Math.floor(x / b);\n  }\n  return digits.reverse().join(\"\");\n}",
  "Dart_humaneval-044": "String changeBase(int x, int b) {\n  if (x == 0) {\n    return \"0\";\n  }\n  List<String> digits = [];\n  while (x > 0) {\n    digits.add((x % b).toString());\n    x ~/= b;\n  }\n  return digits.reversed.join();\n}",
  "Rust_humaneval-044": "fn change_base(x: i32, b: i32) -> String {\n    let mut x = x;\n    if x == 0 {\n        return \"0\".to_string();\n    }\n    let mut digits = Vec::new();\n    while x > 0 {\n        digits.push((x % b).to_string());\n        x /= b;\n    }\n    digits.reverse();\n    digits.join(\"\")\n}",
  "Scala_humaneval-044": "def changeBase(x: Int, b: Int): String = {\n  if (x == 0) {\n    return \"0\"\n  }\n  var digits = List[String]()\n  var num = x\n  while (num > 0) {\n    digits :+= (num % b).toString\n    num /= b\n  }\n  digits.reverse.mkString(\"\")\n}",
  "Kotlin_humaneval-044": "fun changeBase(x: Int, b: Int): String {\n  if (x == 0) {\n    return \"0\"\n  }\n  val digits = mutableListOf<String>()\n  var num = x\n  while (num > 0) {\n    digits.add((num % b).toString())\n    num /= b\n  }\n  return digits.reversed().joinToString(\"\")\n}",
  "C++_humaneval-045": "double triangleArea(int a, int h) { return a * h / 2.0; }",
  "Java_humaneval-045": "public static Double triangleArea(Integer a, Integer h) {\n  return a * h / 2.0;\n}",
  "Python_humaneval-045": "def triangle_area(a: int, h: int) -> float:\n    return a * h / 2",
  "C#_humaneval-045": "public static double TriangleArea(int a, int h) {\n  return a * h / 2.0;\n}",
  "JavaScript_humaneval-045": "function triangleArea(a, h) {\n  return (a * h) / 2;\n}",
  "Go_humaneval-045": "func triangleArea(a int, h int) float64 {\n    return float64(a*h) / 2\n}",
  "PHP_humaneval-045": "function triangleArea(int $a, int $h): float {\n    return $a * $h / 2;\n}",
  "Ruby_humaneval-045": "def triangle_area(a, h)\n  return a * h / 2.0\nend",
  "Swift_humaneval-045": "func triangleArea(_ a: Int, _ h: Int) -> Double {\n  return Double(a * h) / 2\n}",
  "TypeScript_humaneval-045": "function triangleArea(a: number, h: number): number {\n  return (a * h) / 2;\n}",
  "Dart_humaneval-045": "double triangleArea(int a, int h) {\n  return a * h / 2;\n}",
  "Rust_humaneval-045": "fn triangle_area(a: i32, h: i32) -> f64 {\n    (a * h) as f64 / 2.0\n}",
  "Scala_humaneval-045": "def triangleArea(a: Int, h: Int): Double = {\n  a * h / 2.0\n}",
  "Kotlin_humaneval-045": "fun triangleArea(a: Int, h: Int): Double {\n  return a * h / 2.0\n}",
  "C++_humaneval-046": "int fib4(int n) {\n  if (n == 0 || n == 1) {\n    return 0;\n  } else if (n == 2) {\n    return 2;\n  } else {\n    int a = 0, b = 0, c = 2, d = 0;\n    for (int i = 3; i < n; i++) {\n      int e = a + b + c + d;\n      a = b;\n      b = c;\n      c = d;\n      d = e;\n    }\n    return d;\n  }\n}",
  "Java_humaneval-046": "public static Integer fib4(Integer n) {\n  if (n == 0 || n == 1) {\n    return 0;\n  } else if (n == 2) {\n    return 2;\n  } else {\n    int a = 0, b = 0, c = 2, d = 0;\n    for (int i = 3; i < n; i++) {\n      int e = a + b + c + d;\n      a = b;\n      b = c;\n      c = d;\n      d = e;\n    }\n    return d;\n  }\n}",
  "Python_humaneval-046": "def fib4(n: int) -> int:\n    if n == 0 or n == 1:\n        return 0\n    elif n == 2:\n        return 2\n    else:\n        a, b, c, d = 0, 0, 2, 0\n        for i in range(3, n):\n            e = a + b + c + d\n            a, b, c, d = b, c, d, e\n        return d",
  "C#_humaneval-046": "public static int Fib4(int n) {\n  if (n == 0 || n == 1) {\n    return 0;\n  } else if (n == 2) {\n    return 2;\n  } else {\n    int a = 0, b = 0, c = 2, d = 0;\n    for (int i = 3; i < n; i++) {\n      int e = a + b + c + d;\n      a = b;\n      b = c;\n      c = d;\n      d = e;\n    }\n    return d;\n  }\n}",
  "JavaScript_humaneval-046": "function fib4(n) {\n  if (n === 0 || n === 1) {\n    return 0;\n  } else if (n === 2) {\n    return 2;\n  } else {\n    let a = 0,\n      b = 0,\n      c = 2,\n      d = 0;\n    for (let i = 3; i < n; i++) {\n      let e = a + b + c + d;\n      a = b;\n      b = c;\n      c = d;\n      d = e;\n    }\n    return d;\n  }\n}",
  "Go_humaneval-046": "func fib4(n int) int {\n    if n == 0 || n == 1 {\n        return 0\n    } else if n == 2 {\n        return 2\n    } else {\n        a, b, c, d := 0, 0, 2, 0\n        for i := 3; i < n; i++ {\n            e := a + b + c + d\n            a, b, c, d = b, c, d, e\n        }\n        return d\n    }\n}",
  "PHP_humaneval-046": "function fib4(int $n): int {\n    if ($n == 0 || $n == 1) {\n        return 0;\n    } elseif ($n == 2) {\n        return 2;\n    } else {\n        $a = $b = $d = 0;\n        $c = 2;\n        for ($i = 3; $i < $n; $i++) {\n            $e = $a + $b + $c + $d;\n            list($a, $b, $c, $d) = [$b, $c, $d, $e];\n        }\n        return $d;\n    }\n}",
  "Ruby_humaneval-046": "def fib4(n)\n  if n == 0 || n == 1\n    return 0\n  elsif n == 2\n    return 2\n  else\n    a, b, c, d = 0, 0, 2, 0\n    (3...n).each do |i|\n      e = a + b + c + d\n      a, b, c, d = b, c, d, e\n    end\n    return d\n  end\nend",
  "Swift_humaneval-046": "func fib4(_ n: Int) -> Int {\n  if n == 0 || n == 1 {\n    return 0\n  } else if n == 2 {\n    return 2\n  } else {\n    var (a, b, c, d) = (0, 0, 2, 0)\n    for i in 3..<n {\n      let e = a + b + c + d\n      (a, b, c, d) = (b, c, d, e)\n    }\n    return d\n  }\n}",
  "TypeScript_humaneval-046": "function fib4(n: number): number {\n  if (n === 0 || n === 1) {\n    return 0;\n  } else if (n === 2) {\n    return 2;\n  } else {\n    let a = 0,\n      b = 0,\n      c = 2,\n      d = 0;\n    for (let i = 3; i < n; i++) {\n      const e = a + b + c + d;\n      a = b;\n      b = c;\n      c = d;\n      d = e;\n    }\n    return d;\n  }\n}",
  "Dart_humaneval-046": "int fib4(int n) {\n  if (n == 0 || n == 1) {\n    return 0;\n  } else if (n == 2) {\n    return 2;\n  } else {\n    int a = 0, b = 0, c = 2, d = 0;\n    for (int i = 3; i < n; i++) {\n      int e = a + b + c + d;\n      a = b;\n      b = c;\n      c = d;\n      d = e;\n    }\n    return d;\n  }\n}",
  "Rust_humaneval-046": "fn fib4(n: i32) -> i32 {\n    if n == 0 || n == 1 {\n        return 0;\n    } else if n == 2 {\n        return 2;\n    } else {\n        let (mut a, mut b, mut c, mut d) = (0, 0, 2, 0);\n        for i in 3..n {\n            let e = a + b + c + d;\n            a = b;\n            b = c;\n            c = d;\n            d = e;\n        }\n        return d;\n    }\n}",
  "Scala_humaneval-046": "def fib4(n: Int): Int = {\n  if (n == 0 || n == 1) {\n    0\n  } else if (n == 2) {\n    2\n  } else {\n    var (a, b, c, d) = (0, 0, 2, 0)\n    for (i <- 3 until n) {\n      val e = a + b + c + d\n      a = b\n      b = c\n      c = d\n      d = e\n    }\n    d\n  }\n}",
  "Kotlin_humaneval-046": "fun fib4(n: Int): Int {\n  if (n == 0 || n == 1) {\n    return 0\n  } else if (n == 2) {\n    return 2\n  } else {\n    var a = 0\n    var b = 0\n    var c = 2\n    var d = 0\n    for (i in 3 until n) {\n      val e = a + b + c + d\n      a = b\n      b = c\n      c = d\n      d = e\n    }\n    return d\n  }\n}",
  "C++_humaneval-047": "double median(vector<int> l) {\n  sort(l.begin(), l.end());\n  int length = l.size();\n  if (length % 2 == 0) {\n    return (l[length / 2 - 1] + l[length / 2]) / 2.0;\n  } else {\n    return l[length / 2];\n  }\n}",
  "Java_humaneval-047": "public static Double median(List<Integer> l) {\n  List<Integer> sortedList = new ArrayList<>(l);\n  Collections.sort(sortedList);\n  int length = sortedList.size();\n  if (length % 2 == 0) {\n    return (sortedList.get(length / 2 - 1) + sortedList.get(length / 2)) / 2.0;\n  } else {\n    return (double) sortedList.get(length / 2);\n  }\n}",
  "Python_humaneval-047": "def median(l: List[int]) -> float:\n    sorted_list = sorted(l)\n    length = len(sorted_list)\n    if length % 2 == 0:\n        return (sorted_list[length // 2 - 1] + sorted_list[length // 2]) / 2\n    else:\n        return sorted_list[length // 2]",
  "C#_humaneval-047": "public static double Median(List<int> l) {\n  List<int> sortedList = l.OrderBy(x => x).ToList();\n  int length = sortedList.Count;\n  if (length % 2 == 0) {\n    return (sortedList[length / 2 - 1] + sortedList[length / 2]) / 2.0;\n  } else {\n    return sortedList[length / 2];\n  }\n}",
  "JavaScript_humaneval-047": "function median(l) {\n  let sortedList = l.sort((a, b) => a - b);\n  let length = sortedList.length;\n  if (length % 2 === 0) {\n    return (sortedList[length / 2 - 1] + sortedList[length / 2]) / 2;\n  } else {\n    return sortedList[Math.floor(length / 2)];\n  }\n}",
  "Go_humaneval-047": "func median(l []int) float64 {\n    sort.Ints(l)\n    length := len(l)\n    if length%2 == 0 {\n        return float64(l[length/2-1]+l[length/2]) / 2\n    } else {\n        return float64(l[length/2])\n    }\n}",
  "PHP_humaneval-047": "function median(array $l): float {\n    sort($l);\n    $length = count($l);\n    if ($length % 2 == 0) {\n        return ($l[$length / 2 - 1] + $l[$length / 2]) / 2;\n    } else {\n        return $l[floor($length / 2)];\n    }\n}",
  "Ruby_humaneval-047": "def median(l)\n  sorted_list = l.sort\n  length = sorted_list.length\n  if length % 2 == 0\n    (sorted_list[length / 2 - 1] + sorted_list[length / 2]) / 2.0\n  else\n    sorted_list[length / 2]\n  end\nend",
  "Swift_humaneval-047": "func median(_ l: [Int]) -> Double {\n  let sortedList = l.sorted()\n  let length = sortedList.count\n  if length % 2 == 0 {\n    return Double(sortedList[length / 2 - 1] + sortedList[length / 2]) / 2\n  } else {\n    return Double(sortedList[length / 2])\n  }\n}",
  "TypeScript_humaneval-047": "function median(l: number[]): number {\n  const sortedList = l.sort((a, b) => a - b);\n  const length = sortedList.length;\n  if (length % 2 === 0) {\n    return (sortedList[length / 2 - 1] + sortedList[length / 2]) / 2;\n  } else {\n    return sortedList[Math.floor(length / 2)];\n  }\n}",
  "Dart_humaneval-047": "double median(List<int> l) {\n  List<int> sortedList = List.from(l)..sort();\n  int length = sortedList.length;\n  if (length % 2 == 0) {\n    return (sortedList[length ~/ 2 - 1] + sortedList[length ~/ 2]) / 2;\n  } else {\n    return sortedList[length ~/ 2].toDouble();\n  }\n}",
  "Rust_humaneval-047": "fn median(l: Vec<i32>) -> f64 {\n    let mut l = l;\n    l.sort();\n    let length = l.len();\n    if length % 2 == 0 {\n        (l[length / 2 - 1] + l[length / 2]) as f64 / 2.0\n    } else {\n        l[length / 2] as f64\n    }\n}",
  "Scala_humaneval-047": "def median(l: List[Int]): Double = {\n  val sortedList = l.sorted\n  val length = sortedList.length\n  if (length % 2 == 0) {\n    (sortedList(length / 2 - 1) + sortedList(length / 2)) / 2.0\n  } else {\n    sortedList(length / 2)\n  }\n}",
  "Kotlin_humaneval-047": "fun median(l: List<Int>): Double {\n  val sortedList = l.sorted()\n  val length = sortedList.size\n  return if (length % 2 == 0) {\n    (sortedList[length / 2 - 1] + sortedList[length / 2]) / 2.0\n  } else {\n    sortedList[length / 2].toDouble()\n  }\n}",
  "C++_humaneval-048": "bool isPalindrome(string text) {\n  return text == string(text.rbegin(), text.rend());\n}",
  "Java_humaneval-048": "public static Boolean isPalindrome(String text) {\n  return text.equals(new StringBuilder(text).reverse().toString());\n}",
  "Python_humaneval-048": "def is_palindrome(text: str) -> bool:\n    return text == text[::-1]",
  "C#_humaneval-048": "public static bool IsPalindrome(string text) {\n  return text == new string(text.Reverse().ToArray());\n}",
  "JavaScript_humaneval-048": "function isPalindrome(text) {\n  return text === text.split(\"\").reverse().join(\"\");\n}",
  "Go_humaneval-048": "func isPalindrome(text string) bool {\n    for i := 0; i < len(text)/2; i++ {\n        if text[i] != text[len(text)-i-1] {\n            return false\n        }\n    }\n    return true\n}",
  "PHP_humaneval-048": "function isPalindrome(string $text): bool {\n    return $text === strrev($text);\n}",
  "Ruby_humaneval-048": "def is_palindrome(text)\n  text == text.reverse\nend",
  "Swift_humaneval-048": "func isPalindrome(_ text: String) -> Bool {\n  return text == String(text.reversed())\n}",
  "TypeScript_humaneval-048": "function isPalindrome(text: string): boolean {\n  return text === text.split(\"\").reverse().join(\"\");\n}",
  "Dart_humaneval-048": "bool isPalindrome(String text) {\n  return text == text.split('').reversed.join();\n}",
  "Rust_humaneval-048": "fn is_palindrome(text: String) -> bool {\n    text == text.chars().rev().collect::<String>()\n}",
  "Scala_humaneval-048": "def isPalindrome(text: String): Boolean = {\n  text == text.reverse\n}",
  "Kotlin_humaneval-048": "fun isPalindrome(text: String): Boolean {\n  return text == text.reversed()\n}",
  "C++_humaneval-049": "int modp(int n, int p) {\n  if (n == 0) {\n    return 1;\n  } else if (n % 2 == 0) {\n    int x = modp(n / 2, p);\n    return (x * x) % p;\n  } else {\n    int y = modp(n - 1, p);\n    return (2 * y) % p;\n  }\n}",
  "Java_humaneval-049": "public static Integer modp(Integer n, Integer p) {\n  if (n == 0) {\n    return 1;\n  } else if (n % 2 == 0) {\n    return (int) Math.pow(modp(n / 2, p), 2) % p;\n  } else {\n    return (2 * modp(n - 1, p)) % p;\n  }\n}",
  "Python_humaneval-049": "def modp(n: int, p: int) -> int:\n    if n == 0:\n        return 1\n    elif n % 2 == 0:\n        return modp(n // 2, p) ** 2 % p\n    else:\n        return 2 * modp(n - 1, p) % p",
  "C#_humaneval-049": "public static int Modp(int n, int p) {\n  if (n == 0) {\n    return 1;\n  } else if (n % 2 == 0) {\n    int temp = Modp(n / 2, p);\n    return (temp * temp) % p;\n  } else {\n    int temp = Modp(n - 1, p);\n    return (2 * temp) % p;\n  }\n}",
  "JavaScript_humaneval-049": "function modp(n, p) {\n  if (n === 0) {\n    return 1;\n  } else if (n % 2 === 0) {\n    return Math.pow(modp(n / 2, p), 2) % p;\n  } else {\n    return (2 * modp(n - 1, p)) % p;\n  }\n}",
  "Go_humaneval-049": "func modp(n int, p int) int {\n    if n == 0 {\n        return 1\n    } else if n%2 == 0 {\n        return int(math.Pow(float64(modp(n/2, p)), 2)) % p\n    } else {\n        return (2 * modp(n-1, p)) % p\n    }\n}",
  "PHP_humaneval-049": "function modp(int $n, int $p): int {\n    if ($n == 0) {\n        return 1;\n    } elseif ($n % 2 == 0) {\n        return (modp($n / 2, $p) ** 2) % $p;\n    } else {\n        return (2 * modp($n - 1, $p)) % $p;\n    }\n}",
  "Ruby_humaneval-049": "def modp(n, p)\n  if n == 0\n    return 1\n  elsif n % 2 == 0\n    return modp(n / 2, p)**2 % p\n  else\n    return 2 * modp(n - 1, p) % p\n  end\nend",
  "Swift_humaneval-049": "func modp(_ n: Int, _ p: Int) -> Int {\n  if n == 0 {\n    return 1\n  } else if n % 2 == 0 {\n    return modp(n / 2, p) * modp(n / 2, p) % p\n  } else {\n    return 2 * modp(n - 1, p) % p\n  }\n}",
  "TypeScript_humaneval-049": "function modp(n: number, p: number): number {\n  if (n === 0) {\n    return 1;\n  } else if (n % 2 === 0) {\n    return Math.pow(modp(n / 2, p), 2) % p;\n  } else {\n    return (2 * modp(n - 1, p)) % p;\n  }\n}",
  "Dart_humaneval-049": "int modp(int n, int p) {\n  if (n == 0) {\n    return 1;\n  } else if (n % 2 == 0) {\n    return pow(modp(n ~/ 2, p), 2) % p as int;\n  } else {\n    return (2 * modp(n - 1, p)) % p;\n  }\n}",
  "Rust_humaneval-049": "fn modp(n: i32, p: i32) -> i32 {\n    if n == 0 {\n        return 1;\n    } else if n % 2 == 0 {\n        let x = modp(n / 2, p);\n        return (x * x) % p;\n    } else {\n        let x = modp(n - 1, p);\n        return (2 * x) % p;\n    }\n}",
  "Scala_humaneval-049": "def modp(n: Int, p: Int): Int = {\n  if (n == 0) {\n    1\n  } else if (n % 2 == 0) {\n    val x = modp(n / 2, p)\n    (x * x) % p\n  } else {\n    (2 * modp(n - 1, p)) % p\n  }\n}",
  "Kotlin_humaneval-049": "fun modp(n: Int, p: Int): Int {\n  return when {\n    n == 0 -> 1\n    n % 2 == 0 -> modp(n / 2, p).let { it * it % p }\n    else -> (2 * modp(n - 1, p) % p)\n  }\n}",
  "C++_humaneval-050": "string encodeShift(string s) {\n  string encoded_chars;\n  for (char ch : s) {\n    if ('a' <= ch && ch <= 'z') {\n      char encoded_char = (((ch - 'a') + 5) % 26) + 'a';\n      encoded_chars += encoded_char;\n    } else {\n      encoded_chars += ch;\n    }\n  }\n  return encoded_chars;\n}",
  "Java_humaneval-050": "public static String encodeShift(String s) {\n  List<Character> encodedChars = new ArrayList<>();\n  for (char ch : s.toCharArray()) {\n    if ('a' <= ch && ch <= 'z') {\n      char encodedChar = (char) (((ch - 'a' + 5) % 26) + 'a');\n      encodedChars.add(encodedChar);\n    } else {\n      encodedChars.add(ch);\n    }\n  }\n  StringBuilder sb = new StringBuilder();\n  for (char ch : encodedChars) {\n    sb.append(ch);\n  }\n  return sb.toString();\n}",
  "Python_humaneval-050": "def encode_shift(s: str) -> str:\n    encoded_chars = []\n    for ch in s:\n        if \"a\" <= ch <= \"z\":\n            encoded_char = chr(((ord(ch) - ord(\"a\") + 5) % 26) + ord(\"a\"))\n        else:\n            encoded_char = ch\n        encoded_chars.append(encoded_char)\n    return \"\".join(encoded_chars)",
  "C#_humaneval-050": "public static string EncodeShift(string s) {\n  List<char> encodedChars = new List<char>();\n  foreach (char ch in s) {\n    if ('a' <= ch && ch <= 'z') {\n      char encodedChar = (char)(((ch - 'a' + 5) % 26) + 'a');\n      encodedChars.Add(encodedChar);\n    } else {\n      encodedChars.Add(ch);\n    }\n  }\n  return new string(encodedChars.ToArray());\n}",
  "JavaScript_humaneval-050": "function encodeShift(s) {\n  let encodedChars = [];\n  for (let i = 0; i < s.length; i++) {\n    let ch = s.charAt(i);\n    if (\"a\" <= ch && ch <= \"z\") {\n      let encodedChar = String.fromCharCode(\n        ((ch.charCodeAt(0) - \"a\".charCodeAt(0) + 5) % 26) + \"a\".charCodeAt(0),\n      );\n      encodedChars.push(encodedChar);\n    } else {\n      encodedChars.push(ch);\n    }\n  }\n  return encodedChars.join(\"\");\n}",
  "Go_humaneval-050": "func encodeShift(s string) string {\n    encodedChars := []byte{}\n    for _, ch := range s {\n        if 'a' <= ch && ch <= 'z' {\n            encodedChar := byte(((ch - 'a' + 5) % 26) + 'a')\n            encodedChars = append(encodedChars, encodedChar)\n        } else {\n            encodedChars = append(encodedChars, byte(ch))\n        }\n    }\n    return string(encodedChars)\n}",
  "PHP_humaneval-050": "function encodeShift(string $s): string {\n    $encoded_chars = [];\n    for ($i = 0; $i < strlen($s); $i++) {\n        $ch = $s[$i];\n        if (\"a\" <= $ch && $ch <= \"z\") {\n            $encoded_char = chr(((ord($ch) - ord(\"a\") + 5) % 26) + ord(\"a\"));\n        } else {\n            $encoded_char = $ch;\n        }\n        $encoded_chars[] = $encoded_char;\n    }\n    return implode(\"\", $encoded_chars);\n}",
  "Ruby_humaneval-050": "def encode_shift(s)\n  encoded_chars = []\n  s.each_char do |ch|\n    if ch >= \"a\" && ch <= \"z\"\n      encoded_char = ((ch.ord - \"a\".ord + 5) % 26 + \"a\".ord).chr\n    else\n      encoded_char = ch\n    end\n    encoded_chars << encoded_char\n  end\n  encoded_chars.join\nend",
  "Swift_humaneval-050": "func encodeShift(_ s: String) -> String {\n  var encodedChars = [Character]()\n  for ch in s {\n    if ch >= \"a\" && ch <= \"z\" {\n      let encodedChar = Character(\n        UnicodeScalar(\n          (ch.asciiValue! - Character(\"a\").asciiValue! + 5) % 26 + Character(\"a\").asciiValue!))\n      encodedChars.append(encodedChar)\n    } else {\n      encodedChars.append(ch)\n    }\n  }\n  return String(encodedChars)\n}",
  "TypeScript_humaneval-050": "function encodeShift(s: string): string {\n  const encodedChars: string[] = [];\n  for (const ch of s) {\n    if (\"a\" <= ch && ch <= \"z\") {\n      const encodedChar = String.fromCharCode(\n        ((ch.charCodeAt(0) - \"a\".charCodeAt(0) + 5) % 26) + \"a\".charCodeAt(0),\n      );\n      encodedChars.push(encodedChar);\n    } else {\n      encodedChars.push(ch);\n    }\n  }\n  return encodedChars.join(\"\");\n}",
  "Dart_humaneval-050": "String encodeShift(String s) {\n  List<String> encodedChars = [];\n  for (var ch in s.runes) {\n    if (ch >= 97 && ch <= 122) {\n      var encodedChar = String.fromCharCode(((ch - 97 + 5) % 26) + 97);\n      encodedChars.add(encodedChar);\n    } else {\n      encodedChars.add(String.fromCharCode(ch));\n    }\n  }\n  return encodedChars.join(\"\");\n}",
  "Rust_humaneval-050": "fn encode_shift(s: String) -> String {\n    let mut encoded_chars = vec![];\n    for ch in s.chars() {\n        if ch >= 'a' && ch <= 'z' {\n            let encoded_char = ((ch as u8 - b'a') + 5) % 26 + b'a';\n            encoded_chars.push(encoded_char as char);\n        } else {\n            encoded_chars.push(ch);\n        }\n    }\n    encoded_chars.iter().collect()\n}",
  "Scala_humaneval-050": "def encodeShift(s: String): String = {\n  val encodedChars = new StringBuilder()\n  for (ch <- s) {\n    val encodedChar = if ('a' <= ch && ch <= 'z') {\n      ((ch - 'a' + 5) % 26 + 'a').toChar\n    } else {\n      ch\n    }\n    encodedChars += encodedChar\n  }\n  encodedChars.toString()\n}",
  "Kotlin_humaneval-050": "fun encodeShift(s: String): String {\n  val encodedChars = mutableListOf<Char>()\n  for (ch in s) {\n    val encodedChar = if (ch in 'a'..'z') {\n      ((ch - 'a' + 5) % 26 + 'a'.toInt()).toChar()\n    } else {\n      ch\n    }\n    encodedChars.add(encodedChar)\n  }\n  return encodedChars.joinToString(\"\")\n}",
  "C++_humaneval-051": "string removeVowels(string text) {\n  string vowels = \"aeiouAEIOU\";\n  string result = \"\";\n  for (char c : text) {\n    if (vowels.find(c) == string::npos) {\n      result += c;\n    }\n  }\n  return result;\n}",
  "Java_humaneval-051": "public static String removeVowels(String text) {\n  String vowels = \"aeiouAEIOU\";\n  StringBuilder result = new StringBuilder();\n  for (char c : text.toCharArray()) {\n    if (vowels.indexOf(c) == -1) {\n      result.append(c);\n    }\n  }\n  return result.toString();\n}",
  "Python_humaneval-051": "def remove_vowels(text: str) -> str:\n    vowels = \"aeiouAEIOU\"\n    return \"\".join([char for char in text if char not in vowels])",
  "C#_humaneval-051": "public static string RemoveVowels(string text) {\n  string vowels = \"aeiouAEIOU\";\n  return new string(text.Where(c => !vowels.Contains(c)).ToArray());\n}",
  "JavaScript_humaneval-051": "function removeVowels(text) {\n  const vowels = \"aeiouAEIOU\";\n  return [...text].filter((char) => !vowels.includes(char)).join(\"\");\n}",
  "Go_humaneval-051": "func removeVowels(text string) string {\n    vowels := \"aeiouAEIOU\"\n    result := \"\"\n    for _, char := range text {\n        if !strings.ContainsRune(vowels, char) {\n            result += string(char)\n        }\n    }\n    return result\n}",
  "PHP_humaneval-051": "function removeVowels(string $text): string {\n    $vowels = \"aeiouAEIOU\";\n    return str_replace(str_split($vowels), \"\", $text);\n}",
  "Ruby_humaneval-051": "def remove_vowels(text)\n  vowels = \"aeiouAEIOU\"\n  text.chars.select { |char| !vowels.include?(char) }.join(\"\")\nend",
  "Swift_humaneval-051": "func removeVowels(_ text: String) -> String {\n  let vowels = \"aeiouAEIOU\"\n  return String(text.filter { !vowels.contains($0) })\n}",
  "TypeScript_humaneval-051": "function removeVowels(text: string): string {\n  const vowels = \"aeiouAEIOU\";\n  return text\n    .split(\"\")\n    .filter((char) => !vowels.includes(char))\n    .join(\"\");\n}",
  "Dart_humaneval-051": "String removeVowels(String text) {\n  var vowels = \"aeiouAEIOU\";\n  return text.split('').where((char) => !vowels.contains(char)).join('');\n}",
  "Rust_humaneval-051": "fn remove_vowels(text: String) -> String {\n    let vowels = \"aeiouAEIOU\";\n    text.chars().filter(|&c| !vowels.contains(c)).collect()\n}",
  "Scala_humaneval-051": "def removeVowels(text: String): String = {\n  val vowels = \"aeiouAEIOU\"\n  text.filterNot(vowels.contains)\n}",
  "Kotlin_humaneval-051": "fun removeVowels(text: String): String {\n  val vowels = \"aeiouAEIOU\"\n  return text.filter { it !in vowels }\n}",
  "C++_humaneval-052": "bool belowThreshold(vector<int> l, int t) {\n  for (int num : l) {\n    if (num >= t) {\n      return false;\n    }\n  }\n  return true;\n}",
  "Java_humaneval-052": "public static Boolean belowThreshold(List<Integer> l, Integer t) {\n  for (Integer num : l) {\n    if (num >= t) {\n      return false;\n    }\n  }\n  return true;\n}",
  "Python_humaneval-052": "def below_threshold(l: List[int], t: int) -> bool:\n    for num in l:\n        if num >= t:\n            return False\n    return True",
  "C#_humaneval-052": "public static bool BelowThreshold(List<int> l, int t) {\n  foreach (int num in l) {\n    if (num >= t) {\n      return false;\n    }\n  }\n  return true;\n}",
  "JavaScript_humaneval-052": "function belowThreshold(l, t) {\n  for (let num of l) {\n    if (num >= t) {\n      return false;\n    }\n  }\n  return true;\n}",
  "Go_humaneval-052": "func belowThreshold(l []int, t int) bool {\n    for _, num := range l {\n        if num >= t {\n            return false\n        }\n    }\n    return true\n}",
  "PHP_humaneval-052": "function belowThreshold(array $l, int $t): bool {\n    foreach ($l as $num) {\n        if ($num >= $t) {\n            return false;\n        }\n    }\n    return true;\n}",
  "Ruby_humaneval-052": "def below_threshold(l, t)\n  l.each { |num| return false if num >= t }\n  true\nend",
  "Swift_humaneval-052": "func belowThreshold(_ l: [Int], _ t: Int) -> Bool {\n  for num in l {\n    if num >= t {\n      return false\n    }\n  }\n  return true\n}",
  "TypeScript_humaneval-052": "function belowThreshold(l: number[], t: number): boolean {\n  for (let num of l) {\n    if (num >= t) {\n      return false;\n    }\n  }\n  return true;\n}",
  "Dart_humaneval-052": "bool belowThreshold(List<int> l, int t) {\n  for (int num in l) {\n    if (num >= t) {\n      return false;\n    }\n  }\n  return true;\n}",
  "Rust_humaneval-052": "fn below_threshold(l: Vec<i32>, t: i32) -> bool {\n    for num in l {\n        if num >= t {\n            return false;\n        }\n    }\n    true\n}",
  "Scala_humaneval-052": "def belowThreshold(l: List[Int], t: Int): Boolean = {\n  for (num <- l) {\n    if (num >= t) {\n      return false\n    }\n  }\n  true\n}",
  "Kotlin_humaneval-052": "fun belowThreshold(l: List<Int>, t: Int): Boolean {\n  for (num in l) {\n    if (num >= t) {\n      return false\n    }\n  }\n  return true\n}",
  "C++_humaneval-053": "int add(int x, int y) { return x + y; }",
  "Java_humaneval-053": "public static Integer add(Integer x, Integer y) {\n  return x + y;\n}",
  "Python_humaneval-053": "def add(x: int, y: int) -> int:\n    return x + y",
  "C#_humaneval-053": "public static int Add(int x, int y) {\n  return x + y;\n}",
  "JavaScript_humaneval-053": "function add(x, y) {\n  return x + y;\n}",
  "Go_humaneval-053": "func add(x int, y int) int {\n    return x + y\n}",
  "PHP_humaneval-053": "function add(int $x, int $y): int {\n    return $x + $y;\n}",
  "Ruby_humaneval-053": "def add(x, y)\n  return x + y\nend",
  "Swift_humaneval-053": "func add(_ x: Int, _ y: Int) -> Int {\n  return x + y\n}",
  "TypeScript_humaneval-053": "function add(x: number, y: number): number {\n  return x + y;\n}",
  "Dart_humaneval-053": "int add(int x, int y) {\n  return x + y;\n}",
  "Rust_humaneval-053": "fn add(x: i32, y: i32) -> i32 {\n    x + y\n}",
  "Scala_humaneval-053": "def add(x: Int, y: Int): Int = {\n  x + y\n}",
  "Kotlin_humaneval-053": "fun add(x: Int, y: Int): Int {\n  return x + y\n}",
  "C++_humaneval-054": "bool sameChars(string s0, string s1) {\n  set<char> set0(s0.begin(), s0.end());\n  set<char> set1(s1.begin(), s1.end());\n  return set0 == set1;\n}",
  "Java_humaneval-054": "public static Boolean sameChars(String s0, String s1) {\n  Set<Character> set0 = new HashSet<>();\n  Set<Character> set1 = new HashSet<>();\n  for (char c : s0.toCharArray()) {\n    set0.add(c);\n  }\n  for (char c : s1.toCharArray()) {\n    set1.add(c);\n  }\n  return set0.equals(set1);\n}",
  "Python_humaneval-054": "def same_chars(s0: str, s1: str) -> bool:\n    set0 = set(s0)\n    set1 = set(s1)\n    return set0 == set1",
  "C#_humaneval-054": "public static bool SameChars(string s0, string s1) {\n  HashSet<char> set0 = new HashSet<char>(s0);\n  HashSet<char> set1 = new HashSet<char>(s1);\n  return set0.SetEquals(set1);\n}",
  "JavaScript_humaneval-054": "function sameChars(s0, s1) {\n  const set0 = new Set(s0);\n  const set1 = new Set(s1);\n  return (\n    JSON.stringify(Array.from(set0).sort()) ===\n    JSON.stringify(Array.from(set1).sort())\n  );\n}",
  "Go_humaneval-054": "func sameChars(s0 string, s1 string) bool {\n    set0 := make(map[rune]bool)\n    for _, r := range s0 {\n        set0[r] = true\n    }\n    set1 := make(map[rune]bool)\n    for _, r := range s1 {\n        set1[r] = true\n    }\n    return reflect.DeepEqual(set0, set1)\n}",
  "PHP_humaneval-054": "function sameChars(string $s0, string $s1): bool {\n    $set0 = array_unique(str_split($s0));\n    $set1 = array_unique(str_split($s1));\n    sort($set0);\n    sort($set1);\n    return $set0 === $set1;\n}",
  "Ruby_humaneval-054": "def same_chars(s0, s1)\n  set0 = s0.chars.to_set\n  set1 = s1.chars.to_set\n  set0 == set1\nend",
  "Swift_humaneval-054": "func sameChars(_ s0: String, _ s1: String) -> Bool {\n  let set0 = Set(s0)\n  let set1 = Set(s1)\n  return set0 == set1\n}",
  "TypeScript_humaneval-054": "function sameChars(s0: string, s1: string): boolean {\n  const set0 = new Set(s0);\n  const set1 = new Set(s1);\n  return (\n    JSON.stringify(Array.from(set0).sort()) ===\n    JSON.stringify(Array.from(set1).sort())\n  );\n}",
  "Dart_humaneval-054": "bool sameChars(String s0, String s1) {\n  Set set0 = s0.split(\"\").toSet();\n  Set set1 = s1.split(\"\").toSet();\n  return set0.containsAll(set1) && set0.length == set1.length;\n}",
  "Rust_humaneval-054": "fn same_chars(s0: String, s1: String) -> bool {\n    let set0: HashSet<char> = s0.chars().collect();\n    let set1: HashSet<char> = s1.chars().collect();\n    set0 == set1\n}",
  "Scala_humaneval-054": "def sameChars(s0: String, s1: String): Boolean = {\n  val set0 = s0.toSet\n  val set1 = s1.toSet\n  set0 == set1\n}",
  "Kotlin_humaneval-054": "fun sameChars(s0: String, s1: String): Boolean {\n  val set0 = s0.toSet()\n  val set1 = s1.toSet()\n  return set0 == set1\n}",
  "C++_humaneval-055": "int fib(int n) {\n  if (n <= 1) {\n    return n;\n  } else {\n    return fib(n - 1) + fib(n - 2);\n  }\n}",
  "Java_humaneval-055": "public static Integer fib(Integer n) {\n  if (n <= 1) {\n    return n;\n  } else {\n    return fib(n - 1) + fib(n - 2);\n  }\n}",
  "Python_humaneval-055": "def fib(n: int) -> int:\n    if n <= 1:\n        return n\n    else:\n        return fib(n - 1) + fib(n - 2)",
  "C#_humaneval-055": "public static int Fib(int n) {\n  if (n <= 1) {\n    return n;\n  } else {\n    return Fib(n - 1) + Fib(n - 2);\n  }\n}",
  "JavaScript_humaneval-055": "function fib(n) {\n  if (n <= 1) {\n    return n;\n  } else {\n    return fib(n - 1) + fib(n - 2);\n  }\n}",
  "Go_humaneval-055": "func fib(n int) int {\n    if n <= 1 {\n        return n\n    } else {\n        return fib(n-1) + fib(n-2)\n    }\n}",
  "PHP_humaneval-055": "function fib(int $n): int {\n    if ($n <= 1) {\n        return $n;\n    } else {\n        return fib($n - 1) + fib($n - 2);\n    }\n}",
  "Ruby_humaneval-055": "def fib(n)\n  if n <= 1\n    return n\n  else\n    return fib(n - 1) + fib(n - 2)\n  end\nend",
  "Swift_humaneval-055": "func fib(_ n: Int) -> Int {\n  if n <= 1 {\n    return n\n  } else {\n    return fib(n - 1) + fib(n - 2)\n  }\n}",
  "TypeScript_humaneval-055": "function fib(n: number): number {\n  if (n <= 1) {\n    return n;\n  } else {\n    return fib(n - 1) + fib(n - 2);\n  }\n}",
  "Dart_humaneval-055": "int fib(int n) {\n  if (n <= 1) {\n    return n;\n  } else {\n    return fib(n - 1) + fib(n - 2);\n  }\n}",
  "Rust_humaneval-055": "fn fib(n: i32) -> i32 {\n    if n <= 1 {\n        n\n    } else {\n        fib(n - 1) + fib(n - 2)\n    }\n}",
  "Scala_humaneval-055": "def fib(n: Int): Int = {\n  if (n <= 1) n\n  else fib(n - 1) + fib(n - 2)\n}",
  "Kotlin_humaneval-055": "fun fib(n: Int): Int {\n  return if (n <= 1) n else fib(n - 1) + fib(n - 2)\n}",
  "C++_humaneval-056": "bool correctBracketing(string brackets) {\n  stack<char> s;\n  for (char bracket : brackets) {\n    if (bracket == '<') {\n      s.push(bracket);\n    } else if (bracket == '>') {\n      if (s.empty()) {\n        return false;\n      }\n      s.pop();\n    }\n  }\n  return s.empty();\n}",
  "Java_humaneval-056": "public static Boolean correctBracketing(String brackets) {\n  Stack<Character> stack = new Stack<>();\n  for (char bracket : brackets.toCharArray()) {\n    if (bracket == '<') {\n      stack.push(bracket);\n    } else if (bracket == '>') {\n      if (stack.empty()) {\n        return false;\n      }\n      stack.pop();\n    }\n  }\n  return stack.empty();\n}",
  "Python_humaneval-056": "def correct_bracketing(brackets: str) -> bool:\n    stack = []\n    for bracket in brackets:\n        if bracket == \"<\":\n            stack.append(bracket)\n        elif bracket == \">\":\n            if not stack:\n                return False\n            stack.pop()\n    return not stack",
  "C#_humaneval-056": "public static bool CorrectBracketing(string brackets) {\n  Stack<char> stack = new Stack<char>();\n  foreach (char bracket in brackets) {\n    if (bracket == '<') {\n      stack.Push(bracket);\n    } else if (bracket == '>') {\n      if (stack.Count == 0) {\n        return false;\n      }\n      stack.Pop();\n    }\n  }\n  return stack.Count == 0;\n}",
  "JavaScript_humaneval-056": "function correctBracketing(brackets) {\n  let stack = [];\n  for (let bracket of brackets) {\n    if (bracket === \"<\") {\n      stack.push(bracket);\n    } else if (bracket === \">\") {\n      if (!stack.length) {\n        return false;\n      }\n      stack.pop();\n    }\n  }\n  return !stack.length;\n}",
  "Go_humaneval-056": "func correctBracketing(brackets string) bool {\n    stack := []rune{}\n    for _, bracket := range brackets {\n        if bracket == '<' {\n            stack = append(stack, bracket)\n        } else if bracket == '>' {\n            if len(stack) == 0 {\n                return false\n            }\n            stack = stack[:len(stack)-1]\n        }\n    }\n    return len(stack) == 0\n}",
  "PHP_humaneval-056": "function correctBracketing(string $brackets): bool {\n    $stack = [];\n    for ($i = 0; $i < strlen($brackets); $i++) {\n        $bracket = $brackets[$i];\n        if ($bracket == \"<\") {\n            array_push($stack, $bracket);\n        } elseif ($bracket == \">\") {\n            if (empty($stack)) {\n                return false;\n            }\n            array_pop($stack);\n        }\n    }\n    return empty($stack);\n}",
  "Ruby_humaneval-056": "def correct_bracketing(brackets)\n  stack = []\n  brackets.each_char do |bracket|\n    if bracket == \"<\"\n      stack.push(bracket)\n    elsif bracket == \">\"\n      return false if stack.empty?\n      stack.pop\n    end\n  end\n  stack.empty?\nend",
  "Swift_humaneval-056": "func correctBracketing(_ brackets: String) -> Bool {\n  var stack = [Character]()\n  for bracket in brackets {\n    if bracket == \"<\" {\n      stack.append(bracket)\n    } else if bracket == \">\" {\n      if stack.isEmpty {\n        return false\n      }\n      stack.popLast()\n    }\n  }\n  return stack.isEmpty\n}",
  "TypeScript_humaneval-056": "function correctBracketing(brackets: string): boolean {\n  const stack: string[] = [];\n  for (const bracket of brackets) {\n    if (bracket === \"<\") {\n      stack.push(bracket);\n    } else if (bracket === \">\") {\n      if (!stack.length) {\n        return false;\n      }\n      stack.pop();\n    }\n  }\n  return !stack.length;\n}",
  "Dart_humaneval-056": "bool correctBracketing(String brackets) {\n  var stack = [];\n  for (var bracket in brackets.split('')) {\n    if (bracket == \"<\") {\n      stack.add(bracket);\n    } else if (bracket == \">\") {\n      if (stack.isEmpty) {\n        return false;\n      }\n      stack.removeLast();\n    }\n  }\n  return stack.isEmpty;\n}",
  "Rust_humaneval-056": "fn correct_bracketing(brackets: String) -> bool {\n    let mut stack = vec![];\n    for bracket in brackets.chars() {\n        if bracket == '<' {\n            stack.push(bracket);\n        } else if bracket == '>' {\n            if stack.is_empty() {\n                return false;\n            }\n            stack.pop();\n        }\n    }\n    stack.is_empty()\n}",
  "Scala_humaneval-056": "def correctBracketing(brackets: String): Boolean = {\n  var stack = List[Char]()\n  for (bracket <- brackets) {\n    if (bracket == '<') {\n      stack = '<' :: stack\n    } else if (bracket == '>') {\n      if (stack.isEmpty) {\n        return false\n      }\n      stack = stack.tail\n    }\n  }\n  stack.isEmpty\n}",
  "Kotlin_humaneval-056": "fun correctBracketing(brackets: String): Boolean {\n  val stack = mutableListOf<Char>()\n  for (bracket in brackets) {\n    if (bracket == '<') {\n      stack.add(bracket)\n    } else if (bracket == '>') {\n      if (stack.isEmpty()) {\n        return false\n      }\n      stack.removeAt(stack.lastIndex)\n    }\n  }\n  return stack.isEmpty()\n}",
  "C++_humaneval-057": "bool monotonic(vector<int> l) {\n  bool increasing = true, decreasing = true;\n  for (int i = 0; i < l.size() - 1; i++) {\n    if (l[i] > l[i + 1]) {\n      increasing = false;\n    } else if (l[i] < l[i + 1]) {\n      decreasing = false;\n    }\n  }\n  return increasing || decreasing;\n}",
  "Java_humaneval-057": "public static Boolean monotonic(List<Integer> l) {\n  boolean increasing = true;\n  boolean decreasing = true;\n  for (int i = 0; i < l.size() - 1; i++) {\n    if (l.get(i) > l.get(i + 1)) {\n      increasing = false;\n    } else if (l.get(i) < l.get(i + 1)) {\n      decreasing = false;\n    }\n  }\n  return increasing || decreasing;\n}",
  "Python_humaneval-057": "def monotonic(l: List[int]) -> bool:\n    increasing = decreasing = True\n    for i in range(len(l) - 1):\n        if l[i] > l[i + 1]:\n            increasing = False\n        elif l[i] < l[i + 1]:\n            decreasing = False\n    return increasing or decreasing",
  "C#_humaneval-057": "public static bool Monotonic(List<int> l) {\n  bool increasing = true;\n  bool decreasing = true;\n  for (int i = 0; i < l.Count - 1; i++) {\n    if (l[i] > l[i + 1]) {\n      increasing = false;\n    } else if (l[i] < l[i + 1]) {\n      decreasing = false;\n    }\n  }\n  return increasing || decreasing;\n}",
  "JavaScript_humaneval-057": "function monotonic(l) {\n  let increasing = (decreasing = true);\n  for (let i = 0; i < l.length - 1; i++) {\n    if (l[i] > l[i + 1]) {\n      increasing = false;\n    } else if (l[i] < l[i + 1]) {\n      decreasing = false;\n    }\n  }\n  return increasing || decreasing;\n}",
  "Go_humaneval-057": "func monotonic(l []int) bool {\n    increasing, decreasing := true, true\n    for i := 0; i < len(l)-1; i++ {\n        if l[i] > l[i+1] {\n            increasing = false\n        } else if l[i] < l[i+1] {\n            decreasing = false\n        }\n    }\n    return increasing || decreasing\n}",
  "PHP_humaneval-057": "function monotonic(array $l): bool {\n    $increasing = $decreasing = true;\n    for ($i = 0; $i < count($l) - 1; $i++) {\n        if ($l[$i] > $l[$i + 1]) {\n            $increasing = false;\n        } elseif ($l[$i] < $l[$i + 1]) {\n            $decreasing = false;\n        }\n    }\n    return $increasing || $decreasing;\n}",
  "Ruby_humaneval-057": "def monotonic(l)\n  increasing = decreasing = true\n  (l.length - 1).times do |i|\n    if l[i] > l[i + 1]\n      increasing = false\n    elsif l[i] < l[i + 1]\n      decreasing = false\n    end\n  end\n  increasing || decreasing\nend",
  "Swift_humaneval-057": "func monotonic(_ l: [Int]) -> Bool {\n  var increasing = true\n  var decreasing = true\n  for i in 0..<l.count - 1 {\n    if l[i] > l[i + 1] {\n      increasing = false\n    } else if l[i] < l[i + 1] {\n      decreasing = false\n    }\n  }\n  return increasing || decreasing\n}",
  "TypeScript_humaneval-057": "function monotonic(l: number[]): boolean {\n  let increasing = true;\n  let decreasing = true;\n  for (let i = 0; i < l.length - 1; i++) {\n    if (l[i] > l[i + 1]) {\n      increasing = false;\n    } else if (l[i] < l[i + 1]) {\n      decreasing = false;\n    }\n  }\n  return increasing || decreasing;\n}",
  "Dart_humaneval-057": "bool monotonic(List<int> l) {\n  bool increasing = true;\n  bool decreasing = true;\n  for (int i = 0; i < l.length - 1; i++) {\n    if (l[i] > l[i + 1]) {\n      increasing = false;\n    } else if (l[i] < l[i + 1]) {\n      decreasing = false;\n    }\n  }\n  return increasing || decreasing;\n}",
  "Rust_humaneval-057": "fn monotonic(l: Vec<i32>) -> bool {\n    let mut increasing = true;\n    let mut decreasing = true;\n    for i in 0..l.len() - 1 {\n        if l[i] > l[i + 1] {\n            increasing = false;\n        } else if l[i] < l[i + 1] {\n            decreasing = false;\n        }\n    }\n    increasing || decreasing\n}",
  "Scala_humaneval-057": "def monotonic(l: List[Int]): Boolean = {\n  var increasing = true\n  var decreasing = true\n  for (i <- 0 until l.length - 1) {\n    if (l(i) > l(i + 1)) {\n      increasing = false\n    } else if (l(i) < l(i + 1)) {\n      decreasing = false\n    }\n  }\n  increasing || decreasing\n}",
  "Kotlin_humaneval-057": "fun monotonic(l: List<Int>): Boolean {\n  var increasing = true\n  var decreasing = true\n  for (i in 0 until l.size - 1) {\n    if (l[i] > l[i + 1]) {\n      increasing = false\n    } else if (l[i] < l[i + 1]) {\n      decreasing = false\n    }\n  }\n  return increasing || decreasing\n}",
  "C++_humaneval-058": "vector<int> common(vector<int> l1, vector<int> l2) {\n  vector<int> common_elements;\n  sort(l1.begin(), l1.end());\n  sort(l2.begin(), l2.end());\n  set_intersection(l1.begin(), l1.end(), l2.begin(), l2.end(),\n                   back_inserter(common_elements));\n  return common_elements;\n}",
  "Java_humaneval-058": "public static List<Integer> common(List<Integer> l1, List<Integer> l2) {\n  List<Integer> commonElements = new ArrayList<>(new HashSet<>(l1));\n  commonElements.retainAll(new HashSet<>(l2));\n  Collections.sort(commonElements);\n  return commonElements;\n}",
  "Python_humaneval-058": "def common(l1: List[int], l2: List[int]) -> List[int]:\n    common_elements = list(set(l1) & set(l2))\n    return sorted(common_elements)",
  "C#_humaneval-058": "public static List<int> Common(List<int> l1, List<int> l2) {\n  List<int> commonElements = l1.Intersect(l2).ToList();\n  commonElements.Sort();\n  return commonElements;\n}",
  "JavaScript_humaneval-058": "function common(l1, l2) {\n  const commonElements = l1.filter((value) => l2.includes(value));\n  return commonElements.sort();\n}",
  "Go_humaneval-058": "func common(l1 []int, l2 []int) []int {\n    commonElements := make([]int, 0)\n    for _, num1 := range l1 {\n        for _, num2 := range l2 {\n            if num1 == num2 {\n                commonElements = append(commonElements, num1)\n                break\n            }\n        }\n    }\n    sort.Ints(commonElements)\n    return commonElements\n}",
  "PHP_humaneval-058": "function common(array $l1, array $l2): array {\n    $common_elements = array_intersect($l1, $l2);\n    sort($common_elements);\n    return $common_elements;\n}",
  "Ruby_humaneval-058": "def common(l1, l2)\n  common_elements = l1 & l2\n  common_elements.sort\nend",
  "Swift_humaneval-058": "func common(_ l1: [Int], _ l2: [Int]) -> [Int] {\n  let commonElements = Array(Set(l1).intersection(Set(l2)))\n  return commonElements.sorted()\n}",
  "TypeScript_humaneval-058": "function common(l1: number[], l2: number[]): number[] {\n  const commonElements = [...new Set(l1.filter((x) => l2.includes(x)))];\n  return commonElements.sort();\n}",
  "Dart_humaneval-058": "List<int> common(List<int> l1, List<int> l2) {\n  List<int> commonElements = l1.toSet().intersection(l2.toSet()).toList();\n  return commonElements..sort();\n}",
  "Rust_humaneval-058": "fn common(l1: Vec<i32>, l2: Vec<i32>) -> Vec<i32> {\n    let mut common_elements: Vec<i32> = l1.into_iter().filter(|x| l2.contains(x)).collect();\n    common_elements.sort();\n    common_elements.dedup();\n    return common_elements;\n}",
  "Scala_humaneval-058": "def common(l1: List[Int], l2: List[Int]): List[Int] = {\n  val commonElements = l1.toSet.intersect(l2.toSet)\n  commonElements.toList.sorted\n}",
  "Kotlin_humaneval-058": "fun common(l1: List<Int>, l2: List<Int>): List<Int> {\n  val commonElements = (l1 intersect l2).sorted()\n  return commonElements\n}",
  "C++_humaneval-059": "int largestPrimeFactor(int n) {\n  int i = 2;\n  while (i * i <= n) {\n    if (n % i) {\n      i++;\n    } else {\n      n /= i;\n    }\n  }\n  return n;\n}",
  "Java_humaneval-059": "public static Integer largestPrimeFactor(Integer n) {\n  int i = 2;\n  while (i * i <= n) {\n    if (n % i != 0) {\n      i++;\n    } else {\n      n /= i;\n    }\n  }\n  return n;\n}",
  "Python_humaneval-059": "def largest_prime_factor(n: int) -> int:\n    i = 2\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n    return n",
  "C#_humaneval-059": "public static int LargestPrimeFactor(int n) {\n  int i = 2;\n  while (i * i <= n) {\n    if (n % i != 0) {\n      i++;\n    } else {\n      n /= i;\n    }\n  }\n  return n;\n}",
  "JavaScript_humaneval-059": "function largestPrimeFactor(n) {\n  let i = 2;\n  while (i * i <= n) {\n    if (n % i) {\n      i++;\n    } else {\n      n /= i;\n    }\n  }\n  return n;\n}",
  "Go_humaneval-059": "func largestPrimeFactor(n int) int {\n    i := 2\n    for i*i <= n {\n        if n%i != 0 {\n            i++\n        } else {\n            n /= i\n        }\n    }\n    return n\n}",
  "PHP_humaneval-059": "function largestPrimeFactor(int $n): int {\n    $i = 2;\n    while ($i * $i <= $n) {\n        if ($n % $i) {\n            $i++;\n        } else {\n            $n /= $i;\n        }\n    }\n    return $n;\n}",
  "Ruby_humaneval-059": "def largest_prime_factor(n)\n  i = 2\n  while i * i <= n\n    if n % i != 0\n      i += 1\n    else\n      n /= i\n    end\n  end\n  n\nend",
  "Swift_humaneval-059": "func largestPrimeFactor(_ n: Int) -> Int {\n  var i = 2\n  var num = n\n  while i * i <= num {\n    if num % i != 0 {\n      i += 1\n    } else {\n      num /= i\n    }\n  }\n  return num\n}",
  "TypeScript_humaneval-059": "function largestPrimeFactor(n: number): number {\n  let i = 2;\n  while (i * i <= n) {\n    if (n % i) {\n      i++;\n    } else {\n      n /= i;\n    }\n  }\n  return n;\n}",
  "Dart_humaneval-059": "int largestPrimeFactor(int n) {\n  int i = 2;\n  while (i * i <= n) {\n    if (n % i != 0) {\n      i++;\n    } else {\n      n ~/= i;\n    }\n  }\n  return n;\n}",
  "Rust_humaneval-059": "fn largest_prime_factor(n: i32) -> i32 {\n    let mut i = 2;\n    let mut num = n;\n    while i * i <= num {\n        if num % i == 0 {\n            num /= i;\n        } else {\n            i += 1;\n        }\n    }\n    num\n}",
  "Scala_humaneval-059": "def largestPrimeFactor(n: Int): Int = {\n  var i = 2\n  var num = n\n  while (i * i <= num) {\n    if (num % i != 0) {\n      i += 1\n    } else {\n      num /= i\n    }\n  }\n  num\n}",
  "Kotlin_humaneval-059": "fun largestPrimeFactor(n: Int): Int {\n  var i = 2\n  var num = n\n  while (i * i <= num) {\n    if (num % i != 0) {\n      i++\n    } else {\n      num /= i\n    }\n  }\n  return num\n}",
  "C++_humaneval-060": "int sumToN(int n) {\n  int sum = 0;\n  for (int i = 0; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n}",
  "Java_humaneval-060": "public static Integer sumToN(Integer n) {\n  return IntStream.rangeClosed(0, n).sum();\n}",
  "Python_humaneval-060": "def sum_to_n(n: int) -> int:\n    return sum(range(n + 1))",
  "C#_humaneval-060": "public static int SumToN(int n) {\n  return Enumerable.Range(0, n + 1).Sum();\n}",
  "JavaScript_humaneval-060": "function sumToN(n) {\n  return [...Array(n + 1).keys()].reduce((a, b) => a + b);\n}",
  "Go_humaneval-060": "func sumToN(n int) int {\n    sum := 0\n    for i := 0; i <= n; i++ {\n        sum += i\n    }\n    return sum\n}",
  "PHP_humaneval-060": "function sumToN(int $n): int {\n    return array_sum(range(0, $n));\n}",
  "Ruby_humaneval-060": "def sum_to_n(n)\n  (0..n).sum\nend",
  "Swift_humaneval-060": "func sumToN(_ n: Int) -> Int {\n  return (0...n).reduce(0, +)\n}",
  "TypeScript_humaneval-060": "function sumToN(n: number): number {\n  return Array.from({ length: n + 1 }, (_, i) => i).reduce((a, b) => a + b, 0);\n}",
  "Dart_humaneval-060": "int sumToN(int n) {\n  return Iterable<int>.generate(n + 1).reduce((a, b) => a + b);\n}",
  "Rust_humaneval-060": "fn sum_to_n(n: i32) -> i32 {\n    (0..=n).sum()\n}",
  "Scala_humaneval-060": "def sumToN(n: Int): Int = {\n  (0 to n).sum\n}",
  "Kotlin_humaneval-060": "fun sumToN(n: Int): Int {\n  return (0..n).sum()\n}",
  "C++_humaneval-061": "bool correctBracketing(string brackets) {\n  int depth = 0;\n  for (char bracket : brackets) {\n    if (bracket == '(') {\n      depth++;\n    } else if (bracket == ')') {\n      depth--;\n    }\n    if (depth < 0) {\n      return false;\n    }\n  }\n  return depth == 0;\n}",
  "Java_humaneval-061": "public static Boolean correctBracketing(String brackets) {\n  int depth = 0;\n  for (char bracket : brackets.toCharArray()) {\n    if (bracket == '(') {\n      depth++;\n    } else if (bracket == ')') {\n      depth--;\n    }\n    if (depth < 0) {\n      return false;\n    }\n  }\n  return depth == 0;\n}",
  "Python_humaneval-061": "def correct_bracketing(brackets: str) -> bool:\n    depth = 0\n    for bracket in brackets:\n        if bracket == \"(\":\n            depth += 1\n        elif bracket == \")\":\n            depth -= 1\n        if depth < 0:\n            return False\n    return depth == 0",
  "C#_humaneval-061": "public static bool CorrectBracketing(string brackets) {\n  int depth = 0;\n  foreach (char bracket in brackets) {\n    if (bracket == '(') {\n      depth++;\n    } else if (bracket == ')') {\n      depth--;\n    }\n    if (depth < 0) {\n      return false;\n    }\n  }\n  return depth == 0;\n}",
  "JavaScript_humaneval-061": "function correctBracketing(brackets) {\n  let depth = 0;\n  for (let i = 0; i < brackets.length; i++) {\n    if (brackets[i] === \"(\") {\n      depth += 1;\n    } else if (brackets[i] === \")\") {\n      depth -= 1;\n    }\n    if (depth < 0) {\n      return false;\n    }\n  }\n  return depth === 0;\n}",
  "Go_humaneval-061": "func correctBracketing(brackets string) bool {\n    depth := 0\n    for _, bracket := range brackets {\n        if bracket == '(' {\n            depth++\n        } else if bracket == ')' {\n            depth--\n        }\n        if depth < 0 {\n            return false\n        }\n    }\n    return depth == 0\n}",
  "PHP_humaneval-061": "function correctBracketing(string $brackets): bool {\n    $depth = 0;\n    for ($i = 0; $i < strlen($brackets); $i++) {\n        $bracket = $brackets[$i];\n        if ($bracket == \"(\") {\n            $depth += 1;\n        } elseif ($bracket == \")\") {\n            $depth -= 1;\n        }\n        if ($depth < 0) {\n            return false;\n        }\n    }\n    return $depth == 0;\n}",
  "Ruby_humaneval-061": "def correct_bracketing(brackets)\n  depth = 0\n  brackets.each_char do |bracket|\n    if bracket == \"(\"\n      depth += 1\n    elsif bracket == \")\"\n      depth -= 1\n    end\n    return false if depth < 0\n  end\n  depth == 0\nend",
  "Swift_humaneval-061": "func correctBracketing(_ brackets: String) -> Bool {\n  var depth = 0\n  for bracket in brackets {\n    if bracket == \"(\" {\n      depth += 1\n    } else if bracket == \")\" {\n      depth -= 1\n    }\n    if depth < 0 {\n      return false\n    }\n  }\n  return depth == 0\n}",
  "TypeScript_humaneval-061": "function correctBracketing(brackets: string): boolean {\n  let depth = 0;\n  for (const bracket of brackets) {\n    if (bracket === \"(\") {\n      depth += 1;\n    } else if (bracket === \")\") {\n      depth -= 1;\n    }\n    if (depth < 0) {\n      return false;\n    }\n  }\n  return depth === 0;\n}",
  "Dart_humaneval-061": "bool correctBracketing(String brackets) {\n  int depth = 0;\n  for (var bracket in brackets.split('')) {\n    if (bracket == '(') {\n      depth++;\n    } else if (bracket == ')') {\n      depth--;\n    }\n    if (depth < 0) {\n      return false;\n    }\n  }\n  return depth == 0;\n}",
  "Rust_humaneval-061": "fn correct_bracketing(brackets: String) -> bool {\n    let mut depth = 0;\n    for bracket in brackets.chars() {\n        if bracket == '(' {\n            depth += 1;\n        } else if bracket == ')' {\n            depth -= 1;\n        }\n        if depth < 0 {\n            return false;\n        }\n    }\n    return depth == 0;\n}",
  "Scala_humaneval-061": "def correctBracketing(brackets: String): Boolean = {\n  var depth = 0\n  for (bracket <- brackets) {\n    if (bracket == '(') {\n      depth += 1\n    } else if (bracket == ')') {\n      depth -= 1\n    }\n    if (depth < 0) {\n      return false\n    }\n  }\n  depth == 0\n}",
  "Kotlin_humaneval-061": "fun correctBracketing(brackets: String): Boolean {\n  var depth = 0\n  for (bracket in brackets) {\n    when (bracket) {\n      '(' -> depth++\n      ')' -> depth--\n    }\n    if (depth < 0) {\n      return false\n    }\n  }\n  return depth == 0\n}",
  "C++_humaneval-062": "vector<int> derivative(vector<int> xs) {\n  vector<int> result;\n  for (int i = 1; i < xs.size(); i++) {\n    result.push_back(xs[i] * i);\n  }\n  return result;\n}",
  "Java_humaneval-062": "public static List<Integer> derivative(List<Integer> xs) {\n  List<Integer> result = new ArrayList<>();\n  for (int i = 1; i < xs.size(); i++) {\n    result.add(xs.get(i) * i);\n  }\n  return result;\n}",
  "Python_humaneval-062": "def derivative(xs: List[int]) -> List[int]:\n    return [xs[i] * i for i in range(1, len(xs))]",
  "C#_humaneval-062": "public static List<int> Derivative(List<int> xs) {\n  List<int> result = new List<int>();\n  for (int i = 1; i < xs.Count; i++) {\n    result.Add(xs[i] * i);\n  }\n  return result;\n}",
  "JavaScript_humaneval-062": "function derivative(xs) {\n  return xs.slice(1).map((x, i) => x * (i + 1));\n}",
  "Go_humaneval-062": "func derivative(xs []int) []int {\n    result := make([]int, len(xs)-1)\n    for i := 1; i < len(xs); i++ {\n        result[i-1] = xs[i] * i\n    }\n    return result\n}",
  "PHP_humaneval-062": "function derivative(array $xs): array {\n    $result = array();\n    for ($i = 1; $i < count($xs); $i++) {\n        $result[] = $xs[$i] * $i;\n    }\n    return $result;\n}",
  "Ruby_humaneval-062": "def derivative(xs)\n  (1...xs.length).map { |i| xs[i] * i }\nend",
  "Swift_humaneval-062": "func derivative(_ xs: [Int]) -> [Int] {\n  return (1..<xs.count).map { xs[$0] * $0 }\n}",
  "TypeScript_humaneval-062": "function derivative(xs: number[]): number[] {\n  return xs.slice(1).map((x, i) => x * (i + 1));\n}",
  "Dart_humaneval-062": "List<int> derivative(List<int> xs) {\n  return [for (var i = 1; i < xs.length; i++) xs[i] * i];\n}",
  "Rust_humaneval-062": "fn derivative(xs: Vec<i32>) -> Vec<i32> {\n    (1..xs.len()).map(|i| xs[i] * i as i32).collect()\n}",
  "Scala_humaneval-062": "def derivative(xs: List[Int]): List[Int] = {\n  (1 until xs.length).map(i => xs(i) * i).toList\n}",
  "Kotlin_humaneval-062": "fun derivative(xs: List<Int>): List<Int> {\n  return (1 until xs.size).map { i -> xs[i] * i }\n}",
  "C++_humaneval-063": "int fibfib(int n) {\n  if (n == 0) {\n    return 0;\n  } else if (n == 1) {\n    return 0;\n  } else if (n == 2) {\n    return 1;\n  } else {\n    int a = 0, b = 0, c = 1;\n    for (int i = 2; i < n; i++) {\n      int temp = a + b + c;\n      a = b;\n      b = c;\n      c = temp;\n    }\n    return c;\n  }\n}",
  "Java_humaneval-063": "public static Integer fibfib(Integer n) {\n  if (n == 0) {\n    return 0;\n  } else if (n == 1) {\n    return 0;\n  } else if (n == 2) {\n    return 1;\n  } else {\n    int a = 0, b = 0, c = 1;\n    for (int i = 2; i < n; i++) {\n      int temp = a + b + c;\n      a = b;\n      b = c;\n      c = temp;\n    }\n    return c;\n  }\n}",
  "Python_humaneval-063": "def fibfib(n: int) -> int:\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 0\n    elif n == 2:\n        return 1\n    else:\n        a, b, c = 0, 0, 1\n        for i in range(2, n):\n            a, b, c = b, c, a + b + c\n        return c",
  "C#_humaneval-063": "public static int Fibfib(int n) {\n  if (n == 0) {\n    return 0;\n  } else if (n == 1) {\n    return 0;\n  } else if (n == 2) {\n    return 1;\n  } else {\n    int a = 0, b = 0, c = 1;\n    for (int i = 2; i < n; i++) {\n      int temp = a + b + c;\n      a = b;\n      b = c;\n      c = temp;\n    }\n    return c;\n  }\n}",
  "JavaScript_humaneval-063": "function fibfib(n) {\n  if (n === 0) {\n    return 0;\n  } else if (n === 1) {\n    return 0;\n  } else if (n === 2) {\n    return 1;\n  } else {\n    let a = 0;\n    let b = 0;\n    let c = 1;\n    for (let i = 2; i < n; i++) {\n      [a, b, c] = [b, c, a + b + c];\n    }\n    return c;\n  }\n}",
  "Go_humaneval-063": "func fibfib(n int) int {\n    if n == 0 {\n        return 0\n    } else if n == 1 {\n        return 0\n    } else if n == 2 {\n        return 1\n    } else {\n        a, b, c := 0, 0, 1\n        for i := 2; i < n; i++ {\n            a, b, c = b, c, a+b+c\n        }\n        return c\n    }\n}",
  "PHP_humaneval-063": "function fibfib(int $n): int {\n    if ($n == 0) {\n        return 0;\n    } elseif ($n == 1) {\n        return 0;\n    } elseif ($n == 2) {\n        return 1;\n    } else {\n        $a = 0;\n        $b = 0;\n        $c = 1;\n        for ($i = 2; $i < $n; $i++) {\n            list($a, $b, $c) = [$b, $c, $a + $b + $c];\n        }\n        return $c;\n    }\n}",
  "Ruby_humaneval-063": "def fibfib(n)\n  if n == 0\n    return 0\n  elsif n == 1\n    return 0\n  elsif n == 2\n    return 1\n  else\n    a, b, c = 0, 0, 1\n    for i in 2...n\n      a, b, c = b, c, a + b + c\n    end\n    return c\n  end\nend",
  "Swift_humaneval-063": "func fibfib(_ n: Int) -> Int {\n  if n == 0 {\n    return 0\n  } else if n == 1 {\n    return 0\n  } else if n == 2 {\n    return 1\n  } else {\n    var a = 0\n    var b = 0\n    var c = 1\n    for i in 2..<n {\n      (a, b, c) = (b, c, a + b + c)\n    }\n    return c\n  }\n}",
  "TypeScript_humaneval-063": "function fibfib(n: number): number {\n  if (n === 0) {\n    return 0;\n  } else if (n === 1) {\n    return 0;\n  } else if (n === 2) {\n    return 1;\n  } else {\n    let a = 0;\n    let b = 0;\n    let c = 1;\n    for (let i = 2; i < n; i++) {\n      [a, b, c] = [b, c, a + b + c];\n    }\n    return c;\n  }\n}",
  "Dart_humaneval-063": "int fibfib(int n) {\n  if (n == 0) {\n    return 0;\n  } else if (n == 1) {\n    return 0;\n  } else if (n == 2) {\n    return 1;\n  } else {\n    int a = 0, b = 0, c = 1;\n    for (int i = 2; i < n; i++) {\n      int temp = a + b + c;\n      a = b;\n      b = c;\n      c = temp;\n    }\n    return c;\n  }\n}",
  "Rust_humaneval-063": "fn fibfib(n: i32) -> i32 {\n    if n == 0 {\n        return 0;\n    } else if n == 1 {\n        return 0;\n    } else if n == 2 {\n        return 1;\n    } else {\n        let (mut a, mut b, mut c) = (0, 0, 1);\n        for _ in 2..n {\n            let temp = a + b + c;\n            a = b;\n            b = c;\n            c = temp;\n        }\n        return c;\n    }\n}",
  "Scala_humaneval-063": "def fibfib(n: Int): Int = {\n  if (n == 0) {\n    0\n  } else if (n == 1) {\n    0\n  } else if (n == 2) {\n    1\n  } else {\n    var (a, b, c) = (0, 0, 1)\n    for (i <- 2 until n) {\n      val temp = a + b + c\n      a = b\n      b = c\n      c = temp\n    }\n    c\n  }\n}",
  "Kotlin_humaneval-063": "fun fibfib(n: Int): Int {\n  if (n == 0) {\n    return 0\n  } else if (n == 1) {\n    return 0\n  } else if (n == 2) {\n    return 1\n  } else {\n    var a = 0\n    var b = 0\n    var c = 1\n    for (i in 2 until n) {\n      val temp = a + b + c\n      a = b\n      b = c\n      c = temp\n    }\n    return c\n  }\n}",
  "C++_humaneval-064": "int vowelsCount(string s) {\n  string vowels = \"aeiou\";\n  int count = 0;\n  for (int i = 0; i < s.length(); i++) {\n    if (vowels.find(tolower(s[i])) != string::npos) {\n      count++;\n    } else if (i == s.length() - 1 && tolower(s[i]) == 'y') {\n      count++;\n    }\n  }\n  return count;\n}",
  "Java_humaneval-064": "public static Integer vowelsCount(String s) {\n  String[] vowels = {\"a\", \"e\", \"i\", \"o\", \"u\"};\n  int count = 0;\n  for (int i = 0; i < s.length(); i++) {\n    if (Arrays.asList(vowels).contains(String.valueOf(s.toLowerCase().charAt(i)))) {\n      count++;\n    } else if (i == s.length() - 1 && s.toLowerCase().charAt(i) == 'y') {\n      count++;\n    }\n  }\n  return count;\n}",
  "Python_humaneval-064": "def vowels_count(s: str) -> int:\n    vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"]\n    count = 0\n    for i in range(len(s)):\n        if s[i].lower() in vowels:\n            count += 1\n        elif i == len(s) - 1 and s[i].lower() == \"y\":\n            count += 1\n    return count",
  "C#_humaneval-064": "public static int VowelsCount(string s) {\n  char[] vowels = { 'a', 'e', 'i', 'o', 'u' };\n  int count = 0;\n  for (int i = 0; i < s.Length; i++) {\n    if (vowels.Contains(char.ToLower(s[i]))) {\n      count++;\n    } else if (i == s.Length - 1 && char.ToLower(s[i]) == 'y') {\n      count++;\n    }\n  }\n  return count;\n}",
  "JavaScript_humaneval-064": "function vowelsCount(s) {\n  const vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"];\n  let count = 0;\n  for (let i = 0; i < s.length; i++) {\n    if (vowels.includes(s[i].toLowerCase())) {\n      count++;\n    } else if (i === s.length - 1 && s[i].toLowerCase() === \"y\") {\n      count++;\n    }\n  }\n  return count;\n}",
  "Go_humaneval-064": "func vowelsCount(s string) int {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n    count := 0\n    for i := 0; i < len(s); i++ {\n        if contains(vowels, strings.ToLower(string(s[i]))) {\n            count++\n        } else if i == len(s)-1 && strings.ToLower(string(s[i])) == \"y\" {\n            count++\n        }\n    }\n    return count\n}\nfunc contains(s []string, e string) bool {\n    for _, a := range s {\n        if a == e {\n            return true\n        }\n    }\n    return false\n}",
  "PHP_humaneval-064": "function vowelsCount(string $s): int {\n    $vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"];\n    $count = 0;\n    for ($i = 0; $i < strlen($s); $i++) {\n        if (in_array(strtolower($s[$i]), $vowels)) {\n            $count++;\n        } elseif ($i == strlen($s) - 1 && strtolower($s[$i]) == \"y\") {\n            $count++;\n        }\n    }\n    return $count;\n}",
  "Ruby_humaneval-064": "def vowels_count(s)\n  vowels = %w[a e i o u]\n  count = 0\n  s.each_char.with_index do |char, i|\n    if vowels.include?(char.downcase)\n      count += 1\n    elsif i == s.length - 1 && char.downcase == \"y\"\n      count += 1\n    end\n  end\n  count\nend",
  "Swift_humaneval-064": "func vowelsCount(_ s: String) -> Int {\n  let vowels: [Character] = [\"a\", \"e\", \"i\", \"o\", \"u\"]\n  var count = 0\n  for (i, char) in s.enumerated() {\n    if vowels.contains(char.lowercased()) {\n      count += 1\n    } else if i == s.count - 1 && char.lowercased() == \"y\" {\n      count += 1\n    }\n  }\n  return count\n}",
  "TypeScript_humaneval-064": "function vowelsCount(s: string): number {\n  const vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"];\n  let count = 0;\n  for (let i = 0; i < s.length; i++) {\n    if (vowels.includes(s[i].toLowerCase())) {\n      count++;\n    } else if (i === s.length - 1 && s[i].toLowerCase() === \"y\") {\n      count++;\n    }\n  }\n  return count;\n}",
  "Dart_humaneval-064": "int vowelsCount(String s) {\n  List<String> vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"];\n  int count = 0;\n  for (int i = 0; i < s.length; i++) {\n    if (vowels.contains(s[i].toLowerCase())) {\n      count++;\n    } else if (i == s.length - 1 && s[i].toLowerCase() == \"y\") {\n      count++;\n    }\n  }\n  return count;\n}",
  "Rust_humaneval-064": "fn vowels_count(s: String) -> i32 {\n    let vowels = vec!['a', 'e', 'i', 'o', 'u'];\n    let mut count = 0;\n    for (i, c) in s.chars().enumerate() {\n        if vowels.contains(&c.to_ascii_lowercase()) {\n            count += 1;\n        } else if i == s.len() - 1 && c.to_ascii_lowercase() == 'y' {\n            count += 1;\n        }\n    }\n    count\n}",
  "Scala_humaneval-064": "def vowelsCount(s: String): Int = {\n  val vowels = List(\"a\", \"e\", \"i\", \"o\", \"u\")\n  var count = 0\n  for (i <- 0 until s.length) {\n    if (\n      vowels.contains(s(i).toString.toLowerCase) || (i == s.length - 1 && s(\n        i\n      ).toString.toLowerCase == \"y\")\n    ) {\n      count += 1\n    }\n  }\n  count\n}",
  "Kotlin_humaneval-064": "fun vowelsCount(s: String): Int {\n  val vowels = listOf('a', 'e', 'i', 'o', 'u')\n  var count = 0\n  for (i in s.indices) {\n    if (s[i].toLowerCase() in vowels) {\n      count++\n    } else if (i == s.length - 1 && s[i].toLowerCase() == 'y') {\n      count++\n    }\n  }\n  return count\n}",
  "C++_humaneval-065": "string circularShift(int x, int shift) {\n  string x_str = to_string(x);\n  int n = x_str.length();\n  if (shift > n) {\n    return string(x_str.rbegin(), x_str.rend());\n  } else {\n    string shifted_str = x_str.substr(n - shift) + x_str.substr(0, n - shift);\n    return shifted_str;\n  }\n}",
  "Java_humaneval-065": "public static String circularShift(Integer x, Integer shift) {\n  String x_str = x.toString();\n  int n = x_str.length();\n  if (shift > n) {\n    return new StringBuilder(x_str).reverse().toString();\n  } else {\n    String shifted_str = x_str.substring(n - shift) + x_str.substring(0, n - shift);\n    return shifted_str;\n  }\n}",
  "Python_humaneval-065": "def circular_shift(x: int, shift: int) -> str:\n    x_str = str(x)\n    n = len(x_str)\n    if shift > n:\n        return x_str[::-1]\n    else:\n        shifted_str = x_str[-shift:] + x_str[:-shift]\n        return shifted_str",
  "C#_humaneval-065": "public static string CircularShift(int x, int shift) {\n  string x_str = x.ToString();\n  int n = x_str.Length;\n  if (shift > n) {\n    return new string(x_str.Reverse().ToArray());\n  } else {\n    string shifted_str = x_str.Substring(n - shift) + x_str.Substring(0, n - shift);\n    return shifted_str;\n  }\n}",
  "JavaScript_humaneval-065": "function circularShift(x, shift) {\n  let xStr = x.toString();\n  let n = xStr.length;\n  if (shift > n) {\n    return xStr.split(\"\").reverse().join(\"\");\n  } else {\n    let shiftedStr = xStr.slice(-shift) + xStr.slice(0, -shift);\n    return shiftedStr;\n  }\n}",
  "Go_humaneval-065": "func circularShift(x int, shift int) string {\n    xStr := strconv.Itoa(x)\n    n := len(xStr)\n    if shift > n {\n        b := []byte(xStr)\n        for i, j := 0, n-1; i < j; i, j = i+1, j-1 {\n            b[i], b[j] = b[j], b[i]\n        }\n        return string(b)\n    } else {\n        shiftedStr := xStr[n-shift:] + xStr[:n-shift]\n        return shiftedStr\n    }\n}",
  "PHP_humaneval-065": "function circularShift(int $x, int $shift): string {\n    $x_str = strval($x);\n    $n = strlen($x_str);\n    if ($shift > $n) {\n        return strrev($x_str);\n    } else {\n        $shifted_str = substr($x_str, -$shift) . substr($x_str, 0, -$shift);\n        return $shifted_str;\n    }\n}",
  "Ruby_humaneval-065": "def circular_shift(x, shift)\n  x_str = x.to_s\n  n = x_str.length\n  if shift > n\n    return x_str.reverse\n  else\n    shifted_str = x_str[-shift..-1] + x_str[0..-shift - 1]\n    return shifted_str\n  end\nend",
  "Swift_humaneval-065": "func circularShift(_ x: Int, _ shift: Int) -> String {\n  let xStr = String(x)\n  let n = xStr.count\n  if shift > n {\n    return String(xStr.reversed())\n  } else {\n    let shiftedStr = xStr.suffix(shift) + xStr.prefix(n - shift)\n    return String(shiftedStr)\n  }\n}",
  "TypeScript_humaneval-065": "function circularShift(x: number, shift: number): string {\n  const xStr = x.toString();\n  const n = xStr.length;\n  if (shift > n) {\n    return xStr.split(\"\").reverse().join(\"\");\n  } else {\n    const shiftedStr = xStr.slice(-shift) + xStr.slice(0, -shift);\n    return shiftedStr;\n  }\n}",
  "Dart_humaneval-065": "String circularShift(int x, int shift) {\n  String xStr = x.toString();\n  int n = xStr.length;\n  if (shift > n) {\n    return xStr.split('').reversed.join();\n  } else {\n    String shiftedStr =\n        xStr.substring(n - shift) + xStr.substring(0, n - shift);\n    return shiftedStr;\n  }\n}",
  "Rust_humaneval-065": "fn circular_shift(x: i32, shift: i32) -> String {\n    let x_str = x.to_string();\n    let n = x_str.len();\n    if shift > n as i32 {\n        return x_str.chars().rev().collect();\n    } else {\n        let shifted_str = format!(\n            \"{}{}\",\n            &x_str[n - shift as usize..],\n            &x_str[..n - shift as usize]\n        );\n        return shifted_str;\n    }\n}",
  "Scala_humaneval-065": "def circularShift(x: Int, shift: Int): String = {\n  val xStr = x.toString\n  val n = xStr.length\n  if (shift > n) {\n    xStr.reverse\n  } else {\n    val shiftedStr = xStr.substring(n - shift) + xStr.substring(0, n - shift)\n    shiftedStr\n  }\n}",
  "Kotlin_humaneval-065": "fun circularShift(x: Int, shift: Int): String {\n  val xStr = x.toString()\n  val n = xStr.length\n  return if (shift > n) {\n    xStr.reversed()\n  } else {\n    val shiftedStr = xStr.substring(n - shift) + xStr.substring(0, n - shift)\n    shiftedStr\n  }\n}",
  "C++_humaneval-066": "int digitSum(string s) {\n  int sum = 0;\n  for (char c : s) {\n    if (isupper(c)) {\n      sum += int(c);\n    }\n  }\n  return sum;\n}",
  "Java_humaneval-066": "public static Integer digitSum(String s) {\n  int sum = 0;\n  for (char c : s.toCharArray()) {\n    if (Character.isUpperCase(c)) {\n      sum += (int) c;\n    }\n  }\n  return sum;\n}",
  "Python_humaneval-066": "def digit_sum(s: str) -> int:\n    sum = 0\n    for c in s:\n        if c.isupper():\n            sum += ord(c)\n    return sum",
  "C#_humaneval-066": "public static int DigitSum(string s) {\n  int sum = 0;\n  foreach (char c in s) {\n    if (Char.IsUpper(c)) {\n      sum += (int)c;\n    }\n  }\n  return sum;\n}",
  "JavaScript_humaneval-066": "function digitSum(s) {\n  let sum = 0;\n  for (let i = 0; i < s.length; i++) {\n    const c = s.charAt(i);\n    if (c.toUpperCase() === c && c.toLowerCase() !== c) {\n      sum += c.charCodeAt(0);\n    }\n  }\n  return sum;\n}",
  "Go_humaneval-066": "func digitSum(s string) int {\n    sum := 0\n    for _, c := range s {\n        if unicode.IsUpper(c) {\n            sum += int(c)\n        }\n    }\n    return sum\n}",
  "PHP_humaneval-066": "function digitSum(string $s): int {\n    $sum = 0;\n    for ($i = 0; $i < strlen($s); $i++) {\n        $c = $s[$i];\n        if (ctype_upper($c)) {\n            $sum += ord($c);\n        }\n    }\n    return $sum;\n}",
  "Ruby_humaneval-066": "def digit_sum(s)\n  sum = 0\n  s.each_char { |c| sum += c.ord if c.upcase == c && c.downcase != c }\n  return sum\nend",
  "Swift_humaneval-066": "func digitSum(_ s: String) -> Int {\n  var sum = 0\n  for c in s {\n    if c.isUppercase {\n      sum += Int(c.asciiValue!)\n    }\n  }\n  return sum\n}",
  "TypeScript_humaneval-066": "function digitSum(s: string): number {\n  let sum = 0;\n  for (let i = 0; i < s.length; i++) {\n    const c = s.charAt(i);\n    if (c.toUpperCase() === c && c.toLowerCase() !== c) {\n      sum += c.charCodeAt(0);\n    }\n  }\n  return sum;\n}",
  "Dart_humaneval-066": "int digitSum(String s) {\n  int sum = 0;\n  for (int i = 0; i < s.length; i++) {\n    if (s[i].toUpperCase() == s[i] && s[i].toLowerCase() != s[i]) {\n      sum += s.codeUnitAt(i);\n    }\n  }\n  return sum;\n}",
  "Rust_humaneval-066": "fn digit_sum(s: String) -> i32 {\n    let mut sum = 0;\n    for c in s.chars() {\n        if c.is_uppercase() {\n            sum += c as i32;\n        }\n    }\n    sum\n}",
  "Scala_humaneval-066": "def digitSum(s: String): Int = {\n  var sum = 0\n  for (c <- s) {\n    if (c.isUpper) {\n      sum += c.toInt\n    }\n  }\n  sum\n}",
  "Kotlin_humaneval-066": "fun digitSum(s: String): Int {\n  var sum = 0\n  for (c in s) {\n    if (c.isUpperCase()) {\n      sum += c.toInt()\n    }\n  }\n  return sum\n}",
  "C++_humaneval-067": "int fruitDistribution(string s, int n) {\n  vector<string> words;\n  stringstream ss(s);\n  string word;\n  while (ss >> word) {\n    words.push_back(word);\n  }\n  int num_apples = 0;\n  int num_oranges = 0;\n  for (int i = 0; i < words.size(); i++) {\n    if (words[i] == \"apples\") {\n      num_apples = stoi(words[i - 1]);\n    } else if (words[i] == \"oranges\") {\n      num_oranges = stoi(words[i - 1]);\n    }\n  }\n  int num_mangoes = n - num_apples - num_oranges;\n  return num_mangoes;\n}",
  "Java_humaneval-067": "public static Integer fruitDistribution(String s, Integer n) {\n  String[] words = s.split(\" \");\n  int numApples = 0;\n  int numOranges = 0;\n  for (int i = 0; i < words.length; i++) {\n    if (words[i].equals(\"apples\")) {\n      numApples = Integer.parseInt(words[i - 1]);\n    } else if (words[i].equals(\"oranges\")) {\n      numOranges = Integer.parseInt(words[i - 1]);\n    }\n  }\n  int numMangoes = n - numApples - numOranges;\n  return numMangoes;\n}",
  "Python_humaneval-067": "def fruit_distribution(s: str, n: int) -> int:\n    words = s.split()\n    num_apples = 0\n    num_oranges = 0\n    for word in words:\n        if word == \"apples\":\n            num_apples = int(words[words.index(word) - 1])\n        elif word == \"oranges\":\n            num_oranges = int(words[words.index(word) - 1])\n    num_mangoes = n - num_apples - num_oranges\n    return num_mangoes",
  "C#_humaneval-067": "public static int FruitDistribution(string s, int n) {\n  string[] words = s.Split();\n  int num_apples = 0;\n  int num_oranges = 0;\n  for (int i = 0; i < words.Length; i++) {\n    if (words[i] == \"apples\") {\n      num_apples = int.Parse(words[i - 1]);\n    } else if (words[i] == \"oranges\") {\n      num_oranges = int.Parse(words[i - 1]);\n    }\n  }\n  int num_mangoes = n - num_apples - num_oranges;\n  return num_mangoes;\n}",
  "JavaScript_humaneval-067": "function fruitDistribution(s, n) {\n  let words = s.split(\" \");\n  let num_apples = 0;\n  let num_oranges = 0;\n  for (let i = 0; i < words.length; i++) {\n    if (words[i] == \"apples\") {\n      num_apples = parseInt(words[i - 1]);\n    } else if (words[i] == \"oranges\") {\n      num_oranges = parseInt(words[i - 1]);\n    }\n  }\n  let num_mangoes = n - num_apples - num_oranges;\n  return num_mangoes;\n}",
  "Go_humaneval-067": "func fruitDistribution(s string, n int) int {\n    words := strings.Split(s, \" \")\n    var numApples, numOranges int\n    for i, word := range words {\n        if word == \"apples\" {\n            numApples, _ = strconv.Atoi(words[i-1])\n        } else if word == \"oranges\" {\n            numOranges, _ = strconv.Atoi(words[i-1])\n        }\n    }\n    numMangoes := n - numApples - numOranges\n    return numMangoes\n}",
  "PHP_humaneval-067": "function fruitDistribution(string $s, int $n): int {\n    $words = explode(\" \", $s);\n    $num_apples = 0;\n    $num_oranges = 0;\n    foreach ($words as $key => $word) {\n        if ($word == \"apples\") {\n            $num_apples = (int)$words[$key - 1];\n        } elseif ($word == \"oranges\") {\n            $num_oranges = (int)$words[$key - 1];\n        }\n    }\n    $num_mangoes = $n - $num_apples - $num_oranges;\n    return $num_mangoes;\n}",
  "Ruby_humaneval-067": "def fruit_distribution(s, n)\n  words = s.split\n  num_apples = 0\n  num_oranges = 0\n  words.each_with_index do |word, i|\n    if word == \"apples\"\n      num_apples = words[i - 1].to_i\n    elsif word == \"oranges\"\n      num_oranges = words[i - 1].to_i\n    end\n  end\n  num_mangoes = n - num_apples - num_oranges\n  num_mangoes\nend",
  "Swift_humaneval-067": "func fruitDistribution(_ s: String, _ n: Int) -> Int {\n  let words = s.split(separator: \" \")\n  var numApples = 0\n  var numOranges = 0\n  for (index, word) in words.enumerated() {\n    if word == \"apples\" {\n      numApples = Int(words[index - 1]) ?? 0\n    } else if word == \"oranges\" {\n      numOranges = Int(words[index - 1]) ?? 0\n    }\n  }\n  let numMangoes = n - numApples - numOranges\n  return numMangoes\n}",
  "TypeScript_humaneval-067": "function fruitDistribution(s: string, n: number): number {\n  const words: string[] = s.split(\" \");\n  let num_apples: number = 0;\n  let num_oranges: number = 0;\n  for (let i = 0; i < words.length; i++) {\n    const word: string = words[i];\n    if (word === \"apples\") {\n      num_apples = parseInt(words[i - 1]);\n    } else if (word === \"oranges\") {\n      num_oranges = parseInt(words[i - 1]);\n    }\n  }\n  const num_mangoes: number = n - num_apples - num_oranges;\n  return num_mangoes;\n}",
  "Dart_humaneval-067": "int fruitDistribution(String s, int n) {\n  List<String> words = s.split(\" \");\n  int numApples = 0;\n  int numOranges = 0;\n  for (String word in words) {\n    if (word == \"apples\") {\n      numApples = int.parse(words[words.indexOf(word) - 1]);\n    } else if (word == \"oranges\") {\n      numOranges = int.parse(words[words.indexOf(word) - 1]);\n    }\n  }\n  int numMangoes = n - numApples - numOranges;\n  return numMangoes;\n}",
  "Rust_humaneval-067": "fn fruit_distribution(s: String, n: i32) -> i32 {\n    let words: Vec<&str> = s.split_whitespace().collect();\n    let mut num_apples = 0;\n    let mut num_oranges = 0;\n    for (i, &word) in words.iter().enumerate() {\n        if word == \"apples\" {\n            num_apples = words[i - 1].parse().unwrap();\n        } else if word == \"oranges\" {\n            num_oranges = words[i - 1].parse().unwrap();\n        }\n    }\n    let num_mangoes = n - num_apples - num_oranges;\n    num_mangoes\n}",
  "Scala_humaneval-067": "def fruitDistribution(s: String, n: Int): Int = {\n  val words = s.split(\" \")\n  var numApples = 0\n  var numOranges = 0\n  for (i <- 0 until words.length) {\n    if (words(i) == \"apples\") {\n      numApples = words(i - 1).toInt\n    } else if (words(i) == \"oranges\") {\n      numOranges = words(i - 1).toInt\n    }\n  }\n  val numMangoes = n - numApples - numOranges\n  numMangoes\n}",
  "Kotlin_humaneval-067": "fun fruitDistribution(s: String, n: Int): Int {\n  val words = s.split(\" \")\n  var numApples = 0\n  var numOranges = 0\n  for (word in words) {\n    when (word) {\n      \"apples\" -> numApples = words[words.indexOf(word) - 1].toInt()\n      \"oranges\" -> numOranges = words[words.indexOf(word) - 1].toInt()\n    }\n  }\n  val numMangoes = n - numApples - numOranges\n  return numMangoes\n}",
  "C++_humaneval-068": "vector<int> pluck(vector<int> arr) {\n  vector<pair<int, int>> even_values;\n  for (int i = 0; i < arr.size(); i++) {\n    if (arr[i] % 2 == 0) {\n      even_values.push_back(make_pair(arr[i], i));\n    }\n  }\n  if (even_values.empty()) {\n    return {};\n  } else {\n    auto smallest_even_value = *min_element(\n        even_values.begin(), even_values.end(),\n        [](const auto& a, const auto& b) {\n          return a.first == b.first ? a.second < b.second : a.first < b.first;\n        });\n    return {smallest_even_value.first, smallest_even_value.second};\n  }\n}",
  "Java_humaneval-068": "public static List<Integer> pluck(List<Integer> arr) {\n  List<Integer> evenValues = new ArrayList<>();\n  for (int i = 0; i < arr.size(); i++) {\n    int val = arr.get(i);\n    if (val % 2 == 0) {\n      evenValues.add(val);\n      evenValues.add(i);\n    }\n  }\n  if (evenValues.isEmpty()) {\n    return new ArrayList<>();\n  } else {\n    int smallestEvenValueIndex = -1;\n    int smallestEvenValue = Integer.MAX_VALUE;\n    for (int i = 0; i < evenValues.size(); i += 2) {\n      int currentValue = evenValues.get(i);\n      if (currentValue < smallestEvenValue) {\n        smallestEvenValue = currentValue;\n        smallestEvenValueIndex = evenValues.get(i + 1);\n      } else if (currentValue == smallestEvenValue) {\n        smallestEvenValueIndex = Math.min(smallestEvenValueIndex, evenValues.get(i + 1));\n      }\n    }\n    List<Integer> result = new ArrayList<>();\n    result.add(smallestEvenValue);\n    result.add(smallestEvenValueIndex);\n    return result;\n  }\n}",
  "Python_humaneval-068": "def pluck(arr: List[int]) -> List[int]:\n    even_values = []\n    for i, val in enumerate(arr):\n        if val % 2 == 0:\n            even_values.append((val, i))\n    if not even_values:\n        return []\n    else:\n        smallest_even_value = min(even_values, key=lambda x: (x[0], x[1]))\n        return [smallest_even_value[0], smallest_even_value[1]]",
  "C#_humaneval-068": "public static List<int> Pluck(List<int> arr) {\n  List<(int, int)> even_values = new List<(int, int)>();\n  for (int i = 0; i < arr.Count; i++) {\n    int val = arr[i];\n    if (val % 2 == 0) {\n      even_values.Add((val, i));\n    }\n  }\n  if (even_values.Count == 0) {\n    return new List<int>();\n  } else {\n    (int, int)smallest_even_value = even_values.Min((x) => (x.Item1, x.Item2));\n    return new List<int> { smallest_even_value.Item1, smallest_even_value.Item2 };\n  }\n}",
  "JavaScript_humaneval-068": "function pluck(arr) {\n  let even_values = [];\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] % 2 === 0) {\n      even_values.push([arr[i], i]);\n    }\n  }\n  if (even_values.length === 0) {\n    return [];\n  } else {\n    let smallest_even_value = even_values.reduce(function (a, b) {\n      return a[0] < b[0] || (a[0] === b[0] && a[1] < b[1]) ? a : b;\n    });\n    return [smallest_even_value[0], smallest_even_value[1]];\n  }\n}",
  "Go_humaneval-068": "func pluck(arr []int) []int {\n    evenValues := make([][]int, 0)\n    for i, val := range arr {\n        if val%2 == 0 {\n            evenValues = append(evenValues, []int{val, i})\n        }\n    }\n    if len(evenValues) == 0 {\n        return []int{}\n    } else {\n        smallestEvenValue := evenValues[0]\n        for _, val := range evenValues {\n            if val[0] < smallestEvenValue[0] || (val[0] == smallestEvenValue[0] && val[1] < smallestEvenValue[1]) {\n                smallestEvenValue = val\n            }\n        }\n        return []int{smallestEvenValue[0], smallestEvenValue[1]}\n    }\n}",
  "PHP_humaneval-068": "function pluck(array $arr): array {\n    $even_values = [];\n    foreach ($arr as $i => $val) {\n        if ($val % 2 === 0) {\n            $even_values[] = [$val, $i];\n        }\n    }\n    if (empty($even_values)) {\n        return [];\n    } else {\n        return min($even_values);\n    }\n}",
  "Ruby_humaneval-068": "def pluck(arr)\n  even_values = []\n  arr.each_with_index { |val, i| even_values << [val, i] if val % 2 == 0 }\n  if even_values.empty?\n    return []\n  else\n    smallest_even_value = even_values.min_by { |x| [x[0], x[1]] }\n    return smallest_even_value[0], smallest_even_value[1]\n  end\nend",
  "Swift_humaneval-068": "func pluck(_ arr: [Int]) -> [Int] {\n  var evenValues = [(Int, Int)]()\n  for (i, val) in arr.enumerated() {\n    if val % 2 == 0 {\n      evenValues.append((val, i))\n    }\n  }\n  if evenValues.isEmpty {\n    return []\n  } else {\n    let smallestEvenValue = evenValues.min(by: { $0.0 == $1.0 ? $0.1 < $1.1 : $0.0 < $1.0 })!\n    return [smallestEvenValue.0, smallestEvenValue.1]\n  }\n}",
  "TypeScript_humaneval-068": "function pluck(arr: number[]): number[] {\n  const evenValues: [number, number][] = [];\n  for (let i = 0; i < arr.length; i++) {\n    const val = arr[i];\n    if (val % 2 === 0) {\n      evenValues.push([val, i]);\n    }\n  }\n  if (!evenValues.length) {\n    return [];\n  } else {\n    const smallestEvenValue = evenValues.reduce((a, b) => {\n      if (a[0] === b[0]) {\n        return a[1] < b[1] ? a : b;\n      } else {\n        return a[0] < b[0] ? a : b;\n      }\n    });\n    return [smallestEvenValue[0], smallestEvenValue[1]];\n  }\n}",
  "Dart_humaneval-068": "List<int> pluck(List<int> arr) {\n  List<List<int>> evenValues = [];\n  for (int i = 0; i < arr.length; i++) {\n    int val = arr[i];\n    if (val % 2 == 0) {\n      evenValues.add([val, i]);\n    }\n  }\n  if (evenValues.isEmpty) {\n    return [];\n  } else {\n    List<int> smallestEvenValue = evenValues.reduce(\n        (a, b) => (a[0] < b[0] || (a[0] == b[0] && a[1] < b[1])) ? a : b);\n    return [smallestEvenValue[0], smallestEvenValue[1]];\n  }\n}",
  "Rust_humaneval-068": "fn pluck(arr: Vec<i32>) -> Vec<i32> {\n    let mut even_values = vec![];\n    for (i, &val) in arr.iter().enumerate() {\n        if val % 2 == 0 {\n            even_values.push((val, i));\n        }\n    }\n    if even_values.is_empty() {\n        return vec![];\n    } else {\n        let smallest_even_value = even_values.iter().min_by(|x, y| x.cmp(y)).unwrap();\n        return vec![smallest_even_value.0, smallest_even_value.1 as i32];\n    }\n}",
  "Scala_humaneval-068": "def pluck(arr: List[Int]): List[Int] = {\n  val evenValues = arr.zipWithIndex.filter { case (value, _) => value % 2 == 0 }\n  if (evenValues.isEmpty) {\n    List.empty\n  } else {\n    val smallestEvenValue = evenValues.minBy { case (value, index) =>\n      (value, index)\n    }\n    List(smallestEvenValue._1, smallestEvenValue._2)\n  }\n}",
  "Kotlin_humaneval-068": "fun pluck(arr: List<Int>): List<Int> {\n  val evenValues = mutableListOf<Pair<Int, Int>>()\n  for ((i, value) in arr.withIndex()) {\n    if (value % 2 == 0) {\n      evenValues.add(Pair(value, i))\n    }\n  }\n  if (evenValues.isEmpty()) {\n    return emptyList()\n  } else {\n    val smallestEvenValue = evenValues.minWithOrNull(compareBy({ it.first }, { it.second }))!!\n    return listOf(smallestEvenValue.first, smallestEvenValue.second)\n  }\n}",
  "C++_humaneval-069": "int search(vector<int> l) {\n  int max_val = -1;\n  for (int val : set<int>(l.begin(), l.end())) {\n    if (val > 0 && count(l.begin(), l.end(), val) >= val) {\n      max_val = max(max_val, val);\n    }\n  }\n  return max_val;\n}",
  "Java_humaneval-069": "public static Integer search(List<Integer> l) {\n  int max_val = -1;\n  for (Integer val : new HashSet<>(l)) {\n    if (val > 0 && Collections.frequency(l, val) >= val) {\n      max_val = Math.max(max_val, val);\n    }\n  }\n  return max_val;\n}",
  "Python_humaneval-069": "def search(l: List[int]) -> int:\n    max_val = -1\n    for val in set(l):\n        if val > 0 and l.count(val) >= val:\n            max_val = max(max_val, val)\n    return max_val",
  "C#_humaneval-069": "public static int Search(List<int> l) {\n  int max_val = -1;\n  foreach (int val in new HashSet<int>(l)) {\n    if (val > 0 && l.Count(x => x == val) >= val) {\n      max_val = Math.Max(max_val, val);\n    }\n  }\n  return max_val;\n}",
  "JavaScript_humaneval-069": "function search(l) {\n  let max_val = -1;\n  let uniqueVals = new Set(l);\n  for (let val of uniqueVals) {\n    if (val > 0 && l.filter((x) => x === val).length >= val) {\n      max_val = Math.max(max_val, val);\n    }\n  }\n  return max_val;\n}",
  "Go_humaneval-069": "func search(l []int) int {\n    maxVal := -1\n    uniqueVals := make(map[int]bool)\n    for _, val := range l {\n        uniqueVals[val] = true\n    }\n    for val := range uniqueVals {\n        if val > 0 && count(l, val) >= val {\n            maxVal = max(maxVal, val)\n        }\n    }\n    return maxVal\n}\nfunc count(l []int, val int) int {\n    count := 0\n    for _, v := range l {\n        if v == val {\n            count++\n        }\n    }\n    return count\n}\nfunc max(a, b int) int {\n    if a > b {\n        return a\n    }\n    return b\n}",
  "PHP_humaneval-069": "function search(array $l): int {\n    $max_val = -1;\n    foreach (array_unique($l) as $val) {\n        if ($val > 0 && count(array_keys($l, $val)) >= $val) {\n            $max_val = max($max_val, $val);\n        }\n    }\n    return $max_val;\n}",
  "Ruby_humaneval-069": "def search(l)\n  max_val = -1\n  l.uniq.each do |val|\n    max_val = [max_val, val].max if val > 0 && l.count(val) >= val\n  end\n  max_val\nend",
  "Swift_humaneval-069": "func search(_ l: [Int]) -> Int {\n  var max_val = -1\n  for val in Set(l) {\n    if val > 0 && l.filter({ $0 == val }).count >= val {\n      max_val = max(max_val, val)\n    }\n  }\n  return max_val\n}",
  "TypeScript_humaneval-069": "function search(l: number[]): number {\n  let max_val = -1;\n  for (const val of new Set(l)) {\n    if (val > 0 && l.filter((x) => x === val).length >= val) {\n      max_val = Math.max(max_val, val);\n    }\n  }\n  return max_val;\n}",
  "Dart_humaneval-069": "int search(List<int> l) {\n  int maxVal = -1;\n  for (int val in Set.of(l)) {\n    if (val > 0 && l.where((x) => x == val).length >= val) {\n      maxVal = max(maxVal, val);\n    }\n  }\n  return maxVal;\n}",
  "Rust_humaneval-069": "fn search(l: Vec<i32>) -> i32 {\n    let mut max_val = -1;\n    let set: HashSet<i32> = l.iter().cloned().collect();\n    for val in set {\n        if val > 0 && l.iter().filter(|&x| *x == val).count() as i32 >= val {\n            max_val = max_val.max(val);\n        }\n    }\n    max_val\n}",
  "Scala_humaneval-069": "def search(l: List[Int]): Int = {\n  var maxVal = -1\n  for (value <- l.distinct) {\n    if (value > 0 && l.count(_ == value) >= value) {\n      maxVal = max(maxVal, value)\n    }\n  }\n  maxVal\n}",
  "Kotlin_humaneval-069": "fun search(l: List<Int>): Int {\n  var maxVal = -1\n  for (value in l.toSet()) {\n    if (value > 0 && l.count { it == value } >= value) {\n      maxVal = maxOf(maxVal, value)\n    }\n  }\n  return maxVal\n}",
  "C++_humaneval-070": "vector<int> strangeSortList(vector<int> l) {\n  vector<int> sorted_l;\n  sort(l.begin(), l.end());\n  while (!l.empty()) {\n    sorted_l.push_back(l.front());\n    l.erase(l.begin());\n    if (!l.empty()) {\n      sorted_l.push_back(l.back());\n      l.pop_back();\n    }\n  }\n  return sorted_l;\n}",
  "Java_humaneval-070": "public static List<Integer> strangeSortList(List<Integer> l) {\n  List<Integer> sorted_l = new ArrayList<>();\n  Collections.sort(l);\n  while (!l.isEmpty()) {\n    sorted_l.add(l.remove(0));\n    if (!l.isEmpty()) {\n      sorted_l.add(l.remove(l.size() - 1));\n    }\n  }\n  return sorted_l;\n}",
  "Python_humaneval-070": "def strange_sort_list(l: List[int]) -> List[int]:\n    sorted_l = []\n    l.sort()\n    while l:\n        sorted_l.append(l.pop(0))\n        if l:\n            sorted_l.append(l.pop(-1))\n    return sorted_l",
  "C#_humaneval-070": "public static List<int> StrangeSortList(List<int> l) {\n  List<int> sorted_l = new List<int>();\n  l.Sort();\n  while (l.Count > 0) {\n    sorted_l.Add(l[0]);\n    l.RemoveAt(0);\n    if (l.Count > 0) {\n      sorted_l.Add(l[l.Count - 1]);\n      l.RemoveAt(l.Count - 1);\n    }\n  }\n  return sorted_l;\n}",
  "JavaScript_humaneval-070": "function strangeSortList(l) {\n  let sorted_l = [];\n  l.sort((a, b) => a - b);\n  while (l.length) {\n    sorted_l.push(l.shift());\n    if (l.length) {\n      sorted_l.push(l.pop());\n    }\n  }\n  return sorted_l;\n}",
  "Go_humaneval-070": "func strangeSortList(l []int) []int {\n    sorted_l := []int{}\n    sort.Ints(l)\n    for len(l) > 0 {\n        sorted_l = append(sorted_l, l[0])\n        l = l[1:]\n        if len(l) > 0 {\n            sorted_l = append(sorted_l, l[len(l)-1])\n            l = l[:len(l)-1]\n        }\n    }\n    return sorted_l\n}",
  "PHP_humaneval-070": "function strangeSortList(array $l): array {\n    $sorted_l = [];\n    sort($l);\n    while ($l) {\n        array_push($sorted_l, array_shift($l));\n        if ($l) {\n            array_push($sorted_l, array_pop($l));\n        }\n    }\n    return $sorted_l;\n}",
  "Ruby_humaneval-070": "def strange_sort_list(l)\n  sorted_l = []\n  l.sort!\n  while l.any?\n    sorted_l << l.shift\n    sorted_l << l.pop unless l.empty?\n  end\n  sorted_l\nend",
  "Swift_humaneval-070": "func strangeSortList(_ l: [Int]) -> [Int] {\n  var sortedL = [Int]()\n  var l = l.sorted()\n  while !l.isEmpty {\n    sortedL.append(l.removeFirst())\n    if !l.isEmpty {\n      sortedL.append(l.removeLast())\n    }\n  }\n  return sortedL\n}",
  "TypeScript_humaneval-070": "function strangeSortList(l: number[]): number[] {\n  const sorted_l: number[] = [];\n  l.sort();\n  while (l.length) {\n    sorted_l.push(l.shift()!);\n    if (l.length) {\n      sorted_l.push(l.pop()!);\n    }\n  }\n  return sorted_l;\n}",
  "Dart_humaneval-070": "List<int> strangeSortList(List<int> l) {\n  List<int> sortedL = [];\n  l.sort();\n  while (l.isNotEmpty) {\n    sortedL.add(l.removeAt(0));\n    if (l.isNotEmpty) {\n      sortedL.add(l.removeLast());\n    }\n  }\n  return sortedL;\n}",
  "Rust_humaneval-070": "fn strange_sort_list(l: Vec<i32>) -> Vec<i32> {\n    let mut l = l;\n    let mut sorted_l = Vec::new();\n    l.sort();\n    while !l.is_empty() {\n        sorted_l.push(l.remove(0));\n        if !l.is_empty() {\n            sorted_l.push(l.pop().unwrap());\n        }\n    }\n    sorted_l\n}",
  "Scala_humaneval-070": "def strangeSortList(l: List[Int]): List[Int] = {\n  var sortedL: List[Int] = List()\n  var mutableL = l.sorted\n  while (mutableL.nonEmpty) {\n    sortedL = sortedL :+ mutableL.head\n    mutableL = mutableL.drop(1)\n    if (mutableL.nonEmpty) {\n      sortedL = sortedL :+ mutableL.last\n      mutableL = mutableL.dropRight(1)\n    }\n  }\n  sortedL\n}",
  "Kotlin_humaneval-070": "fun strangeSortList(l: List<Int>): List<Int> {\n  val sortedL = mutableListOf<Int>()\n  val mutableL = l.toMutableList()\n  mutableL.sort()\n  while (mutableL.isNotEmpty()) {\n    sortedL.add(mutableL.removeAt(0))\n    if (mutableL.isNotEmpty()) {\n      sortedL.add(mutableL.removeAt(mutableL.size - 1))\n    }\n  }\n  return sortedL\n}",
  "C++_humaneval-071": "double triangleArea(int a, int b, int c) {\n  if (a + b > c && a + c > b && b + c > a) {\n    double s = (a + b + c) / 2.0;\n    double area = pow(s * (s - a) * (s - b) * (s - c), 0.5);\n    return round(area * 100) / 100.0;\n  } else {\n    return -1;\n  }\n}",
  "Java_humaneval-071": "public static Double triangleArea(Integer a, Integer b, Integer c) {\n  if (a + b > c && a + c > b && b + c > a) {\n    double s = (a + b + c) / 2.0;\n    double area = Math.sqrt(s * (s - a) * (s - b) * (s - c));\n    return Math.round(area * 100.0) / 100.0;\n  } else {\n    return -1.0;\n  }\n}",
  "Python_humaneval-071": "def triangle_area(a: int, b: int, c: int) -> float:\n    if a + b > c and a + c > b and b + c > a:\n        s = (a + b + c) / 2\n        area = (s * (s - a) * (s - b) * (s - c)) ** 0.5\n        return round(area, 2)\n    else:\n        return -1",
  "C#_humaneval-071": "public static double TriangleArea(int a, int b, int c) {\n  if (a + b > c && a + c > b && b + c > a) {\n    double s = (a + b + c) / 2.0;\n    double area = Math.Pow(s * (s - a) * (s - b) * (s - c), 0.5);\n    return Math.Round(area, 2);\n  } else {\n    return -1;\n  }\n}",
  "JavaScript_humaneval-071": "function triangleArea(a, b, c) {\n  if (a + b > c && a + c > b && b + c > a) {\n    let s = (a + b + c) / 2;\n    let area = Math.pow(s * (s - a) * (s - b) * (s - c), 0.5);\n    return parseFloat(area.toFixed(2));\n  } else {\n    return -1;\n  }\n}",
  "Go_humaneval-071": "func triangleArea(a int, b int, c int) float64 {\n    if a+b > c && a+c > b && b+c > a {\n        s := float64(a+b+c) / 2\n        area := math.Pow(s*(s-float64(a))*(s-float64(b))*(s-float64(c)), 0.5)\n        return math.Round(area*100) / 100\n    } else {\n        return -1\n    }\n}",
  "PHP_humaneval-071": "function triangleArea(int $a, int $b, int $c): float {\n    if ($a + $b > $c && $a + $c > $b && $b + $c > $a) {\n        $s = ($a + $b + $c) / 2;\n        $area = pow($s * ($s - $a) * ($s - $b) * ($s - $c), 0.5);\n        return round($area, 2);\n    } else {\n        return -1;\n    }\n}",
  "Ruby_humaneval-071": "def triangle_area(a, b, c)\n  if a + b > c && a + c > b && b + c > a\n    s = (a + b + c) / 2.0\n    area = (s * (s - a) * (s - b) * (s - c))**0.5\n    return area.round(2)\n  else\n    return -1\n  end\nend",
  "Swift_humaneval-071": "func triangleArea(_ a: Int, _ b: Int, _ c: Int) -> Double {\n  if a + b > c && a + c > b && b + c > a {\n    let s = Double(a + b + c) / 2\n    let area = pow(s * (s - Double(a)) * (s - Double(b)) * (s - Double(c)), 0.5)\n    return round(area * 100) / 100\n  } else {\n    return -1\n  }\n}",
  "TypeScript_humaneval-071": "function triangleArea(a: number, b: number, c: number): number {\n  if (a + b > c && a + c > b && b + c > a) {\n    const s = (a + b + c) / 2;\n    const area = Math.sqrt(s * (s - a) * (s - b) * (s - c));\n    return parseFloat(area.toFixed(2));\n  } else {\n    return -1;\n  }\n}",
  "Dart_humaneval-071": "double triangleArea(int a, int b, int c) {\n  if (a + b > c && a + c > b && b + c > a) {\n    double s = (a + b + c) / 2;\n    double area = pow(s * (s - a) * (s - b) * (s - c), 0.5) as double;\n    return double.parse(area.toStringAsFixed(2));\n  } else {\n    return -1;\n  }\n}",
  "Rust_humaneval-071": "fn triangle_area(a: i32, b: i32, c: i32) -> f64 {\n    if a + b > c && a + c > b && b + c > a {\n        let s = (a + b + c) as f64 / 2.0;\n        let area = (s * (s - a as f64) * (s - b as f64) * (s - c as f64)).sqrt();\n        return (area * 100.0).round() / 100.0;\n    } else {\n        return -1.0;\n    }\n}",
  "Scala_humaneval-071": "def triangleArea(a: Int, b: Int, c: Int): Double = {\n  if (a + b > c && a + c > b && b + c > a) {\n    val s = (a + b + c) / 2.0\n    val area = sqrt(s * (s - a) * (s - b) * (s - c))\n    round(area * 100) / 100.0\n  } else {\n    -1\n  }\n}",
  "Kotlin_humaneval-071": "fun triangleArea(a: Int, b: Int, c: Int): Double {\n  return if (a + b > c && a + c > b && b + c > a) {\n    val s = (a + b + c) / 2.0\n    val area = Math.sqrt(s * (s - a) * (s - b) * (s - c))\n    Math.round(area * 100) / 100.0\n  } else {\n    -1.0\n  }\n}",
  "C++_humaneval-072": "bool willItFly(vector<int> q, int w) {\n  int n = q.size();\n  bool is_palindromic = true;\n  for (int i = 0; i < n; i++) {\n    if (q[i] != q[n - i - 1]) {\n      is_palindromic = false;\n      break;\n    }\n  }\n  if (is_palindromic && accumulate(q.begin(), q.end(), 0) <= w) {\n    return true;\n  } else {\n    return false;\n  }\n}",
  "Java_humaneval-072": "public static Boolean willItFly(List<Integer> q, Integer w) {\n  int n = q.size();\n  boolean isPalindromic = true;\n  for (int i = 0; i < n; i++) {\n    if (q.get(i) != q.get(n - i - 1)) {\n      isPalindromic = false;\n      break;\n    }\n  }\n  if (isPalindromic && q.stream().mapToInt(Integer::intValue).sum() <= w) {\n    return true;\n  } else {\n    return false;\n  }\n}",
  "Python_humaneval-072": "def will_it_fly(q: List[int], w: int) -> bool:\n    n = len(q)\n    is_palindromic = all(q[i] == q[n - i - 1] for i in range(n))\n    if is_palindromic and sum(q) <= w:\n        return True\n    else:\n        return False",
  "C#_humaneval-072": "public static bool WillItFly(List<int> q, int w) {\n  int n = q.Count;\n  bool is_palindromic = Enumerable.Range(0, n).All(i => q[i] == q[n - i - 1]);\n  if (is_palindromic && q.Sum() <= w) {\n    return true;\n  } else {\n    return false;\n  }\n}",
  "JavaScript_humaneval-072": "function willItFly(q, w) {\n  const n = q.length;\n  const isPalindromic = q.every((val, i) => val === q[n - i - 1]);\n  if (isPalindromic && q.reduce((sum, val) => sum + val, 0) <= w) {\n    return true;\n  } else {\n    return false;\n  }\n}",
  "Go_humaneval-072": "func willItFly(q []int, w int) bool {\n    n := len(q)\n    isPalindromic := true\n    for i := 0; i < n/2; i++ {\n        if q[i] != q[n-i-1] {\n            isPalindromic = false\n            break\n        }\n    }\n    if isPalindromic && sum(q) <= w {\n        return true\n    }\n    return false\n}\nfunc sum(q []int) int {\n    s := 0\n    for _, v := range q {\n        s += v\n    }\n    return s\n}",
  "PHP_humaneval-072": "function willItFly(array $q, int $w): bool {\n    $n = count($q);\n    $is_palindromic = true;\n    for ($i = 0; $i < $n; $i++) {\n        if ($q[$i] != $q[$n - $i - 1]) {\n            $is_palindromic = false;\n            break;\n        }\n    }\n    if ($is_palindromic && array_sum($q) <= $w) {\n        return true;\n    } else {\n        return false;\n    }\n}",
  "Ruby_humaneval-072": "def will_it_fly(q, w)\n  n = q.length\n  is_palindromic = (0...n).all? { |i| q[i] == q[n - i - 1] }\n  if is_palindromic && q.sum <= w\n    true\n  else\n    false\n  end\nend",
  "Swift_humaneval-072": "func willItFly(_ q: [Int], _ w: Int) -> Bool {\n  let n = q.count\n  let isPalindromic = zip(q, q.reversed()).allSatisfy(==)\n  if isPalindromic && q.reduce(0, +) <= w {\n    return true\n  } else {\n    return false\n  }\n}",
  "TypeScript_humaneval-072": "function willItFly(q: number[], w: number): boolean {\n  const n = q.length;\n  const isPalindromic = q.every((value, index) => value === q[n - index - 1]);\n  if (isPalindromic && q.reduce((acc, curr) => acc + curr, 0) <= w) {\n    return true;\n  } else {\n    return false;\n  }\n}",
  "Dart_humaneval-072": "bool willItFly(List<int> q, int w) {\n  int n = q.length;\n  bool isPalindromic =\n      List.generate(n, (i) => q[i] == q[n - i - 1]).every((x) => x);\n  if (isPalindromic && q.reduce((a, b) => a + b) <= w) {\n    return true;\n  } else {\n    return false;\n  }\n}",
  "Rust_humaneval-072": "fn will_it_fly(q: Vec<i32>, w: i32) -> bool {\n    let n = q.len();\n    let is_palindromic = (0..n).all(|i| q[i] == q[n - i - 1]);\n    if is_palindromic && q.iter().sum::<i32>() <= w {\n        true\n    } else {\n        false\n    }\n}",
  "Scala_humaneval-072": "def willItFly(q: List[Int], w: Int): Boolean = {\n  val n = q.length\n  val isPalindromic = (0 until n).forall(i => q(i) == q(n - i - 1))\n  if (isPalindromic && q.sum <= w) {\n    true\n  } else {\n    false\n  }\n}",
  "Kotlin_humaneval-072": "fun willItFly(q: List<Int>, w: Int): Boolean {\n  val n = q.size\n  val isPalindromic = (0 until n).all { q[it] == q[n - it - 1] }\n  return isPalindromic && q.sum() <= w\n}",
  "C++_humaneval-073": "int smallestChange(vector<int> arr) {\n  int n = arr.size();\n  int changes_needed = 0;\n  for (int i = 0; i < n / 2; i++) {\n    if (arr[i] != arr[n - i - 1]) {\n      changes_needed++;\n    }\n  }\n  return changes_needed;\n}",
  "Java_humaneval-073": "public static Integer smallestChange(List<Integer> arr) {\n  int n = arr.size();\n  int changesNeeded = 0;\n  for (int i = 0; i < n / 2; i++) {\n    if (!arr.get(i).equals(arr.get(n - i - 1))) {\n      changesNeeded++;\n    }\n  }\n  return changesNeeded;\n}",
  "Python_humaneval-073": "def smallest_change(arr: List[int]) -> int:\n    n = len(arr)\n    changes_needed = 0\n    for i in range(n // 2):\n        if arr[i] != arr[n - i - 1]:\n            changes_needed += 1\n    return changes_needed",
  "C#_humaneval-073": "public static int SmallestChange(List<int> arr) {\n  int n = arr.Count;\n  int changesNeeded = 0;\n  for (int i = 0; i < n / 2; i++) {\n    if (arr[i] != arr[n - i - 1]) {\n      changesNeeded++;\n    }\n  }\n  return changesNeeded;\n}",
  "JavaScript_humaneval-073": "function smallestChange(arr) {\n  const n = arr.length;\n  let changesNeeded = 0;\n  for (let i = 0; i < n / 2; i++) {\n    if (arr[i] !== arr[n - i - 1]) {\n      changesNeeded += 1;\n    }\n  }\n  return changesNeeded;\n}",
  "Go_humaneval-073": "func smallestChange(arr []int) int {\n    n := len(arr)\n    changesNeeded := 0\n    for i := 0; i < n/2; i++ {\n        if arr[i] != arr[n-i-1] {\n            changesNeeded++\n        }\n    }\n    return changesNeeded\n}",
  "PHP_humaneval-073": "function smallestChange(array $arr): int {\n    $n = count($arr);\n    $changesNeeded = 0;\n    for ($i = 0; $i < $n / 2; $i++) {\n        if ($arr[$i] != $arr[$n - $i - 1]) {\n            $changesNeeded++;\n        }\n    }\n    return $changesNeeded;\n}",
  "Ruby_humaneval-073": "def smallest_change(arr)\n  n = arr.length\n  changes_needed = 0\n  (n / 2).times { |i| changes_needed += 1 if arr[i] != arr[n - i - 1] }\n  changes_needed\nend",
  "Swift_humaneval-073": "func smallestChange(_ arr: [Int]) -> Int {\n  let n = arr.count\n  var changesNeeded = 0\n  for i in 0..<n / 2 {\n    if arr[i] != arr[n - i - 1] {\n      changesNeeded += 1\n    }\n  }\n  return changesNeeded\n}",
  "TypeScript_humaneval-073": "function smallestChange(arr: number[]): number {\n  const n = arr.length;\n  let changesNeeded = 0;\n  for (let i = 0; i < n / 2; i++) {\n    if (arr[i] !== arr[n - i - 1]) {\n      changesNeeded++;\n    }\n  }\n  return changesNeeded;\n}",
  "Dart_humaneval-073": "int smallestChange(List<int> arr) {\n  int n = arr.length;\n  int changesNeeded = 0;\n  for (int i = 0; i < n ~/ 2; i++) {\n    if (arr[i] != arr[n - i - 1]) {\n      changesNeeded++;\n    }\n  }\n  return changesNeeded;\n}",
  "Rust_humaneval-073": "fn smallest_change(arr: Vec<i32>) -> i32 {\n    let n = arr.len();\n    let mut changes_needed = 0;\n    for i in 0..n / 2 {\n        if arr[i] != arr[n - i - 1] {\n            changes_needed += 1;\n        }\n    }\n    changes_needed\n}",
  "Scala_humaneval-073": "def smallestChange(arr: List[Int]): Int = {\n  val n = arr.length\n  var changesNeeded = 0\n  for (i <- 0 until n / 2) {\n    if (arr(i) != arr(n - i - 1)) {\n      changesNeeded += 1\n    }\n  }\n  changesNeeded\n}",
  "Kotlin_humaneval-073": "fun smallestChange(arr: List<Int>): Int {\n  val n = arr.size\n  var changesNeeded = 0\n  for (i in 0 until n / 2) {\n    if (arr[i] != arr[n - i - 1]) {\n      changesNeeded++\n    }\n  }\n  return changesNeeded\n}",
  "C++_humaneval-074": "vector<string> totalMatch(vector<string> l1, vector<string> l2) {\n  int total_chars_l1 = 0, total_chars_l2 = 0;\n  for (string s : l1) {\n    total_chars_l1 += s.length();\n  }\n  for (string s : l2) {\n    total_chars_l2 += s.length();\n  }\n  if (total_chars_l1 <= total_chars_l2) {\n    return l1;\n  } else {\n    return l2;\n  }\n}",
  "Java_humaneval-074": "public static List<String> totalMatch(List<String> l1, List<String> l2) {\n  int totalCharsL1 = l1.stream().mapToInt(String::length).sum();\n  int totalCharsL2 = l2.stream().mapToInt(String::length).sum();\n  if (totalCharsL1 <= totalCharsL2) {\n    return l1;\n  } else {\n    return l2;\n  }\n}",
  "Python_humaneval-074": "def total_match(l1: List[str], l2: List[str]) -> List[str]:\n    total_chars_l1 = sum(len(s) for s in l1)\n    total_chars_l2 = sum(len(s) for s in l2)\n    if total_chars_l1 <= total_chars_l2:\n        return l1\n    else:\n        return l2",
  "C#_humaneval-074": "public static List<string> TotalMatch(List<string> l1, List<string> l2) {\n  int total_chars_l1 = l1.Sum(s => s.Length);\n  int total_chars_l2 = l2.Sum(s => s.Length);\n  if (total_chars_l1 <= total_chars_l2) {\n    return l1;\n  } else {\n    return l2;\n  }\n}",
  "JavaScript_humaneval-074": "function totalMatch(l1, l2) {\n  let totalCharsL1 = l1.reduce((acc, s) => acc + s.length, 0);\n  let totalCharsL2 = l2.reduce((acc, s) => acc + s.length, 0);\n  if (totalCharsL1 <= totalCharsL2) {\n    return l1;\n  } else {\n    return l2;\n  }\n}",
  "Go_humaneval-074": "func totalMatch(l1 []string, l2 []string) []string {\n    totalCharsL1 := 0\n    for _, s := range l1 {\n        totalCharsL1 += len(s)\n    }\n    totalCharsL2 := 0\n    for _, s := range l2 {\n        totalCharsL2 += len(s)\n    }\n    if totalCharsL1 <= totalCharsL2 {\n        return l1\n    } else {\n        return l2\n    }\n}",
  "PHP_humaneval-074": "function totalMatch(array $l1, array $l2): array {\n    $total_chars_l1 = array_reduce($l1, function($acc, $str) {\n        return $acc + strlen($str);\n    }, 0);\n    $total_chars_l2 = array_reduce($l2, function($acc, $str) {\n        return $acc + strlen($str);\n    }, 0);\n    if ($total_chars_l1 <= $total_chars_l2) {\n        return $l1;\n    } else {\n        return $l2;\n    }\n}",
  "Ruby_humaneval-074": "def total_match(l1, l2)\n  total_chars_l1 = l1.sum(&:length)\n  total_chars_l2 = l2.sum(&:length)\n  total_chars_l1 <= total_chars_l2 ? l1 : l2\nend",
  "Swift_humaneval-074": "func totalMatch(_ l1: [String], _ l2: [String]) -> [String] {\n  let totalCharsL1 = l1.reduce(0) { $0 + $1.count }\n  let totalCharsL2 = l2.reduce(0) { $0 + $1.count }\n  if totalCharsL1 <= totalCharsL2 {\n    return l1\n  } else {\n    return l2\n  }\n}",
  "TypeScript_humaneval-074": "function totalMatch(l1: string[], l2: string[]): string[] {\n  const totalCharsL1 = l1.reduce((total, s) => total + s.length, 0);\n  const totalCharsL2 = l2.reduce((total, s) => total + s.length, 0);\n  return totalCharsL1 <= totalCharsL2 ? l1 : l2;\n}",
  "Dart_humaneval-074": "List<String> totalMatch(List<String> l1, List<String> l2) {\n  int totalCharsL1 = l1.fold(0, (sum, s) => sum + s.length);\n  int totalCharsL2 = l2.fold(0, (sum, s) => sum + s.length);\n  if (totalCharsL1 <= totalCharsL2) {\n    return l1;\n  } else {\n    return l2;\n  }\n}",
  "Rust_humaneval-074": "fn total_match(l1: Vec<String>, l2: Vec<String>) -> Vec<String> {\n    let total_chars_l1: usize = l1.iter().map(|s| s.len()).sum();\n    let total_chars_l2: usize = l2.iter().map(|s| s.len()).sum();\n    if total_chars_l1 <= total_chars_l2 {\n        l1\n    } else {\n        l2\n    }\n}",
  "Scala_humaneval-074": "def totalMatch(l1: List[String], l2: List[String]): List[String] = {\n  val totalCharsL1 = l1.map(_.length).sum\n  val totalCharsL2 = l2.map(_.length).sum\n  if (totalCharsL1 <= totalCharsL2) l1 else l2\n}",
  "Kotlin_humaneval-074": "fun totalMatch(l1: List<String>, l2: List<String>): List<String> {\n  val totalCharsL1 = l1.sumBy { it.length }\n  val totalCharsL2 = l2.sumBy { it.length }\n  return if (totalCharsL1 <= totalCharsL2) l1 else l2\n}",
  "C++_humaneval-075": "bool isPrime(int num) {\n  if (num < 2) {\n    return false;\n  }\n  for (int i = 2; i <= sqrt(num); i++) {\n    if (num % i == 0) {\n      return false;\n    }\n  }\n  return true;\n}\nbool isMultiplyPrime(int a) {\n  if (a < 2) {\n    return false;\n  }\n  vector<int> prime_factors;\n  for (int i = 2; i <= a; i++) {\n    if (isPrime(i)) {\n      while (a % i == 0) {\n        prime_factors.push_back(i);\n        a /= i;\n      }\n    }\n  }\n  return prime_factors.size() == 3;\n}",
  "Java_humaneval-075": "public static boolean isPrime(int num) {\n  if (num < 2) {\n    return false;\n  }\n  for (int i = 2; i <= Math.sqrt(num); i++) {\n    if (num % i == 0) {\n      return false;\n    }\n  }\n  return true;\n}\npublic static Boolean isMultiplyPrime(Integer a) {\n  if (a < 2) {\n    return false;\n  }\n  List<Integer> primeFactors = new ArrayList<>();\n  for (int i = 2; i <= a; i++) {\n    if (isPrime(i)) {\n      while (a % i == 0) {\n        primeFactors.add(i);\n        a /= i;\n      }\n    }\n  }\n  return primeFactors.size() == 3;\n}",
  "Python_humaneval-075": "def is_prime(num):\n    if num < 2:\n        return False\n    for i in range(2, int(num**0.5) + 1):\n        if num % i == 0:\n            return False\n    return True\ndef is_multiply_prime(a: int) -> bool:\n    if a < 2:\n        return False\n    prime_factors = []\n    for i in range(2, a + 1):\n        if is_prime(i):\n            while a % i == 0:\n                prime_factors.append(i)\n                a //= i\n    return len(prime_factors) == 3",
  "C#_humaneval-075": "public static bool IsPrime(int num) {\n  if (num < 2) {\n    return false;\n  }\n  for (int i = 2; i <= Math.Sqrt(num); i++) {\n    if (num % i == 0) {\n      return false;\n    }\n  }\n  return true;\n}\npublic static bool IsMultiplyPrime(int a) {\n  if (a < 2) {\n    return false;\n  }\n  List<int> primeFactors = new List<int>();\n  for (int i = 2; i <= a; i++) {\n    if (IsPrime(i)) {\n      while (a % i == 0) {\n        primeFactors.Add(i);\n        a /= i;\n      }\n    }\n  }\n  return primeFactors.Count == 3;\n}",
  "JavaScript_humaneval-075": "function is_prime(num) {\n  if (num < 2) {\n    return false;\n  }\n  for (let i = 2; i <= Math.sqrt(num); i++) {\n    if (num % i === 0) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction isMultiplyPrime(a) {\n  if (a < 2) {\n    return false;\n  }\n  const primeFactors = [];\n  for (let i = 2; i <= a; i++) {\n    if (is_prime(i)) {\n      while (a % i === 0) {\n        primeFactors.push(i);\n        a /= i;\n      }\n    }\n  }\n  return primeFactors.length === 3;\n}",
  "Go_humaneval-075": "func isPrime(num int) bool {\n    if num < 2 {\n        return false\n    }\n    for i := 2; i*i <= num; i++ {\n        if num%i == 0 {\n            return false\n        }\n    }\n    return true\n}\nfunc isMultiplyPrime(a int) bool {\n    if a < 2 {\n        return false\n    }\n    primeFactors := []int{}\n    for i := 2; i <= a; i++ {\n        if isPrime(i) {\n            for a%i == 0 {\n                primeFactors = append(primeFactors, i)\n                a /= i\n            }\n        }\n    }\n    return len(primeFactors) == 3\n}",
  "PHP_humaneval-075": "function is_prime($num) {\n    if ($num < 2) {\n        return false;\n    }\n    for ($i = 2; $i <= sqrt($num); $i++) {\n        if ($num % $i == 0) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction isMultiplyPrime(int $a): bool {\n    if ($a < 2) {\n        return false;\n    }\n    $prime_factors = [];\n    for ($i = 2; $i <= $a; $i++) {\n        if (is_prime($i)) {\n            while ($a % $i == 0) {\n                $prime_factors[] = $i;\n                $a /= $i;\n            }\n        }\n    }\n    return count($prime_factors) == 3;\n}",
  "Ruby_humaneval-075": "def is_prime(num)\n  return false if num < 2\n  (2..(num**0.5).to_i).each { |i| return false if num % i == 0 }\n  true\nend\ndef is_multiply_prime(a)\n  return false if a < 2\n  prime_factors = []\n  (2..a).each do |i|\n    if is_prime(i)\n      while a % i == 0\n        prime_factors << i\n        a /= i\n      end\n    end\n  end\n  prime_factors.length == 3\nend",
  "Swift_humaneval-075": "func isPrime(_ num: Int) -> Bool {\n  if num < 2 {\n    return false\n  }\n  for i in 2..<Int(1 + sqrt(Double(num))) {\n    if num % i == 0 {\n      return false\n    }\n  }\n  return true\n}\nfunc isMultiplyPrime(_ a: Int) -> Bool {\n  if a < 2 {\n    return false\n  }\n  var primeFactors = [Int]()\n  var a1 = a\n  for i in 2...a {\n    if isPrime(i) {\n      while a1 % i == 0 {\n        primeFactors.append(i)\n        a1 /= i\n      }\n    }\n  }\n  return primeFactors.count == 3\n}",
  "TypeScript_humaneval-075": "function isPrime(num: number): boolean {\n  if (num < 2) {\n    return false;\n  }\n  for (let i = 2; i <= Math.sqrt(num); i++) {\n    if (num % i === 0) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction isMultiplyPrime(a: number): boolean {\n  if (a < 2) {\n    return false;\n  }\n  const primeFactors: number[] = [];\n  for (let i = 2; i <= a; i++) {\n    if (isPrime(i)) {\n      while (a % i === 0) {\n        primeFactors.push(i);\n        a /= i;\n      }\n    }\n  }\n  return primeFactors.length === 3;\n}",
  "Dart_humaneval-075": "bool isPrime(int num) {\n  if (num < 2) {\n    return false;\n  }\n  for (int i = 2; i <= sqrt(num); i++) {\n    if (num % i == 0) {\n      return false;\n    }\n  }\n  return true;\n}\nbool isMultiplyPrime(int a) {\n  if (a < 2) {\n    return false;\n  }\n  List<int> primeFactors = [];\n  for (int i = 2; i <= a; i++) {\n    if (isPrime(i)) {\n      while (a % i == 0) {\n        primeFactors.add(i);\n        a ~/= i;\n      }\n    }\n  }\n  return primeFactors.length == 3;\n}",
  "Rust_humaneval-075": "fn is_prime(num: i32) -> bool {\n    if num < 2 {\n        return false;\n    }\n    for i in 2..=(num as f64).sqrt() as i32 {\n        if num % i == 0 {\n            return false;\n        }\n    }\n    true\n}\nfn is_multiply_prime(a: i32) -> bool {\n    if a < 2 {\n        return false;\n    }\n    let mut prime_factors = Vec::new();\n    let mut a1 = a;\n    for i in 2..=a {\n        if is_prime(i) {\n            while a1 % i == 0 {\n                prime_factors.push(i);\n                a1 /= i;\n            }\n        }\n    }\n    prime_factors.len() == 3\n}",
  "Scala_humaneval-075": "def isPrime(num: Int): Boolean = {\n  if (num < 2) {\n    false\n  } else {\n    (2 to sqrt(num).toInt).forall(i => num % i != 0)\n  }\n}\ndef isMultiplyPrime(a: Int): Boolean = {\n  if (a < 2) {\n    false\n  } else {\n    var primeFactors = List[Int]()\n    for (i <- 2 to a) {\n      if (isPrime(i)) {\n        var temp = a\n        while (temp % i == 0) {\n          primeFactors = primeFactors :+ i\n          temp /= i\n        }\n      }\n    }\n    primeFactors.length == 3\n  }\n}",
  "Kotlin_humaneval-075": "fun isPrime(num: Int): Boolean {\n  if (num < 2) {\n    return false\n  }\n  for (i in 2..(num.toDouble().pow(0.5)).toInt()) {\n    if (num % i == 0) {\n      return false\n    }\n  }\n  return true\n}\nfun isMultiplyPrime(a: Int): Boolean {\n  if (a < 2) {\n    return false\n  }\n  val primeFactors = mutableListOf<Int>()\n  var a1 = a\n  for (i in 2..a) {\n    if (isPrime(i)) {\n      while (a1 % i == 0) {\n        primeFactors.add(i)\n        a1 /= i\n      }\n    }\n  }\n  return primeFactors.size == 3\n}",
  "C++_humaneval-076": "bool isSimplePower(int x, int n) {\n  if (x == 1) {\n    return true;\n  } else if (n == 1) {\n    return false;\n  }\n  int i = 1;\n  while (i <= x) {\n    if (i == x) {\n      return true;\n    }\n    i *= n;\n  }\n  return false;\n}",
  "Java_humaneval-076": "public static Boolean isSimplePower(Integer x, Integer n) {\n  if (x == 1) {\n    return true;\n  } else if (n == 1) {\n    return false;\n  }\n  int i = 1;\n  while (i <= x) {\n    if (i == x) {\n      return true;\n    }\n    i *= n;\n  }\n  return false;\n}",
  "Python_humaneval-076": "def is_simple_power(x: int, n: int) -> bool:\n    if x == 1:\n        return True\n    elif n == 1:\n        return False\n    i = 1\n    while i <= x:\n        if i == x:\n            return True\n        i *= n\n    return False",
  "C#_humaneval-076": "public static bool IsSimplePower(int x, int n) {\n  if (x == 1) {\n    return true;\n  } else if (n == 1) {\n    return false;\n  }\n  int i = 1;\n  while (i <= x) {\n    if (i == x) {\n      return true;\n    }\n    i *= n;\n  }\n  return false;\n}",
  "JavaScript_humaneval-076": "function isSimplePower(x, n) {\n  if (x === 1) {\n    return true;\n  } else if (n === 1) {\n    return false;\n  }\n  let i = 1;\n  while (i <= x) {\n    if (i === x) {\n      return true;\n    }\n    i *= n;\n  }\n  return false;\n}",
  "Go_humaneval-076": "func isSimplePower(x int, n int) bool {\n    if x == 1 {\n        return true\n    } else if n == 1 {\n        return false\n    }\n    i := 1\n    for i <= x {\n        if i == x {\n            return true\n        }\n        i *= n\n    }\n    return false\n}",
  "PHP_humaneval-076": "function isSimplePower(int $x, int $n): bool {\n    if ($x == 1) {\n        return true;\n    } elseif ($n == 1) {\n        return false;\n    }\n    $i = 1;\n    while ($i <= $x) {\n        if ($i == $x) {\n            return true;\n        }\n        $i *= $n;\n    }\n    return false;\n}",
  "Ruby_humaneval-076": "def is_simple_power(x, n)\n  return true if x == 1\n  return false if n == 1\n  i = 1\n  while i <= x\n    return true if i == x\n    i *= n\n  end\n  false\nend",
  "Swift_humaneval-076": "func isSimplePower(_ x: Int, _ n: Int) -> Bool {\n  if x == 1 {\n    return true\n  } else if n == 1 {\n    return false\n  }\n  var i = 1\n  while i <= x {\n    if i == x {\n      return true\n    }\n    i *= n\n  }\n  return false\n}",
  "TypeScript_humaneval-076": "function isSimplePower(x: number, n: number): boolean {\n  if (x === 1) {\n    return true;\n  } else if (n === 1) {\n    return false;\n  }\n  let i = 1;\n  while (i <= x) {\n    if (i === x) {\n      return true;\n    }\n    i *= n;\n  }\n  return false;\n}",
  "Dart_humaneval-076": "bool isSimplePower(int x, int n) {\n  if (x == 1) {\n    return true;\n  } else if (n == 1) {\n    return false;\n  }\n  int i = 1;\n  while (i <= x) {\n    if (i == x) {\n      return true;\n    }\n    i *= n;\n  }\n  return false;\n}",
  "Rust_humaneval-076": "fn is_simple_power(x: i32, n: i32) -> bool {\n    if x == 1 {\n        return true;\n    } else if n == 1 {\n        return false;\n    }\n    let mut i = 1;\n    while i <= x {\n        if i == x {\n            return true;\n        }\n        i *= n;\n    }\n    false\n}",
  "Scala_humaneval-076": "def isSimplePower(x: Int, n: Int): Boolean = {\n  if (x == 1) {\n    true\n  } else if (n == 1) {\n    false\n  } else {\n    var i = 1\n    while (i <= x) {\n      if (i == x) {\n        return true\n      }\n      i *= n\n    }\n    false\n  }\n}",
  "Kotlin_humaneval-076": "fun isSimplePower(x: Int, n: Int): Boolean {\n  if (x == 1) {\n    return true\n  } else if (n == 1) {\n    return false\n  }\n  var i = 1\n  while (i <= x) {\n    if (i == x) {\n      return true\n    }\n    i *= n\n  }\n  return false\n}",
  "C++_humaneval-077": "bool iscube(int a) {\n  if (a == 0) {\n    return true;\n  } else if (a < 0) {\n    a = -a;\n  }\n  double cube_root = pow(a, 1.0 / 3.0);\n  return pow(round(cube_root), 3) == a;\n}",
  "Java_humaneval-077": "public static Boolean iscube(Integer a) {\n  if (a == 0) {\n    return true;\n  } else if (a < 0) {\n    a = -a;\n  }\n  double cube_root = Math.pow(a, 1.0 / 3.0);\n  return Math.pow(Math.round(cube_root), 3) == a;\n}",
  "Python_humaneval-077": "def iscube(a: int) -> bool:\n    if a == 0:\n        return True\n    elif a < 0:\n        a = -a\n    cube_root = a ** (1 / 3)\n    return int(cube_root + 0.5) ** 3 == a",
  "C#_humaneval-077": "public static bool Iscube(int a) {\n  if (a == 0) {\n    return true;\n  } else if (a < 0) {\n    a = -a;\n  }\n  double cube_root = Math.Pow(a, 1.0 / 3.0);\n  return (int)(cube_root + 0.5) * (int)(cube_root + 0.5) * (int)(cube_root + 0.5) == a;\n}",
  "JavaScript_humaneval-077": "function iscube(a) {\n  if (a === 0) {\n    return true;\n  } else if (a < 0) {\n    a = -a;\n  }\n  var cube_root = Math.pow(a, 1 / 3);\n  return Math.round(cube_root) ** 3 === a;\n}",
  "Go_humaneval-077": "func iscube(a int) bool {\n    if a == 0 {\n        return true\n    } else if a < 0 {\n        a = -a\n    }\n    cubeRoot := math.Pow(float64(a), 1.0/3.0)\n    return int(cubeRoot+0.5)*int(cubeRoot+0.5)*int(cubeRoot+0.5) == a\n}",
  "PHP_humaneval-077": "function iscube(int $a): bool {\n    if ($a == 0) {\n        return true;\n    } elseif ($a < 0) {\n        $a = -$a;\n    }\n    $cube_root = pow($a, 1/3);\n    return pow((int)($cube_root + 0.5), 3) == $a;\n}",
  "Ruby_humaneval-077": "def iscube(a)\n  if a == 0\n    return true\n  elsif a < 0\n    a = -a\n  end\n  cube_root = a**(1.0 / 3)\n  return (cube_root + 0.5).to_i**3 == a\nend",
  "Swift_humaneval-077": "func iscube(_ a: Int) -> Bool {\n  if a == 0 {\n    return true\n  } else if a < 0 {\n    var a = -a\n    let cubeRoot = pow(Double(a), 1.0 / 3.0)\n    return Int(cubeRoot + 0.5) * Int(cubeRoot + 0.5) * Int(cubeRoot + 0.5) == a\n  } else {\n    let cubeRoot = pow(Double(a), 1.0 / 3.0)\n    return Int(cubeRoot + 0.5) * Int(cubeRoot + 0.5) * Int(cubeRoot + 0.5) == a\n  }\n}",
  "TypeScript_humaneval-077": "function iscube(a: number): boolean {\n  if (a === 0) {\n    return true;\n  } else if (a < 0) {\n    a = -a;\n  }\n  const cube_root = Math.pow(a, 1 / 3);\n  return Math.round(cube_root) ** 3 === a;\n}",
  "Dart_humaneval-077": "bool iscube(int a) {\n  if (a == 0) {\n    return true;\n  } else if (a < 0) {\n    a = -a;\n  }\n  double cubeRoot = pow(a, 1 / 3) as double;\n  return (cubeRoot.round() * cubeRoot.round() * cubeRoot.round()) == a;\n}",
  "Rust_humaneval-077": "fn iscube(a: i32) -> bool {\n    let mut abs_a = a;\n    if a == 0 {\n        return true;\n    } else if a < 0 {\n        abs_a = -a;\n    }\n    let cube_root = (abs_a as f64).powf(1.0 / 3.0);\n    (cube_root.round() as i32).pow(3) == abs_a\n}",
  "Scala_humaneval-077": "def iscube(a: Int): Boolean = {\n  if (a == 0) {\n    true\n  } else {\n    var abs_a = a\n    if (a < 0) {\n      abs_a = -a\n    }\n    val cube_root = pow(abs_a, 1.0 / 3.0)\n    pow(round(cube_root).toInt, 3) == abs_a\n  }\n}",
  "Kotlin_humaneval-077": "fun iscube(a: Int): Boolean {\n  return when {\n    a == 0 -> true\n    a < 0 -> {\n      val absA = -a\n      val cubeRoot = Math.cbrt(absA.toDouble())\n      (Math.round(cubeRoot) * Math.round(cubeRoot) * Math.round(cubeRoot)).toInt() == absA\n    }\n    else -> {\n      val cubeRoot = Math.cbrt(a.toDouble())\n      (Math.round(cubeRoot) * Math.round(cubeRoot) * Math.round(cubeRoot)).toInt() == a\n    }\n  }\n}",
  "C++_humaneval-078": "int hexKey(string num) {\n  string primes = \"2357BD\";\n  int count = 0;\n  for (char digit : num) {\n    if (primes.find(digit) != string::npos) {\n      count++;\n    }\n  }\n  return count;\n}",
  "Java_humaneval-078": "public static Integer hexKey(String num) {\n  String[] primes = {\"2\", \"3\", \"5\", \"7\", \"B\", \"D\"};\n  int count = 0;\n  for (int i = 0; i < num.length(); i++) {\n    if (Arrays.asList(primes).contains(String.valueOf(num.charAt(i)))) {\n      count++;\n    }\n  }\n  return count;\n}",
  "Python_humaneval-078": "def hex_key(num: str) -> int:\n    primes = [\"2\", \"3\", \"5\", \"7\", \"B\", \"D\"]\n    count = 0\n    for digit in num:\n        if digit in primes:\n            count += 1\n    return count",
  "C#_humaneval-078": "public static int HexKey(string num) {\n  string[] primes = { \"2\", \"3\", \"5\", \"7\", \"B\", \"D\" };\n  int count = 0;\n  foreach (char digit in num) {\n    if (primes.Contains(digit.ToString())) {\n      count++;\n    }\n  }\n  return count;\n}",
  "JavaScript_humaneval-078": "function hexKey(num) {\n  const primes = [\"2\", \"3\", \"5\", \"7\", \"B\", \"D\"];\n  let count = 0;\n  for (const digit of num) {\n    if (primes.includes(digit)) {\n      count += 1;\n    }\n  }\n  return count;\n}",
  "Go_humaneval-078": "func hexKey(num string) int {\n    primes := []string{\"2\", \"3\", \"5\", \"7\", \"B\", \"D\"}\n    count := 0\n    for _, digit := range num {\n        if string(digit) == primes[0] || string(digit) == primes[1] || string(digit) == primes[2] || string(digit) == primes[3] || string(digit) == primes[4] || string(digit) == primes[5] {\n            count++\n        }\n    }\n    return count\n}",
  "PHP_humaneval-078": "function hexKey(string $num): int {\n    $primes = [\"2\", \"3\", \"5\", \"7\", \"B\", \"D\"];\n    $count = 0;\n    for ($i = 0; $i < strlen($num); $i++) {\n        if (in_array($num[$i], $primes)) {\n            $count++;\n        }\n    }\n    return $count;\n}",
  "Ruby_humaneval-078": "def hex_key(num)\n  primes = %w[2 3 5 7 B D]\n  count = 0\n  num.each_char { |digit| count += 1 if primes.include?(digit) }\n  return count\nend",
  "Swift_humaneval-078": "func hexKey(_ num: String) -> Int {\n  let primes = [\"2\", \"3\", \"5\", \"7\", \"B\", \"D\"]\n  var count = 0\n  for digit in num {\n    if primes.contains(String(digit)) {\n      count += 1\n    }\n  }\n  return count\n}",
  "TypeScript_humaneval-078": "function hexKey(num: string): number {\n  const primes = [\"2\", \"3\", \"5\", \"7\", \"B\", \"D\"];\n  let count = 0;\n  for (const digit of num) {\n    if (primes.includes(digit)) {\n      count += 1;\n    }\n  }\n  return count;\n}",
  "Dart_humaneval-078": "int hexKey(String num) {\n  List<String> primes = [\"2\", \"3\", \"5\", \"7\", \"B\", \"D\"];\n  int count = 0;\n  for (var digit in num.split('')) {\n    if (primes.contains(digit)) {\n      count += 1;\n    }\n  }\n  return count;\n}",
  "Rust_humaneval-078": "fn hex_key(num: String) -> i32 {\n    let primes = vec![\"2\", \"3\", \"5\", \"7\", \"B\", \"D\"];\n    let mut count = 0;\n    for digit in num.chars() {\n        if primes.contains(&digit.to_string().as_str()) {\n            count += 1;\n        }\n    }\n    count\n}",
  "Scala_humaneval-078": "def hexKey(num: String): Int = {\n  val primes = Set(\"2\", \"3\", \"5\", \"7\", \"B\", \"D\")\n  var count = 0\n  for (digit <- num) {\n    if (primes.contains(digit.toString)) {\n      count += 1\n    }\n  }\n  count\n}",
  "Kotlin_humaneval-078": "fun hexKey(num: String): Int {\n  val primes = listOf(\"2\", \"3\", \"5\", \"7\", \"B\", \"D\")\n  var count = 0\n  for (digit in num) {\n    if (digit.toString() in primes) {\n      count += 1\n    }\n  }\n  return count\n}",
  "C++_humaneval-079": "string decimalToBinary(int dec) {\n  bitset<32> binary(dec);\n  string binary_string = binary.to_string();\n  size_t start_pos = binary_string.find_first_not_of('0');\n  if (start_pos != string::npos) {\n    binary_string = binary_string.substr(start_pos);\n  } else {\n    binary_string = \"0\";\n  }\n  return \"db\" + binary_string + \"db\";\n}",
  "Java_humaneval-079": "public static String decimalToBinary(Integer dec) {\n  String binary = Integer.toBinaryString(dec);\n  return \"db\" + binary + \"db\";\n}",
  "Python_humaneval-079": "def decimal_to_binary(dec: int) -> str:\n    binary = bin(dec)[2:]\n    return f\"db{binary}db\"",
  "C#_humaneval-079": "public static string DecimalToBinary(int dec) {\n  string binary = Convert.ToString(dec, 2);\n  return $\"db{binary}db\";\n}",
  "JavaScript_humaneval-079": "function decimalToBinary(dec) {\n  let binary = dec.toString(2);\n  return `db${binary}db`;\n}",
  "Go_humaneval-079": "func decimalToBinary(dec int) string {\n    binary := strconv.FormatInt(int64(dec), 2)\n    return \"db\" + binary + \"db\"\n}",
  "PHP_humaneval-079": "function decimalToBinary(int $dec): string {\n    $binary = decbin($dec);\n    return \"db\" . $binary . \"db\";\n}",
  "Ruby_humaneval-079": "def decimal_to_binary(dec)\n  binary = dec.to_s(2)\n  \"db#{binary}db\"\nend",
  "Swift_humaneval-079": "func decimalToBinary(_ dec: Int) -> String {\n  let binary = String(dec, radix: 2)\n  return \"db\\(binary)db\"\n}",
  "TypeScript_humaneval-079": "function decimalToBinary(dec: number): string {\n  const binary = dec.toString(2);\n  return `db${binary}db`;\n}",
  "Dart_humaneval-079": "String decimalToBinary(int dec) {\n  String binary = dec.toRadixString(2);\n  return \"db$binary\" + \"db\";\n}",
  "Rust_humaneval-079": "fn decimal_to_binary(dec: i32) -> String {\n    let binary = format!(\"{:b}\", dec);\n    format!(\"db{}db\", binary)\n}",
  "Scala_humaneval-079": "def decimalToBinary(dec: Int): String = {\n  val binary = dec.toBinaryString\n  s\"db$binary\" + \"db\"\n}",
  "Kotlin_humaneval-079": "fun decimalToBinary(dec: Int): String {\n  val binary = Integer.toBinaryString(dec)\n  return \"db$binary\" + \"db\"\n}",
  "C++_humaneval-080": "bool isHappy(string s) {\n  if (s.length() < 3) {\n    return false;\n  }\n  for (int i = 0; i < s.length() - 2; i++) {\n    if (s[i] == s[i + 1] || s[i] == s[i + 2] || s[i + 1] == s[i + 2]) {\n      return false;\n    }\n  }\n  return true;\n}",
  "Java_humaneval-080": "public static Boolean isHappy(String s) {\n  if (s.length() < 3) {\n    return false;\n  }\n  for (int i = 0; i < s.length() - 2; i++) {\n    if (s.charAt(i) == s.charAt(i + 1) || s.charAt(i) == s.charAt(i + 2)\n        || s.charAt(i + 1) == s.charAt(i + 2)) {\n      return false;\n    }\n  }\n  return true;\n}",
  "Python_humaneval-080": "def is_happy(s: str) -> bool:\n    if len(s) < 3:\n        return False\n    for i in range(len(s) - 2):\n        if s[i] == s[i + 1] or s[i] == s[i + 2] or s[i + 1] == s[i + 2]:\n            return False\n    return True",
  "C#_humaneval-080": "public static bool IsHappy(string s) {\n  if (s.Length < 3) {\n    return false;\n  }\n  for (int i = 0; i < s.Length - 2; i++) {\n    if (s[i] == s[i + 1] || s[i] == s[i + 2] || s[i + 1] == s[i + 2]) {\n      return false;\n    }\n  }\n  return true;\n}",
  "JavaScript_humaneval-080": "function isHappy(s) {\n  if (s.length < 3) {\n    return false;\n  }\n  for (let i = 0; i < s.length - 2; i++) {\n    if (s[i] === s[i + 1] || s[i] === s[i + 2] || s[i + 1] === s[i + 2]) {\n      return false;\n    }\n  }\n  return true;\n}",
  "Go_humaneval-080": "func isHappy(s string) bool {\n    if len(s) < 3 {\n        return false\n    }\n    for i := 0; i < len(s)-2; i++ {\n        if s[i] == s[i+1] || s[i] == s[i+2] || s[i+1] == s[i+2] {\n            return false\n        }\n    }\n    return true\n}",
  "PHP_humaneval-080": "function isHappy(string $s): bool {\n    if (strlen($s) < 3) {\n        return false;\n    }\n    for ($i = 0; $i < strlen($s) - 2; $i++) {\n        if ($s[$i] == $s[$i + 1] || $s[$i] == $s[$i + 2] || $s[$i + 1] == $s[$i + 2]) {\n            return false;\n        }\n    }\n    return true;\n}",
  "Ruby_humaneval-080": "def is_happy(s)\n  return false if s.length < 3\n  (0..s.length - 3).each do |i|\n    return false if s[i] == s[i + 1] || s[i] == s[i + 2] || s[i + 1] == s[i + 2]\n  end\n  true\nend",
  "Swift_humaneval-080": "func isHappy(_ s: String) -> Bool {\n  if s.count < 3 {\n    return false\n  }\n  for i in 0..<(s.count - 2) {\n    let idx1 = s.index(s.startIndex, offsetBy: i)\n    let idx2 = s.index(s.startIndex, offsetBy: i + 1)\n    let idx3 = s.index(s.startIndex, offsetBy: i + 2)\n    if s[idx1] == s[idx2] || s[idx1] == s[idx3] || s[idx2] == s[idx3] {\n      return false\n    }\n  }\n  return true\n}",
  "TypeScript_humaneval-080": "function isHappy(s: string): boolean {\n  if (s.length < 3) {\n    return false;\n  }\n  for (let i = 0; i < s.length - 2; i++) {\n    if (s[i] === s[i + 1] || s[i] === s[i + 2] || s[i + 1] === s[i + 2]) {\n      return false;\n    }\n  }\n  return true;\n}",
  "Dart_humaneval-080": "bool isHappy(String s) {\n  if (s.length < 3) {\n    return false;\n  }\n  for (int i = 0; i < s.length - 2; i++) {\n    if (s[i] == s[i + 1] || s[i] == s[i + 2] || s[i + 1] == s[i + 2]) {\n      return false;\n    }\n  }\n  return true;\n}",
  "Rust_humaneval-080": "fn is_happy(s: String) -> bool {\n    if s.len() < 3 {\n        return false;\n    }\n    for i in 0..s.len() - 2 {\n        if s.chars().nth(i) == s.chars().nth(i + 1)\n            || s.chars().nth(i) == s.chars().nth(i + 2)\n            || s.chars().nth(i + 1) == s.chars().nth(i + 2)\n        {\n            return false;\n        }\n    }\n    return true;\n}",
  "Scala_humaneval-080": "def isHappy(s: String): Boolean = {\n  if (s.length < 3) {\n    return false\n  }\n  for (i <- 0 until s.length - 2) {\n    if (s(i) == s(i + 1) || s(i) == s(i + 2) || s(i + 1) == s(i + 2)) {\n      return false\n    }\n  }\n  true\n}",
  "Kotlin_humaneval-080": "fun isHappy(s: String): Boolean {\n  if (s.length < 3) {\n    return false\n  }\n  for (i in 0..s.length - 3) {\n    if (s[i] == s[i + 1] || s[i] == s[i + 2] || s[i + 1] == s[i + 2]) {\n      return false\n    }\n  }\n  return true\n}",
  "C++_humaneval-081": "vector<string> numericalLetterGrade(vector<double> grades) {\n  vector<string> letter_grades;\n  for (double grade : grades) {\n    if (grade == 4.0) {\n      letter_grades.push_back(\"A+\");\n    } else if (grade > 3.7) {\n      letter_grades.push_back(\"A\");\n    } else if (grade > 3.3) {\n      letter_grades.push_back(\"A-\");\n    } else if (grade > 3.0) {\n      letter_grades.push_back(\"B+\");\n    } else if (grade > 2.7) {\n      letter_grades.push_back(\"B\");\n    } else if (grade > 2.3) {\n      letter_grades.push_back(\"B-\");\n    } else if (grade > 2.0) {\n      letter_grades.push_back(\"C+\");\n    } else if (grade > 1.7) {\n      letter_grades.push_back(\"C\");\n    } else if (grade > 1.3) {\n      letter_grades.push_back(\"C-\");\n    } else if (grade > 1.0) {\n      letter_grades.push_back(\"D+\");\n    } else if (grade > 0.7) {\n      letter_grades.push_back(\"D\");\n    } else if (grade > 0.0) {\n      letter_grades.push_back(\"D-\");\n    } else {\n      letter_grades.push_back(\"E\");\n    }\n  }\n  return letter_grades;\n}",
  "Java_humaneval-081": "public static List<String> numericalLetterGrade(List<Double> grades) {\n  List<String> letterGrades = new ArrayList<>();\n  for (Double grade : grades) {\n    if (grade == 4.0) {\n      letterGrades.add(\"A+\");\n    } else if (grade > 3.7) {\n      letterGrades.add(\"A\");\n    } else if (grade > 3.3) {\n      letterGrades.add(\"A-\");\n    } else if (grade > 3.0) {\n      letterGrades.add(\"B+\");\n    } else if (grade > 2.7) {\n      letterGrades.add(\"B\");\n    } else if (grade > 2.3) {\n      letterGrades.add(\"B-\");\n    } else if (grade > 2.0) {\n      letterGrades.add(\"C+\");\n    } else if (grade > 1.7) {\n      letterGrades.add(\"C\");\n    } else if (grade > 1.3) {\n      letterGrades.add(\"C-\");\n    } else if (grade > 1.0) {\n      letterGrades.add(\"D+\");\n    } else if (grade > 0.7) {\n      letterGrades.add(\"D\");\n    } else if (grade > 0.0) {\n      letterGrades.add(\"D-\");\n    } else {\n      letterGrades.add(\"E\");\n    }\n  }\n  return letterGrades;\n}",
  "Python_humaneval-081": "def numerical_letter_grade(grades: List[float]) -> List[str]:\n    letter_grades = []\n    for grade in grades:\n        if grade == 4.0:\n            letter_grades.append(\"A+\")\n        elif grade > 3.7:\n            letter_grades.append(\"A\")\n        elif grade > 3.3:\n            letter_grades.append(\"A-\")\n        elif grade > 3.0:\n            letter_grades.append(\"B+\")\n        elif grade > 2.7:\n            letter_grades.append(\"B\")\n        elif grade > 2.3:\n            letter_grades.append(\"B-\")\n        elif grade > 2.0:\n            letter_grades.append(\"C+\")\n        elif grade > 1.7:\n            letter_grades.append(\"C\")\n        elif grade > 1.3:\n            letter_grades.append(\"C-\")\n        elif grade > 1.0:\n            letter_grades.append(\"D+\")\n        elif grade > 0.7:\n            letter_grades.append(\"D\")\n        elif grade > 0.0:\n            letter_grades.append(\"D-\")\n        else:\n            letter_grades.append(\"E\")\n    return letter_grades",
  "C#_humaneval-081": "public static List<string> NumericalLetterGrade(List<double> grades) {\n  List<string> letterGrades = new List<string>();\n  foreach (double grade in grades) {\n    if (grade == 4.0) {\n      letterGrades.Add(\"A+\");\n    } else if (grade > 3.7) {\n      letterGrades.Add(\"A\");\n    } else if (grade > 3.3) {\n      letterGrades.Add(\"A-\");\n    } else if (grade > 3.0) {\n      letterGrades.Add(\"B+\");\n    } else if (grade > 2.7) {\n      letterGrades.Add(\"B\");\n    } else if (grade > 2.3) {\n      letterGrades.Add(\"B-\");\n    } else if (grade > 2.0) {\n      letterGrades.Add(\"C+\");\n    } else if (grade > 1.7) {\n      letterGrades.Add(\"C\");\n    } else if (grade > 1.3) {\n      letterGrades.Add(\"C-\");\n    } else if (grade > 1.0) {\n      letterGrades.Add(\"D+\");\n    } else if (grade > 0.7) {\n      letterGrades.Add(\"D\");\n    } else if (grade > 0.0) {\n      letterGrades.Add(\"D-\");\n    } else {\n      letterGrades.Add(\"E\");\n    }\n  }\n  return letterGrades;\n}",
  "JavaScript_humaneval-081": "function numericalLetterGrade(grades) {\n  let letterGrades = [];\n  for (let i = 0; i < grades.length; i++) {\n    let grade = grades[i];\n    if (grade === 4.0) {\n      letterGrades.push(\"A+\");\n    } else if (grade > 3.7) {\n      letterGrades.push(\"A\");\n    } else if (grade > 3.3) {\n      letterGrades.push(\"A-\");\n    } else if (grade > 3.0) {\n      letterGrades.push(\"B+\");\n    } else if (grade > 2.7) {\n      letterGrades.push(\"B\");\n    } else if (grade > 2.3) {\n      letterGrades.push(\"B-\");\n    } else if (grade > 2.0) {\n      letterGrades.push(\"C+\");\n    } else if (grade > 1.7) {\n      letterGrades.push(\"C\");\n    } else if (grade > 1.3) {\n      letterGrades.push(\"C-\");\n    } else if (grade > 1.0) {\n      letterGrades.push(\"D+\");\n    } else if (grade > 0.7) {\n      letterGrades.push(\"D\");\n    } else if (grade > 0.0) {\n      letterGrades.push(\"D-\");\n    } else {\n      letterGrades.push(\"E\");\n    }\n  }\n  return letterGrades;\n}",
  "Go_humaneval-081": "func numericalLetterGrade(grades []float64) []string {\n    var letterGrades []string\n    for _, grade := range grades {\n        switch {\n        case grade == 4.0:\n            letterGrades = append(letterGrades, \"A+\")\n        case grade > 3.7:\n            letterGrades = append(letterGrades, \"A\")\n        case grade > 3.3:\n            letterGrades = append(letterGrades, \"A-\")\n        case grade > 3.0:\n            letterGrades = append(letterGrades, \"B+\")\n        case grade > 2.7:\n            letterGrades = append(letterGrades, \"B\")\n        case grade > 2.3:\n            letterGrades = append(letterGrades, \"B-\")\n        case grade > 2.0:\n            letterGrades = append(letterGrades, \"C+\")\n        case grade > 1.7:\n            letterGrades = append(letterGrades, \"C\")\n        case grade > 1.3:\n            letterGrades = append(letterGrades, \"C-\")\n        case grade > 1.0:\n            letterGrades = append(letterGrades, \"D+\")\n        case grade > 0.7:\n            letterGrades = append(letterGrades, \"D\")\n        case grade > 0.0:\n            letterGrades = append(letterGrades, \"D-\")\n        default:\n            letterGrades = append(letterGrades, \"E\")\n        }\n    }\n    return letterGrades\n}",
  "PHP_humaneval-081": "function numericalLetterGrade(array $grades): array {\n    $letterGrades = [];\n    foreach ($grades as $grade) {\n        if ($grade == 4.0) {\n            $letterGrades[] = \"A+\";\n        } elseif ($grade > 3.7) {\n            $letterGrades[] = \"A\";\n        } elseif ($grade > 3.3) {\n            $letterGrades[] = \"A-\";\n        } elseif ($grade > 3.0) {\n            $letterGrades[] = \"B+\";\n        } elseif ($grade > 2.7) {\n            $letterGrades[] = \"B\";\n        } elseif ($grade > 2.3) {\n            $letterGrades[] = \"B-\";\n        } elseif ($grade > 2.0) {\n            $letterGrades[] = \"C+\";\n        } elseif ($grade > 1.7) {\n            $letterGrades[] = \"C\";\n        } elseif ($grade > 1.3) {\n            $letterGrades[] = \"C-\";\n        } elseif ($grade > 1.0) {\n            $letterGrades[] = \"D+\";\n        } elseif ($grade > 0.7) {\n            $letterGrades[] = \"D\";\n        } elseif ($grade > 0.0) {\n            $letterGrades[] = \"D-\";\n        } else {\n            $letterGrades[] = \"E\";\n        }\n    }\n    return $letterGrades;\n}",
  "Ruby_humaneval-081": "def numerical_letter_grade(grades)\n  letter_grades = []\n  grades.each do |grade|\n    if grade == 4.0\n      letter_grades << \"A+\"\n    elsif grade > 3.7\n      letter_grades << \"A\"\n    elsif grade > 3.3\n      letter_grades << \"A-\"\n    elsif grade > 3.0\n      letter_grades << \"B+\"\n    elsif grade > 2.7\n      letter_grades << \"B\"\n    elsif grade > 2.3\n      letter_grades << \"B-\"\n    elsif grade > 2.0\n      letter_grades << \"C+\"\n    elsif grade > 1.7\n      letter_grades << \"C\"\n    elsif grade > 1.3\n      letter_grades << \"C-\"\n    elsif grade > 1.0\n      letter_grades << \"D+\"\n    elsif grade > 0.7\n      letter_grades << \"D\"\n    elsif grade > 0.0\n      letter_grades << \"D-\"\n    else\n      letter_grades << \"E\"\n    end\n  end\n  letter_grades\nend",
  "Swift_humaneval-081": "func numericalLetterGrade(_ grades: [Double]) -> [String] {\n  var letterGrades = [String]()\n  for grade in grades {\n    if grade == 4.0 {\n      letterGrades.append(\"A+\")\n    } else if grade > 3.7 {\n      letterGrades.append(\"A\")\n    } else if grade > 3.3 {\n      letterGrades.append(\"A-\")\n    } else if grade > 3.0 {\n      letterGrades.append(\"B+\")\n    } else if grade > 2.7 {\n      letterGrades.append(\"B\")\n    } else if grade > 2.3 {\n      letterGrades.append(\"B-\")\n    } else if grade > 2.0 {\n      letterGrades.append(\"C+\")\n    } else if grade > 1.7 {\n      letterGrades.append(\"C\")\n    } else if grade > 1.3 {\n      letterGrades.append(\"C-\")\n    } else if grade > 1.0 {\n      letterGrades.append(\"D+\")\n    } else if grade > 0.7 {\n      letterGrades.append(\"D\")\n    } else if grade > 0.0 {\n      letterGrades.append(\"D-\")\n    } else {\n      letterGrades.append(\"E\")\n    }\n  }\n  return letterGrades\n}",
  "TypeScript_humaneval-081": "function numericalLetterGrade(grades: number[]): string[] {\n  const letterGrades: string[] = [];\n  for (const grade of grades) {\n    if (grade === 4.0) {\n      letterGrades.push(\"A+\");\n    } else if (grade > 3.7) {\n      letterGrades.push(\"A\");\n    } else if (grade > 3.3) {\n      letterGrades.push(\"A-\");\n    } else if (grade > 3.0) {\n      letterGrades.push(\"B+\");\n    } else if (grade > 2.7) {\n      letterGrades.push(\"B\");\n    } else if (grade > 2.3) {\n      letterGrades.push(\"B-\");\n    } else if (grade > 2.0) {\n      letterGrades.push(\"C+\");\n    } else if (grade > 1.7) {\n      letterGrades.push(\"C\");\n    } else if (grade > 1.3) {\n      letterGrades.push(\"C-\");\n    } else if (grade > 1.0) {\n      letterGrades.push(\"D+\");\n    } else if (grade > 0.7) {\n      letterGrades.push(\"D\");\n    } else if (grade > 0.0) {\n      letterGrades.push(\"D-\");\n    } else {\n      letterGrades.push(\"E\");\n    }\n  }\n  return letterGrades;\n}",
  "Dart_humaneval-081": "List<String> numericalLetterGrade(List<double> grades) {\n  List<String> letterGrades = [];\n  for (double grade in grades) {\n    if (grade == 4.0) {\n      letterGrades.add(\"A+\");\n    } else if (grade > 3.7) {\n      letterGrades.add(\"A\");\n    } else if (grade > 3.3) {\n      letterGrades.add(\"A-\");\n    } else if (grade > 3.0) {\n      letterGrades.add(\"B+\");\n    } else if (grade > 2.7) {\n      letterGrades.add(\"B\");\n    } else if (grade > 2.3) {\n      letterGrades.add(\"B-\");\n    } else if (grade > 2.0) {\n      letterGrades.add(\"C+\");\n    } else if (grade > 1.7) {\n      letterGrades.add(\"C\");\n    } else if (grade > 1.3) {\n      letterGrades.add(\"C-\");\n    } else if (grade > 1.0) {\n      letterGrades.add(\"D+\");\n    } else if (grade > 0.7) {\n      letterGrades.add(\"D\");\n    } else if (grade > 0.0) {\n      letterGrades.add(\"D-\");\n    } else {\n      letterGrades.add(\"E\");\n    }\n  }\n  return letterGrades;\n}",
  "Rust_humaneval-081": "fn numerical_letter_grade(grades: Vec<f64>) -> Vec<String> {\n    let mut letter_grades = Vec::new();\n    for grade in grades {\n        if grade == 4.0 {\n            letter_grades.push(\"A+\".to_string());\n        } else if grade > 3.7 {\n            letter_grades.push(\"A\".to_string());\n        } else if grade > 3.3 {\n            letter_grades.push(\"A-\".to_string());\n        } else if grade > 3.0 {\n            letter_grades.push(\"B+\".to_string());\n        } else if grade > 2.7 {\n            letter_grades.push(\"B\".to_string());\n        } else if grade > 2.3 {\n            letter_grades.push(\"B-\".to_string());\n        } else if grade > 2.0 {\n            letter_grades.push(\"C+\".to_string());\n        } else if grade > 1.7 {\n            letter_grades.push(\"C\".to_string());\n        } else if grade > 1.3 {\n            letter_grades.push(\"C-\".to_string());\n        } else if grade > 1.0 {\n            letter_grades.push(\"D+\".to_string());\n        } else if grade > 0.7 {\n            letter_grades.push(\"D\".to_string());\n        } else if grade > 0.0 {\n            letter_grades.push(\"D-\".to_string());\n        } else {\n            letter_grades.push(\"E\".to_string());\n        }\n    }\n    letter_grades\n}",
  "Scala_humaneval-081": "def numericalLetterGrade(grades: List[Double]): List[String] = {\n  var letterGrades = List[String]()\n  for (grade <- grades) {\n    if (grade == 4.0) {\n      letterGrades :+= \"A+\"\n    } else if (grade > 3.7) {\n      letterGrades :+= \"A\"\n    } else if (grade > 3.3) {\n      letterGrades :+= \"A-\"\n    } else if (grade > 3.0) {\n      letterGrades :+= \"B+\"\n    } else if (grade > 2.7) {\n      letterGrades :+= \"B\"\n    } else if (grade > 2.3) {\n      letterGrades :+= \"B-\"\n    } else if (grade > 2.0) {\n      letterGrades :+= \"C+\"\n    } else if (grade > 1.7) {\n      letterGrades :+= \"C\"\n    } else if (grade > 1.3) {\n      letterGrades :+= \"C-\"\n    } else if (grade > 1.0) {\n      letterGrades :+= \"D+\"\n    } else if (grade > 0.7) {\n      letterGrades :+= \"D\"\n    } else if (grade > 0.0) {\n      letterGrades :+= \"D-\"\n    } else {\n      letterGrades :+= \"E\"\n    }\n  }\n  letterGrades\n}",
  "Kotlin_humaneval-081": "fun numericalLetterGrade(grades: List<Double>): List<String> {\n  val letterGrades = mutableListOf<String>()\n  for (grade in grades) {\n    when {\n      grade == 4.0 -> letterGrades.add(\"A+\")\n      grade > 3.7 -> letterGrades.add(\"A\")\n      grade > 3.3 -> letterGrades.add(\"A-\")\n      grade > 3.0 -> letterGrades.add(\"B+\")\n      grade > 2.7 -> letterGrades.add(\"B\")\n      grade > 2.3 -> letterGrades.add(\"B-\")\n      grade > 2.0 -> letterGrades.add(\"C+\")\n      grade > 1.7 -> letterGrades.add(\"C\")\n      grade > 1.3 -> letterGrades.add(\"C-\")\n      grade > 1.0 -> letterGrades.add(\"D+\")\n      grade > 0.7 -> letterGrades.add(\"D\")\n      grade > 0.0 -> letterGrades.add(\"D-\")\n      else -> letterGrades.add(\"E\")\n    }\n  }\n  return letterGrades\n}",
  "C++_humaneval-082": "bool primeLength(string s) {\n  int length = s.length();\n  if (length < 2) {\n    return false;\n  }\n  for (int i = 2; i <= sqrt(length); i++) {\n    if (length % i == 0) {\n      return false;\n    }\n  }\n  return true;\n}",
  "Java_humaneval-082": "public static Boolean primeLength(String s) {\n  int length = s.length();\n  if (length < 2) {\n    return false;\n  }\n  for (int i = 2; i <= Math.sqrt(length); i++) {\n    if (length % i == 0) {\n      return false;\n    }\n  }\n  return true;\n}",
  "Python_humaneval-082": "def prime_length(s: str) -> bool:\n    length = len(s)\n    if length < 2:\n        return False\n    for i in range(2, int(math.sqrt(length)) + 1):\n        if length % i == 0:\n            return False\n    return True",
  "C#_humaneval-082": "public static bool PrimeLength(string s) {\n  int length = s.Length;\n  if (length < 2) {\n    return false;\n  }\n  for (int i = 2; i <= Math.Sqrt(length); i++) {\n    if (length % i == 0) {\n      return false;\n    }\n  }\n  return true;\n}",
  "JavaScript_humaneval-082": "function primeLength(s) {\n  let length = s.length;\n  if (length < 2) {\n    return false;\n  }\n  for (let i = 2; i <= Math.sqrt(length); i++) {\n    if (length % i === 0) {\n      return false;\n    }\n  }\n  return true;\n}",
  "Go_humaneval-082": "func primeLength(s string) bool {\n    length := len(s)\n    if length < 2 {\n        return false\n    }\n    for i := 2; i <= int(math.Sqrt(float64(length))); i++ {\n        if length%i == 0 {\n            return false\n        }\n    }\n    return true\n}",
  "PHP_humaneval-082": "function primeLength(string $s): bool {\n    $length = strlen($s);\n    if ($length < 2) {\n        return false;\n    }\n    for ($i = 2; $i <= sqrt($length); $i++) {\n        if ($length % $i == 0) {\n            return false;\n        }\n    }\n    return true;\n}",
  "Ruby_humaneval-082": "def prime_length(s)\n  length = s.length\n  return false if length < 2\n  (2..Math.sqrt(length).to_i).each { |i| return false if length % i == 0 }\n  true\nend",
  "Swift_humaneval-082": "func primeLength(_ s: String) -> Bool {\n  let length = s.count\n  if length < 2 {\n    return false\n  }\n  for i in 2..<Int(1 + sqrt(Double(length))) {\n    if length % i == 0 {\n      return false\n    }\n  }\n  return true\n}",
  "TypeScript_humaneval-082": "function primeLength(s: string): boolean {\n  const length = s.length;\n  if (length < 2) {\n    return false;\n  }\n  for (let i = 2; i <= Math.sqrt(length); i++) {\n    if (length % i === 0) {\n      return false;\n    }\n  }\n  return true;\n}",
  "Dart_humaneval-082": "bool primeLength(String s) {\n  int length = s.length;\n  if (length < 2) {\n    return false;\n  }\n  for (int i = 2; i <= sqrt(length); i++) {\n    if (length % i == 0) {\n      return false;\n    }\n  }\n  return true;\n}",
  "Rust_humaneval-082": "fn prime_length(s: String) -> bool {\n    let length = s.len();\n    if length < 2 {\n        return false;\n    }\n    for i in 2..=(length as f64).sqrt().floor() as usize {\n        if length % i == 0 {\n            return false;\n        }\n    }\n    true\n}",
  "Scala_humaneval-082": "def primeLength(s: String): Boolean = {\n  val length = s.length()\n  if (length < 2) {\n    false\n  } else {\n    for (i <- 2 to sqrt(length).toInt) {\n      if (length % i == 0) {\n        return false\n      }\n    }\n    true\n  }\n}",
  "Kotlin_humaneval-082": "fun primeLength(s: String): Boolean {\n  val length = s.length\n  if (length < 2) {\n    return false\n  }\n  for (i in 2..sqrt(length.toDouble()).toInt()) {\n    if (length % i == 0) {\n      return false\n    }\n  }\n  return true\n}",
  "C++_humaneval-083": "int startsOneEnds(int n) {\n  if (n == 1) {\n    return 1;\n  }\n  return 2 * 9 * pow(10, n - 2);\n}",
  "Java_humaneval-083": "public static Integer startsOneEnds(Integer n) {\n  if (n == 1) {\n    return 1;\n  }\n  return 2 * 9 * (int) Math.pow(10, n - 2);\n}",
  "Python_humaneval-083": "def starts_one_ends(n: int) -> int:\n    if n == 1:\n        return 1\n    return 2 * 9 * (10 ** (n - 2))",
  "C#_humaneval-083": "public static int StartsOneEnds(int n) {\n  if (n == 1) {\n    return 1;\n  }\n  return 2 * 9 * (int)Math.Pow(10, n - 2);\n}",
  "JavaScript_humaneval-083": "function startsOneEnds(n) {\n  if (n === 1) {\n    return 1;\n  }\n  return 2 * 9 * Math.pow(10, n - 2);\n}",
  "Go_humaneval-083": "func startsOneEnds(n int) int {\n    if n == 1 {\n        return 1\n    }\n    return 2 * 9 * int(math.Pow10(n-2))\n}",
  "PHP_humaneval-083": "function startsOneEnds(int $n): int {\n    if ($n == 1) {\n        return 1;\n    }\n    return 2 * 9 * (10 ** ($n - 2));\n}",
  "Ruby_humaneval-083": "def starts_one_ends(n)\n  return 1 if n == 1\n  return 2 * 9 * (10**(n - 2))\nend",
  "Swift_humaneval-083": "func startsOneEnds(_ n: Int) -> Int {\n  if n == 1 {\n    return 1\n  }\n  return 2 * 9 * Int(pow(10.0, Double(n - 2)))\n}",
  "TypeScript_humaneval-083": "function startsOneEnds(n: number): number {\n  if (n === 1) {\n    return 1;\n  }\n  return 2 * 9 * 10 ** (n - 2);\n}",
  "Dart_humaneval-083": "int startsOneEnds(int n) {\n  if (n == 1) {\n    return 1;\n  }\n  return 2 * 9 * (pow(10, n - 2) as int);\n}",
  "Rust_humaneval-083": "fn starts_one_ends(n: i32) -> i32 {\n    if n == 1 {\n        return 1;\n    }\n    return 2 * 9 * (10_i32.pow((n - 2) as u32));\n}",
  "Scala_humaneval-083": "def startsOneEnds(n: Int): Int = {\n  if (n == 1) {\n    1\n  } else {\n    2 * 9 * pow(10, n - 2).toInt\n  }\n}",
  "Kotlin_humaneval-083": "fun startsOneEnds(n: Int): Int {\n  if (n == 1) {\n    return 1\n  }\n  return 2 * 9 * (10.0.pow(n - 2)).toInt()\n}",
  "C++_humaneval-084": "string solve(int n) {\n  string digits = to_string(n);\n  int sum = 0;\n  for (char d : digits) {\n    sum += d - '0';\n  }\n  string binary_sum = bitset<32>(sum).to_string();\n  return binary_sum.substr(binary_sum.find('1'));\n}",
  "Java_humaneval-084": "public static String solve(Integer n) {\n  List<String> digits = Arrays.asList(String.valueOf(n).split(\"\"));\n  int sum = digits.stream().mapToInt(Integer::valueOf).sum();\n  String binarySum = Integer.toBinaryString(sum);\n  return binarySum;\n}",
  "Python_humaneval-084": "def solve(n: int) -> str:\n    digits = list(str(n))\n    binary_sum = bin(sum(int(d) for d in digits))\n    return binary_sum[2:]",
  "C#_humaneval-084": "public static string Solve(int n) {\n  List<char> digits = n.ToString().ToList();\n  string binarySum = Convert.ToString(digits.Sum(d => int.Parse(d.ToString())), 2);\n  return binarySum;\n}",
  "JavaScript_humaneval-084": "function solve(n) {\n  const digits = Array.from(String(n), Number);\n  const sum = digits.reduce((acc, cur) => acc + cur, 0);\n  const binarySum = sum.toString(2);\n  return binarySum;\n}",
  "Go_humaneval-084": "func solve(n int) string {\n    digits := strconv.Itoa(n)\n    sum := 0\n    for _, d := range digits {\n        digit, _ := strconv.Atoi(string(d))\n        sum += digit\n    }\n    binarySum := strconv.FormatInt(int64(sum), 2)\n    return binarySum\n}",
  "PHP_humaneval-084": "function solve(int $n): string {\n    $digits = str_split(strval($n));\n    $sum = array_sum($digits);\n    $binary_sum = decbin($sum);\n    return $binary_sum;\n}",
  "Ruby_humaneval-084": "def solve(n)\n  digits = n.to_s.chars.map(&:to_i)\n  binary_sum = (digits.sum).to_s(2)\n  return binary_sum\nend",
  "Swift_humaneval-084": "func solve(_ n: Int) -> String {\n  let digits = Array(String(n))\n  let sum = digits.reduce(0) { $0 + Int(String($1))! }\n  let binarySum = String(sum, radix: 2)\n  return binarySum\n}",
  "TypeScript_humaneval-084": "function solve(n: number): string {\n  const digits = Array.from(n.toString()).map(Number);\n  const binarySum = digits.reduce((a, b) => a + b, 0).toString(2);\n  return binarySum;\n}",
  "Dart_humaneval-084": "String solve(int n) {\n  List<String> digits = n.toString().split('');\n  String binarySum =\n      (digits.map(int.parse).reduce((a, b) => a + b)).toRadixString(2);\n  return binarySum;\n}",
  "Rust_humaneval-084": "fn solve(n: i32) -> String {\n    let digits: Vec<char> = n.to_string().chars().collect();\n    let sum: u32 = digits.iter().map(|d| d.to_digit(10).unwrap()).sum();\n    let binary_sum = format!(\"{:b}\", sum);\n    binary_sum\n}",
  "Scala_humaneval-084": "def solve(n: Int): String = {\n  val digits = n.toString.map(_.asDigit)\n  val binarySum = (digits.sum).toBinaryString\n  binarySum\n}",
  "Kotlin_humaneval-084": "fun solve(n: Int): String {\n  val digits = n.toString().toList()\n  val binarySum = Integer.toBinaryString(digits.map { it.toString().toInt() }.sum())\n  return binarySum\n}",
  "C++_humaneval-085": "int add(vector<int> l) {\n  int total = 0;\n  for (int i = 1; i < l.size(); i += 2) {\n    if (l[i] % 2 == 0) {\n      total += l[i];\n    }\n  }\n  return total;\n}",
  "Java_humaneval-085": "public static Integer add(List<Integer> l) {\n  int total = 0;\n  for (int i = 1; i < l.size(); i += 2) {\n    if (l.get(i) % 2 == 0) {\n      total += l.get(i);\n    }\n  }\n  return total;\n}",
  "Python_humaneval-085": "def add(l: List[int]) -> int:\n    total = 0\n    for i in range(1, len(l), 2):\n        if l[i] % 2 == 0:\n            total += l[i]\n    return total",
  "C#_humaneval-085": "public static int Add(List<int> l) {\n  int total = 0;\n  for (int i = 1; i < l.Count; i += 2) {\n    if (l[i] % 2 == 0) {\n      total += l[i];\n    }\n  }\n  return total;\n}",
  "JavaScript_humaneval-085": "function add(l) {\n  let total = 0;\n  for (let i = 1; i < l.length; i += 2) {\n    if (l[i] % 2 === 0) {\n      total += l[i];\n    }\n  }\n  return total;\n}",
  "Go_humaneval-085": "func add(l []int) int {\n    total := 0\n    for i := 1; i < len(l); i += 2 {\n        if l[i]%2 == 0 {\n            total += l[i]\n        }\n    }\n    return total\n}",
  "PHP_humaneval-085": "function add(array $l): int {\n    $total = 0;\n    for ($i = 1; $i < count($l); $i += 2) {\n        if ($l[$i] % 2 == 0) {\n            $total += $l[$i];\n        }\n    }\n    return $total;\n}",
  "Ruby_humaneval-085": "def add(l)\n  total = 0\n  for i in (1...l.length).step(2)\n    total += l[i] if l[i] % 2 == 0\n  end\n  return total\nend",
  "Swift_humaneval-085": "func add(_ l: [Int]) -> Int {\n  var total = 0\n  for i in stride(from: 1, to: l.count, by: 2) {\n    if l[i] % 2 == 0 {\n      total += l[i]\n    }\n  }\n  return total\n}",
  "TypeScript_humaneval-085": "function add(l: number[]): number {\n  let total = 0;\n  for (let i = 1; i < l.length; i += 2) {\n    if (l[i] % 2 === 0) {\n      total += l[i];\n    }\n  }\n  return total;\n}",
  "Dart_humaneval-085": "int add(List<int> l) {\n  int total = 0;\n  for (int i = 1; i < l.length; i += 2) {\n    if (l[i] % 2 == 0) {\n      total += l[i];\n    }\n  }\n  return total;\n}",
  "Rust_humaneval-085": "fn add(l: Vec<i32>) -> i32 {\n    let mut total = 0;\n    for i in (1..l.len()).step_by(2) {\n        if l[i] % 2 == 0 {\n            total += l[i];\n        }\n    }\n    total\n}",
  "Scala_humaneval-085": "def add(l: List[Int]): Int = {\n  var total = 0\n  for (i <- 1 until l.length by 2) {\n    if (l(i) % 2 == 0) {\n      total += l(i)\n    }\n  }\n  total\n}",
  "Kotlin_humaneval-085": "fun add(l: List<Int>): Int {\n  var total = 0\n  for (i in 1 until l.size step 2) {\n    if (l[i] % 2 == 0) {\n      total += l[i]\n    }\n  }\n  return total\n}",
  "C++_humaneval-086": "string antiShuffle(string s) {\n  vector<string> words;\n  string word = \"\";\n  for (char c : s) {\n    if (c == ' ') {\n      words.push_back(word);\n      word = \"\";\n    } else {\n      word += c;\n    }\n  }\n  words.push_back(word);\n  vector<string> ordered_words;\n  for (string w : words) {\n    sort(w.begin(), w.end());\n    ordered_words.push_back(w);\n  }\n  string result = \"\";\n  for (string w : ordered_words) {\n    result += w + \" \";\n  }\n  result.pop_back();\n  return result;\n}",
  "Java_humaneval-086": "public static String antiShuffle(String s) {\n  String[] words = s.split(\" \");\n  List<String> orderedWords = new ArrayList<>();\n  for (String word : words) {\n    char[] chars = word.toCharArray();\n    Arrays.sort(chars);\n    orderedWords.add(new String(chars));\n  }\n  return String.join(\" \", orderedWords);\n}",
  "Python_humaneval-086": "def anti_shuffle(s: str) -> str:\n    words = s.split()\n    ordered_words = []\n    for word in words:\n        ordered_word = \"\".join(sorted(word))\n        ordered_words.append(ordered_word)\n    return \" \".join(ordered_words)",
  "C#_humaneval-086": "public static string AntiShuffle(string s) {\n  string[] words = s.Split();\n  List<string> orderedWords = new List<string>();\n  foreach (string word in words) {\n    string orderedWord = new string(word.OrderBy(c => c).ToArray());\n    orderedWords.Add(orderedWord);\n  }\n  return string.Join(\" \", orderedWords);\n}",
  "JavaScript_humaneval-086": "function antiShuffle(s) {\n  let words = s.split(\" \");\n  let orderedWords = [];\n  for (let i = 0; i < words.length; i++) {\n    let orderedWord = words[i].split(\"\").sort().join(\"\");\n    orderedWords.push(orderedWord);\n  }\n  return orderedWords.join(\" \");\n}",
  "Go_humaneval-086": "func antiShuffle(s string) string {\n    words := strings.Split(s, \" \")\n    orderedWords := []string{}\n    for _, word := range words {\n        orderedWord := sortString(word)\n        orderedWords = append(orderedWords, orderedWord)\n    }\n    return strings.Join(orderedWords, \" \")\n}\nfunc sortString(w string) string {\n    s := strings.Split(w, \"\")\n    sort.Strings(s)\n    return strings.Join(s, \"\")\n}",
  "PHP_humaneval-086": "function antiShuffle(string $s): string {\n    $words = explode(\" \", $s);\n    $ordered_words = [];\n    foreach ($words as $word) {\n        $ordered_word = str_split($word);\n        sort($ordered_word);\n        $ordered_word = implode(\"\", $ordered_word);\n        $ordered_words[] = $ordered_word;\n    }\n    return implode(\" \", $ordered_words);\n}",
  "Ruby_humaneval-086": "def anti_shuffle(s)\n  words = s.split\n  ordered_words = []\n  words.each do |word|\n    ordered_word = word.chars.sort.join\n    ordered_words << ordered_word\n  end\n  ordered_words.join(\" \")\nend",
  "Swift_humaneval-086": "func antiShuffle(_ s: String) -> String {\n  let words = s.split(separator: \" \")\n  var orderedWords = [String]()\n  for word in words {\n    let orderedWord = String(word.sorted())\n    orderedWords.append(orderedWord)\n  }\n  return orderedWords.joined(separator: \" \")\n}",
  "TypeScript_humaneval-086": "function antiShuffle(s: string): string {\n  const words = s.split(\" \");\n  const orderedWords = [];\n  for (const word of words) {\n    const orderedWord = word.split(\"\").sort().join(\"\");\n    orderedWords.push(orderedWord);\n  }\n  return orderedWords.join(\" \");\n}",
  "Dart_humaneval-086": "String antiShuffle(String s) {\n  List<String> words = s.split(\" \");\n  List<String> orderedWords = [];\n  for (String word in words) {\n    String orderedWord = String.fromCharCodes(word.runes.toList()..sort());\n    orderedWords.add(orderedWord);\n  }\n  return orderedWords.join(\" \");\n}",
  "Rust_humaneval-086": "fn anti_shuffle(s: String) -> String {\n    let words: Vec<&str> = s.split_whitespace().collect();\n    let mut ordered_words = Vec::new();\n    for word in words {\n        let mut chars: Vec<char> = word.chars().collect();\n        chars.sort();\n        let ordered_word = chars.into_iter().collect::<String>();\n        ordered_words.push(ordered_word);\n    }\n    ordered_words.join(\" \")\n}",
  "Scala_humaneval-086": "def antiShuffle(s: String): String = {\n  val words = s.split(\" \")\n  val orderedWords = words.map(word => word.sorted)\n  orderedWords.mkString(\" \")\n}",
  "Kotlin_humaneval-086": "fun antiShuffle(s: String): String {\n  val words = s.split(\" \")\n  val orderedWords = mutableListOf<String>()\n  for (word in words) {\n    val orderedWord = word.toCharArray().sorted().joinToString(\"\")\n    orderedWords.add(orderedWord)\n  }\n  return orderedWords.joinToString(\" \")\n}",
  "C++_humaneval-087": "vector<vector<int>> getRow(vector<vector<int>> l, int x) {\n  vector<vector<int>> coordinates;\n  for (int i = 0; i < l.size(); i++) {\n    for (int j = 0; j < l[i].size(); j++) {\n      if (l[i][j] == x) {\n        coordinates.push_back({i, j});\n      }\n    }\n  }\n  sort(coordinates.begin(), coordinates.end(),\n       [](vector<int> a, vector<int> b) {\n         if (a[0] != b[0]) {\n           return a[0] < b[0];\n         } else {\n           return a[1] > b[1];\n         }\n       });\n  return coordinates;\n}",
  "Java_humaneval-087": "public static List<List<Integer>> getRow(List<List<Integer>> l, Integer x) {\n  List<List<Integer>> coordinates = new ArrayList<>();\n  for (int i = 0; i < l.size(); i++) {\n    for (int j = 0; j < l.get(i).size(); j++) {\n      if (l.get(i).get(j) == x) {\n        List<Integer> coordinate = new ArrayList<>();\n        coordinate.add(i);\n        coordinate.add(j);\n        coordinates.add(coordinate);\n      }\n    }\n  }\n  Collections.sort(coordinates, Comparator.comparingInt((List<Integer> a) -> a.get(1)).reversed());\n  Collections.sort(coordinates, Comparator.comparingInt((List<Integer> a) -> a.get(0)));\n  return coordinates;\n}",
  "Python_humaneval-087": "def get_row(l: List[List[int]], x: int) -> List[List[int]]:\n    coordinates = []\n    for i in range(len(l)):\n        for j in range(len(l[i])):\n            if l[i][j] == x:\n                coordinates.append([i, j])\n    coordinates.sort(key=lambda x: x[1], reverse=True)\n    coordinates.sort(key=lambda x: x[0])\n    return coordinates",
  "C#_humaneval-087": "public static List<List<int>> GetRow(List<List<int>> l, int x) {\n  List<List<int>> coordinates = new List<List<int>>();\n  for (int i = 0; i < l.Count; i++) {\n    for (int j = 0; j < l[i].Count; j++) {\n      if (l[i][j] == x) {\n        coordinates.Add(new List<int> { i, j });\n      }\n    }\n  }\n  coordinates.Sort((a, b) => {\n    if (a[0] == b[0]) {\n      return b[1].CompareTo(a[1]);\n    }\n    return a[0].CompareTo(b[0]);\n  });\n  return coordinates;\n}",
  "JavaScript_humaneval-087": "function getRow(l, x) {\n  let coordinates = [];\n  for (let i = 0; i < l.length; i++) {\n    for (let j = 0; j < l[i].length; j++) {\n      if (l[i][j] == x) {\n        coordinates.push([i, j]);\n      }\n    }\n  }\n  coordinates.sort((a, b) => {\n    if (a[0] !== b[0]) {\n      return a[0] - b[0];\n    }\n    return b[1] - a[1];\n  });\n  return coordinates;\n}",
  "Go_humaneval-087": "func getRow(l [][]int, x int) [][]int {\n    coordinates := [][]int{}\n    for i := 0; i < len(l); i++ {\n        for j := 0; j < len(l[i]); j++ {\n            if l[i][j] == x {\n                coordinates = append(coordinates, []int{i, j})\n            }\n        }\n    }\n    sort.Slice(coordinates, func(i, j int) bool {\n        if coordinates[i][0] == coordinates[j][0] {\n            return coordinates[i][1] > coordinates[j][1]\n        }\n        return coordinates[i][0] < coordinates[j][0]\n    })\n    return coordinates\n}",
  "PHP_humaneval-087": "function getRow(array $l, int $x): array {\n    $coordinates = [];\n    foreach ($l as $i => $row) {\n        foreach ($row as $j => $val) {\n            if ($val == $x) {\n                $coordinates[] = [$i, $j];\n            }\n        }\n    }\n    usort($coordinates, function($a, $b) {\n        return $a[0] <=> $b[0] ?: $b[1] <=> $a[1];\n    });\n    return $coordinates;\n}",
  "Ruby_humaneval-087": "def get_row(l, x)\n  coordinates = []\n  l.each_with_index do |row, i|\n    row.each_with_index { |value, j| coordinates << [i, j] if value == x }\n  end\n  coordinates.sort_by! { |x| [x[0], -x[1]] }\nend",
  "Swift_humaneval-087": "func getRow(_ l: [[Int]], _ x: Int) -> [[Int]] {\n  var coordinates = [[Int]]()\n  for i in 0..<l.count {\n    for j in 0..<l[i].count {\n      if l[i][j] == x {\n        coordinates.append([i, j])\n      }\n    }\n  }\n  coordinates.sort { $0[0] < $1[0] }\n  coordinates.sort { $0[1] > $1[1] }\n  return coordinates\n}",
  "TypeScript_humaneval-087": "function getRow(l: number[][], x: number): number[][] {\n  const coordinates: number[][] = [];\n  for (let i = 0; i < l.length; i++) {\n    for (let j = 0; j < l[i].length; j++) {\n      if (l[i][j] === x) {\n        coordinates.push([i, j]);\n      }\n    }\n  }\n  coordinates.sort((a, b) => {\n    if (a[0] === b[0]) {\n      return b[1] - a[1];\n    }\n    return a[0] - b[0];\n  });\n  return coordinates;\n}",
  "Dart_humaneval-087": "List<List<int>> getRow(List<List<int>> l, int x) {\n  List<List<int>> coordinates = [];\n  for (int i = 0; i < l.length; i++) {\n    for (int j = 0; j < l[i].length; j++) {\n      if (l[i][j] == x) {\n        coordinates.add([i, j]);\n      }\n    }\n  }\n  coordinates.sort((a, b) {\n    if (a[0] != b[0]) {\n      return a[0].compareTo(b[0]);\n    } else {\n      return b[1].compareTo(a[1]);\n    }\n  });\n  return coordinates;\n}",
  "Rust_humaneval-087": "fn get_row(l: Vec<Vec<i32>>, x: i32) -> Vec<Vec<i32>> {\n    let mut coordinates = Vec::new();\n    for i in 0..l.len() {\n        for j in 0..l[i].len() {\n            if l[i][j] == x {\n                coordinates.push(vec![i as i32, j as i32]);\n            }\n        }\n    }\n    coordinates.sort_by(|a, b| a[0].cmp(&b[0]).then_with(|| b[1].cmp(&a[1])));\n    coordinates\n}",
  "Scala_humaneval-087": "def getRow(l: List[List[Int]], x: Int): List[List[Int]] = {\n  var coordinates = List[List[Int]]()\n  for (i <- 0 until l.length) {\n    for (j <- 0 until l(i).length) {\n      if (l(i)(j) == x) {\n        coordinates = coordinates :+ List(i, j)\n      }\n    }\n  }\n  coordinates =\n    coordinates.sortWith((a, b) => a(0) < b(0) || (a(0) == b(0) && a(1) > b(1)))\n  coordinates\n}",
  "Kotlin_humaneval-087": "fun getRow(l: List<List<Int>>, x: Int): List<List<Int>> {\n  val coordinates = mutableListOf<List<Int>>()\n  for (i in l.indices) {\n    for (j in l[i].indices) {\n      if (l[i][j] == x) {\n        coordinates.add(listOf(i, j))\n      }\n    }\n  }\n  coordinates.sortWith(compareBy({ it[0] }, { -it[1] }))\n  return coordinates\n}",
  "C++_humaneval-088": "vector<int> sortArray(vector<int> arr) {\n  vector<int> sorted_arr = arr;\n  if (sorted_arr.size() <= 1) {\n    return sorted_arr;\n  }\n  if ((sorted_arr[0] + sorted_arr[sorted_arr.size() - 1]) % 2 == 0) {\n    sort(sorted_arr.rbegin(), sorted_arr.rend());\n  } else {\n    sort(sorted_arr.begin(), sorted_arr.end());\n  }\n  return sorted_arr;\n}",
  "Java_humaneval-088": "public static List<Integer> sortArray(List<Integer> arr) {\n  List<Integer> sortedArr = new ArrayList<>(arr);\n  if (sortedArr.size() <= 1) {\n    return sortedArr;\n  }\n  if ((sortedArr.get(0) + sortedArr.get(sortedArr.size() - 1)) % 2 == 0) {\n    Collections.sort(sortedArr, Collections.reverseOrder());\n  } else {\n    Collections.sort(sortedArr);\n  }\n  return sortedArr;\n}",
  "Python_humaneval-088": "def sort_array(arr: List[int]) -> List[int]:\n    sorted_arr = arr.copy()\n    if len(sorted_arr) <= 1:\n        return sorted_arr\n    if (sorted_arr[0] + sorted_arr[-1]) % 2 == 0:\n        sorted_arr.sort(reverse=True)\n    else:\n        sorted_arr.sort()\n    return sorted_arr",
  "C#_humaneval-088": "public static List<int> SortArray(List<int> arr) {\n  List<int> sortedArr = new List<int>(arr);\n  if (sortedArr.Count <= 1) {\n    return sortedArr;\n  }\n  if ((sortedArr[0] + sortedArr[^1]) % 2 == 0) {\n    sortedArr.Sort((x, y) => y.CompareTo(x));\n  } else {\n    sortedArr.Sort();\n  }\n  return sortedArr;\n}",
  "JavaScript_humaneval-088": "function sortArray(arr) {\n  let sortedArr = [...arr];\n  if (sortedArr.length <= 1) {\n    return sortedArr;\n  }\n  if ((sortedArr[0] + sortedArr[sortedArr.length - 1]) % 2 === 0) {\n    sortedArr.sort((a, b) => b - a);\n  } else {\n    sortedArr.sort((a, b) => a - b);\n  }\n  return sortedArr;\n}",
  "Go_humaneval-088": "func sortArray(arr []int) []int {\n    sortedArr := make([]int, len(arr))\n    copy(sortedArr, arr)\n    if len(sortedArr) <= 1 {\n        return sortedArr\n    }\n    if (sortedArr[0]+sortedArr[len(sortedArr)-1])%2 == 0 {\n        sort.Sort(sort.Reverse(sort.IntSlice(sortedArr)))\n    } else {\n        sort.Ints(sortedArr)\n    }\n    return sortedArr\n}",
  "PHP_humaneval-088": "function sortArray(array $arr): array {\n    $sorted_arr = $arr;\n    if (count($sorted_arr) <= 1) {\n        return $sorted_arr;\n    }\n    if (($sorted_arr[0] + $sorted_arr[count($sorted_arr)-1]) % 2 == 0) {\n        rsort($sorted_arr);\n    } else {\n        sort($sorted_arr);\n    }\n    return $sorted_arr;\n}",
  "Ruby_humaneval-088": "def sort_array(arr)\n  sorted_arr = arr.dup\n  return sorted_arr if sorted_arr.length <= 1\n  if (sorted_arr[0] + sorted_arr[-1]) % 2 == 0\n    sorted_arr.sort! { |a, b| b <=> a }\n  else\n    sorted_arr.sort!\n  end\n  return sorted_arr\nend",
  "Swift_humaneval-088": "func sortArray(_ arr: [Int]) -> [Int] {\n  var sortedArr = arr\n  if sortedArr.count <= 1 {\n    return sortedArr\n  }\n  if (sortedArr[0] + sortedArr[sortedArr.count - 1]) % 2 == 0 {\n    sortedArr.sort(by: >)\n  } else {\n    sortedArr.sort()\n  }\n  return sortedArr\n}",
  "TypeScript_humaneval-088": "function sortArray(arr: number[]): number[] {\n  const sortedArr = [...arr];\n  if (sortedArr.length <= 1) {\n    return sortedArr;\n  }\n  if ((sortedArr[0] + sortedArr[sortedArr.length - 1]) % 2 === 0) {\n    sortedArr.sort((a, b) => b - a);\n  } else {\n    sortedArr.sort((a, b) => a - b);\n  }\n  return sortedArr;\n}",
  "Dart_humaneval-088": "List<int> sortArray(List<int> arr) {\n  List<int> sortedArr = List.from(arr);\n  if (sortedArr.length <= 1) {\n    return sortedArr;\n  }\n  if ((sortedArr[0] + sortedArr[sortedArr.length - 1]) % 2 == 0) {\n    sortedArr.sort((a, b) => b.compareTo(a));\n  } else {\n    sortedArr.sort();\n  }\n  return sortedArr;\n}",
  "Rust_humaneval-088": "fn sort_array(arr: Vec<i32>) -> Vec<i32> {\n    let mut sorted_arr = arr.clone();\n    if sorted_arr.len() <= 1 {\n        return sorted_arr;\n    }\n    if (sorted_arr[0] + sorted_arr[sorted_arr.len() - 1]) % 2 == 0 {\n        sorted_arr.sort_by(|a, b| b.cmp(a));\n    } else {\n        sorted_arr.sort();\n    }\n    sorted_arr\n}",
  "Scala_humaneval-088": "def sortArray(arr: List[Int]): List[Int] = {\n  var sortedArr = arr\n  if (sortedArr.length <= 1) {\n    return sortedArr\n  }\n  if ((sortedArr.head + sortedArr.last) % 2 == 0) {\n    sortedArr = sortedArr.sorted.reverse\n  } else {\n    sortedArr = sortedArr.sorted\n  }\n  sortedArr\n}",
  "Kotlin_humaneval-088": "fun sortArray(arr: List<Int>): List<Int> {\n  val sortedArr = arr.toMutableList()\n  if (sortedArr.size <= 1) {\n    return sortedArr\n  }\n  if ((sortedArr[0] + sortedArr.last()) % 2 == 0) {\n    sortedArr.sortDescending()\n  } else {\n    sortedArr.sort()\n  }\n  return sortedArr\n}",
  "C++_humaneval-089": "string encrypt(string s) {\n  string result = \"\";\n  for (char& c : s) {\n    if (isalpha(c)) {\n      int shifted = c + 4;\n      if (shifted > 'z') {\n        shifted -= 26;\n      }\n      result += shifted;\n    } else {\n      result += c;\n    }\n  }\n  return result;\n}",
  "Java_humaneval-089": "public static String encrypt(String s) {\n  String result = \"\";\n  for (char c : s.toCharArray()) {\n    if (Character.isLetter(c)) {\n      int shifted = c + 4;\n      if (shifted > 'z') {\n        shifted -= 26;\n      }\n      result += (char) shifted;\n    } else {\n      result += c;\n    }\n  }\n  return result;\n}",
  "Python_humaneval-089": "def encrypt(s: str) -> str:\n    result = \"\"\n    for char in s:\n        if char.isalpha():\n            shifted = ord(char) + 4\n            if shifted > ord(\"z\"):\n                shifted -= 26\n            result += chr(shifted)\n        else:\n            result += char\n    return result",
  "C#_humaneval-089": "public static string Encrypt(string s) {\n  string result = \"\";\n  foreach (char c in s) {\n    if (Char.IsLetter(c)) {\n      int shifted = (int)c + 4;\n      if (shifted > (int)'z') {\n        shifted -= 26;\n      }\n      result += (char)shifted;\n    } else {\n      result += c;\n    }\n  }\n  return result;\n}",
  "JavaScript_humaneval-089": "function encrypt(s) {\n  let result = \"\";\n  for (let i = 0; i < s.length; i++) {\n    let char = s[i];\n    if (char.match(/[a-z]/i)) {\n      let shifted = char.charCodeAt(0) + 4;\n      if (shifted > 122) {\n        shifted -= 26;\n      }\n      result += String.fromCharCode(shifted);\n    } else {\n      result += char;\n    }\n  }\n  return result;\n}",
  "Go_humaneval-089": "func encrypt(s string) string {\n    result := \"\"\n    for _, char := range s {\n        if unicode.IsLetter(char) {\n            shifted := rune(char) + 4\n            if shifted > 'z' {\n                shifted -= 26\n            }\n            result += string(shifted)\n        } else {\n            result += string(char)\n        }\n    }\n    return result\n}",
  "PHP_humaneval-089": "function encrypt(string $s): string {\n    $result = \"\";\n    for ($i = 0; $i < strlen($s); $i++) {\n        $char = $s[$i];\n        if (ctype_alpha($char)) {\n            $shifted = ord($char) + 4;\n            if ($shifted > ord(\"z\")) {\n                $shifted -= 26;\n            }\n            $result .= chr($shifted);\n        } else {\n            $result .= $char;\n        }\n    }\n    return $result;\n}",
  "Ruby_humaneval-089": "def encrypt(s)\n  result = \"\"\n  s.each_char do |char|\n    if char.match?(/[a-zA-Z]/)\n      shifted = char.ord + 4\n      shifted -= 26 if shifted > \"z\".ord\n      result += shifted.chr\n    else\n      result += char\n    end\n  end\n  result\nend",
  "Swift_humaneval-089": "func encrypt(_ s: String) -> String {\n  var result = \"\"\n  for char in s {\n    if char.isLetter {\n      var shifted = char.asciiValue! + 4\n      if shifted > Character(\"z\").asciiValue! {\n        shifted -= 26\n      }\n      result += String(UnicodeScalar(shifted))\n    } else {\n      result += String(char)\n    }\n  }\n  return result\n}",
  "TypeScript_humaneval-089": "function encrypt(s: string): string {\n  let result = \"\";\n  for (let i = 0; i < s.length; i++) {\n    const char = s[i];\n    if (char.match(/[a-zA-Z]/)) {\n      let shifted = char.charCodeAt(0) + 4;\n      if (shifted > \"z\".charCodeAt(0)) {\n        shifted -= 26;\n      }\n      result += String.fromCharCode(shifted);\n    } else {\n      result += char;\n    }\n  }\n  return result;\n}",
  "Dart_humaneval-089": "String encrypt(String s) {\n  String result = \"\";\n  for (int i = 0; i < s.length; i++) {\n    String char = s[i];\n    if (char.contains(new RegExp(r'[a-zA-Z]'))) {\n      int shifted = char.codeUnitAt(0) + 4;\n      if (shifted > \"z\".codeUnitAt(0)) {\n        shifted -= 26;\n      }\n      result += String.fromCharCode(shifted);\n    } else {\n      result += char;\n    }\n  }\n  return result;\n}",
  "Rust_humaneval-089": "fn encrypt(s: String) -> String {\n    let mut result = String::new();\n    for char in s.chars() {\n        if char.is_alphabetic() {\n            let mut shifted = char as u8 + 4;\n            if shifted > b'z' {\n                shifted -= 26;\n            }\n            result.push(shifted as char);\n        } else {\n            result.push(char);\n        }\n    }\n    result\n}",
  "Scala_humaneval-089": "def encrypt(s: String): String = {\n  var result = \"\"\n  for (char <- s) {\n    if (char.isLetter) {\n      var shifted = char.toInt + 4\n      if (shifted > 'z') {\n        shifted -= 26\n      }\n      result += shifted.toChar\n    } else {\n      result += char\n    }\n  }\n  result\n}",
  "Kotlin_humaneval-089": "fun encrypt(s: String): String {\n  var result = \"\"\n  for (char in s) {\n    if (char.isLetter()) {\n      var shifted = char.toInt() + 4\n      if (shifted > 'z'.toInt()) {\n        shifted -= 26\n      }\n      result += shifted.toChar()\n    } else {\n      result += char\n    }\n  }\n  return result\n}",
  "C++_humaneval-090": "int nextSmallest(vector<int> l) {\n  if (l.size() < 2) {\n    return 0;\n  } else {\n    vector<int> unique_l(l);\n    sort(unique_l.begin(), unique_l.end());\n    unique_l.erase(unique(unique_l.begin(), unique_l.end()), unique_l.end());\n    if (unique_l.size() < 2) {\n      return 0;\n    } else {\n      return unique_l[1];\n    }\n  }\n}",
  "Java_humaneval-090": "public static Integer nextSmallest(List<Integer> l) {\n  if (l.size() < 2) {\n    return 0;\n  } else {\n    List<Integer> uniqueL = new ArrayList<>(new HashSet<>(l));\n    if (uniqueL.size() < 2) {\n      return 0;\n    } else {\n      Collections.sort(uniqueL);\n      return uniqueL.get(1);\n    }\n  }\n}",
  "Python_humaneval-090": "def next_smallest(l: List[int]) -> int:\n    if len(l) < 2:\n        return 0\n    else:\n        unique_l = list(set(l))\n        if len(unique_l) < 2:\n            return 0\n        else:\n            unique_l.sort()\n            return unique_l[1]",
  "C#_humaneval-090": "public static int NextSmallest(List<int> l) {\n  if (l.Count < 2) {\n    return 0;\n  } else {\n    List<int> unique_l = l.Distinct().ToList();\n    if (unique_l.Count < 2) {\n      return 0;\n    } else {\n      unique_l.Sort();\n      return unique_l[1];\n    }\n  }\n}",
  "JavaScript_humaneval-090": "function nextSmallest(l) {\n  if (l.length < 2) {\n    return 0;\n  } else {\n    let uniqueL = [...new Set(l)];\n    if (uniqueL.length < 2) {\n      return 0;\n    } else {\n      uniqueL.sort((a, b) => a - b);\n      return uniqueL[1];\n    }\n  }\n}",
  "Go_humaneval-090": "func nextSmallest(l []int) int {\n    if len(l) < 2 {\n        return 0\n    } else {\n        unique_l := make(map[int]bool)\n        for _, v := range l {\n            unique_l[v] = true\n        }\n        if len(unique_l) < 2 {\n            return 0\n        } else {\n            uniqueList := []int{}\n            for k := range unique_l {\n                uniqueList = append(uniqueList, k)\n            }\n            sort.Ints(uniqueList)\n            return uniqueList[1]\n        }\n    }\n}",
  "PHP_humaneval-090": "function nextSmallest(array $l): int {\n    if (count($l) < 2) {\n        return 0;\n    } else {\n        $unique_l = array_unique($l);\n        if (count($unique_l) < 2) {\n            return 0;\n        } else {\n            sort($unique_l);\n            return $unique_l[1];\n        }\n    }\n}",
  "Ruby_humaneval-090": "def next_smallest(l)\n  if l.length < 2\n    return 0\n  else\n    unique_l = l.uniq\n    if unique_l.length < 2\n      return 0\n    else\n      unique_l.sort!\n      return unique_l[1]\n    end\n  end\nend",
  "Swift_humaneval-090": "func nextSmallest(_ l: [Int]) -> Int {\n  if l.count < 2 {\n    return 0\n  } else {\n    let uniqueL = Array(Set(l))\n    if uniqueL.count < 2 {\n      return 0\n    } else {\n      let sortedL = uniqueL.sorted()\n      return sortedL[1]\n    }\n  }\n}",
  "TypeScript_humaneval-090": "function nextSmallest(l: number[]): number {\n  if (l.length < 2) {\n    return 0;\n  } else {\n    const unique_l = [...new Set(l)];\n    if (unique_l.length < 2) {\n      return 0;\n    } else {\n      unique_l.sort((a, b) => a - b);\n      return unique_l[1];\n    }\n  }\n}",
  "Dart_humaneval-090": "int nextSmallest(List<int> l) {\n  if (l.length < 2) {\n    return 0;\n  } else {\n    List<int> uniqueL = l.toSet().toList();\n    if (uniqueL.length < 2) {\n      return 0;\n    } else {\n      uniqueL.sort();\n      return uniqueL[1];\n    }\n  }\n}",
  "Rust_humaneval-090": "fn next_smallest(l: Vec<i32>) -> i32 {\n    if l.len() < 2 {\n        return 0;\n    } else {\n        let mut unique_l = l.clone();\n        unique_l.sort();\n        unique_l.dedup();\n        if unique_l.len() < 2 {\n            return 0;\n        } else {\n            return unique_l[1];\n        }\n    }\n}",
  "Scala_humaneval-090": "def nextSmallest(l: List[Int]): Int = {\n  if (l.length < 2) {\n    0\n  } else {\n    val uniqueL = l.distinct\n    if (uniqueL.length < 2) {\n      0\n    } else {\n      uniqueL.sorted.apply(1)\n    }\n  }\n}",
  "Kotlin_humaneval-090": "fun nextSmallest(l: List<Int>): Int {\n  if (l.size < 2) {\n    return 0\n  } else {\n    val uniqueL = l.toSet().toMutableList()\n    if (uniqueL.size < 2) {\n      return 0\n    } else {\n      uniqueL.sort()\n      return uniqueL[1]\n    }\n  }\n}",
  "C++_humaneval-091": "int isBored(string s) {\n  regex r(\"[.!?]\");\n  vector<string> sentences(sregex_token_iterator(s.begin(), s.end(), r, -1),\n                           sregex_token_iterator());\n  int count = 0;\n  for (string sentence : sentences) {\n    stringstream ss(sentence);\n    string word;\n    ss >> word;\n    if (word == \"I\") {\n      count += 1;\n    }\n  }\n  return count;\n}",
  "Java_humaneval-091": "public static Integer isBored(String s) {\n  String[] sentences = s.split(\"[.!?]\");\n  int count = 0;\n  for (String sentence : sentences) {\n    String[] words = sentence.trim().split(\"\\\\s+\");\n    if (words.length > 0 && words[0].equals(\"I\")) {\n      count++;\n    }\n  }\n  return count;\n}",
  "Python_humaneval-091": "def is_bored(s: str) -> int:\n    sentences = re.split(r\"[.!?]\", s)\n    count = 0\n    for sentence in sentences:\n        words = sentence.strip().split()\n        if words and words[0] == \"I\":\n            count += 1\n    return count",
  "C#_humaneval-091": "public static int IsBored(string s) {\n  string[] sentences = Regex.Split(s, @\"[.!?]\");\n  int count = 0;\n  foreach (string sentence in sentences) {\n    string[] words = sentence.Trim().Split();\n    if (words.Length > 0 && words[0] == \"I\") {\n      count++;\n    }\n  }\n  return count;\n}",
  "JavaScript_humaneval-091": "function isBored(s) {\n  const sentences = s.split(/[.!?]/);\n  let count = 0;\n  for (const sentence of sentences) {\n    const words = sentence.trim().split(\" \");\n    if (words.length > 0 && words[0] === \"I\") {\n      count++;\n    }\n  }\n  return count;\n}",
  "Go_humaneval-091": "func isBored(s string) int {\n    sentences := regexp.MustCompile(`[.!?]`).Split(s, -1)\n    count := 0\n    for _, sentence := range sentences {\n        words := strings.Fields(sentence)\n        if len(words) > 0 && words[0] == \"I\" {\n            count++\n        }\n    }\n    return count\n}",
  "PHP_humaneval-091": "function isBored(string $s): int {\n    $sentences = preg_split(\"/[.!?]/\", $s);\n    $count = 0;\n    foreach ($sentences as $sentence) {\n        $words = explode(\" \", trim($sentence));\n        if ($words && $words[0] == \"I\") {\n            $count += 1;\n        }\n    }\n    return $count;\n}",
  "Ruby_humaneval-091": "def is_bored(s)\n  sentences = s.split(/[.!?]/)\n  count = 0\n  sentences.each do |sentence|\n    words = sentence.strip.split\n    count += 1 if words[0] == \"I\"\n  end\n  count\nend",
  "Swift_humaneval-091": "func isBored(_ s: String) -> Int {\n  let sentences = s.split(whereSeparator: { \".?!\".contains($0) })\n  var count = 0\n  for sentence in sentences {\n    let words = sentence.trimmingCharacters(in: .whitespacesAndNewlines).split(separator: \" \")\n    if !words.isEmpty && words[0] == \"I\" {\n      count += 1\n    }\n  }\n  return count\n}",
  "TypeScript_humaneval-091": "function isBored(s: string): number {\n  const sentences = s.split(/[.!?]/);\n  let count = 0;\n  for (const sentence of sentences) {\n    const words = sentence.trim().split(\" \");\n    if (words.length > 0 && words[0] === \"I\") {\n      count++;\n    }\n  }\n  return count;\n}",
  "Dart_humaneval-091": "int isBored(String s) {\n  List<String> sentences = s.split(RegExp(r'[.!?]'));\n  int count = 0;\n  for (String sentence in sentences) {\n    List<String> words = sentence.trim().split(' ');\n    if (words.isNotEmpty && words[0] == 'I') {\n      count++;\n    }\n  }\n  return count;\n}",
  "Rust_humaneval-091": "fn is_bored(s: String) -> i32 {\n    let re = Regex::new(r\"[.!?]\").unwrap();\n    let sentences: Vec<&str> = re.split(&s).collect();\n    let mut count = 0;\n    for sentence in sentences {\n        let words: Vec<&str> = sentence.trim().split(' ').collect();\n        if !words.is_empty() && words[0] == \"I\" {\n            count += 1;\n        }\n    }\n    count\n}",
  "Scala_humaneval-091": "def isBored(s: String): Int = {\n  val sentences = s.split(\"[.!?]\")\n  var count = 0\n  for (sentence <- sentences) {\n    val words = sentence.trim.split(\" \")\n    if (words.nonEmpty && words(0) == \"I\") {\n      count += 1\n    }\n  }\n  count\n}",
  "Kotlin_humaneval-091": "fun isBored(s: String): Int {\n  val sentences = s.split(Regex(\"[.!?]\"))\n  var count = 0\n  for (sentence in sentences) {\n    val words = sentence.trim().split(\" \")\n    if (words.isNotEmpty() && words[0] == \"I\") {\n      count++\n    }\n  }\n  return count\n}",
  "C++_humaneval-093": "string encode(string message) {\n  string vowels = \"aeiouAEIOU\";\n  string encoded_message = \"\";\n  for (char letter : message) {\n    if (isalpha(letter)) {\n      if (vowels.find(letter) != string::npos) {\n        letter = static_cast<char>(letter + 2);\n      }\n      if (islower(letter)) {\n        encoded_message += toupper(letter);\n      } else {\n        encoded_message += tolower(letter);\n      }\n    } else {\n      encoded_message += letter;\n    }\n  }\n  return encoded_message;\n}",
  "Java_humaneval-093": "public static String encode(String message) {\n  String vowels = \"aeiouAEIOU\";\n  String encodedMessage = \"\";\n  for (char letter : message.toCharArray()) {\n    if (Character.isLetter(letter)) {\n      if (vowels.indexOf(letter) != -1) {\n        letter = (char) (letter + 2);\n      }\n      if (Character.isLowerCase(letter)) {\n        encodedMessage += Character.toUpperCase(letter);\n      } else {\n        encodedMessage += Character.toLowerCase(letter);\n      }\n    } else {\n      encodedMessage += letter;\n    }\n  }\n  return encodedMessage;\n}",
  "Python_humaneval-093": "def encode(message: str) -> str:\n    vowels = \"aeiouAEIOU\"\n    encoded_message = \"\"\n    for letter in message:\n        if letter.isalpha():\n            if letter in vowels:\n                letter = chr(ord(letter) + 2)\n            if letter.islower():\n                encoded_message += letter.upper()\n            else:\n                encoded_message += letter.lower()\n        else:\n            encoded_message += letter\n    return encoded_message",
  "C#_humaneval-093": "public static string Encode(string message) {\n  string vowels = \"aeiouAEIOU\";\n  string encodedMessage = \"\";\n  foreach (char letter in message) {\n    if (Char.IsLetter(letter)) {\n      char newLetter = letter;\n      if (vowels.Contains(letter)) {\n        newLetter = (char)(letter + 2);\n      }\n      if (Char.IsLower(letter)) {\n        encodedMessage += Char.ToUpper(newLetter);\n      } else {\n        encodedMessage += Char.ToLower(newLetter);\n      }\n    } else {\n      encodedMessage += letter;\n    }\n  }\n  return encodedMessage;\n}",
  "JavaScript_humaneval-093": "function encode(message) {\n  const vowels = \"aeiouAEIOU\";\n  let encoded_message = \"\";\n  for (let letter of message) {\n    if (letter.match(/[a-zA-Z]/)) {\n      if (vowels.includes(letter)) {\n        letter = String.fromCharCode(letter.charCodeAt(0) + 2);\n      }\n      if (letter === letter.toLowerCase()) {\n        encoded_message += letter.toUpperCase();\n      } else {\n        encoded_message += letter.toLowerCase();\n      }\n    } else {\n      encoded_message += letter;\n    }\n  }\n  return encoded_message;\n}",
  "Go_humaneval-093": "func encode(message string) string {\n    vowels := \"aeiouAEIOU\"\n    encodedMessage := \"\"\n    for _, letter := range message {\n        if unicode.IsLetter(letter) {\n            if strings.ContainsRune(vowels, letter) {\n                letter = letter + 2\n            }\n            if unicode.IsLower(letter) {\n                encodedMessage += strings.ToUpper(string(letter))\n            } else {\n                encodedMessage += strings.ToLower(string(letter))\n            }\n        } else {\n            encodedMessage += string(letter)\n        }\n    }\n    return encodedMessage\n}",
  "PHP_humaneval-093": "function encode(string $message): string {\n    $vowels = \"aeiouAEIOU\";\n    $encoded_message = \"\";\n    for ($i = 0; $i < strlen($message); $i++) {\n        $letter = $message[$i];\n        if (ctype_alpha($letter)) {\n            if (strpos($vowels, $letter) !== false) {\n                $letter = chr(ord($letter) + 2);\n            }\n            if (ctype_lower($letter)) {\n                $encoded_message .= strtoupper($letter);\n            } else {\n                $encoded_message .= strtolower($letter);\n            }\n        } else {\n            $encoded_message .= $letter;\n        }\n    }\n    return $encoded_message;\n}",
  "Ruby_humaneval-093": "def encode(message)\n  vowels = \"aeiouAEIOU\"\n  encoded_message = \"\"\n  message.each_char do |letter|\n    if letter.match?(/[a-zA-Z]/)\n      letter = (letter.ord + 2).chr if vowels.include?(letter)\n      if letter == letter.downcase\n        encoded_message += letter.upcase\n      else\n        encoded_message += letter.downcase\n      end\n    else\n      encoded_message += letter\n    end\n  end\n  encoded_message\nend",
  "Swift_humaneval-093": "func encode(_ message: String) -> String {\n  let vowels = \"aeiouAEIOU\"\n  var encodedMessage = \"\"\n  for letter in message {\n    if letter.isLetter {\n      var newLetter = letter\n      if vowels.contains(letter) {\n        newLetter = Character(UnicodeScalar(letter.asciiValue! + 2))\n      }\n      if letter.isLowercase {\n        encodedMessage += newLetter.uppercased()\n      } else {\n        encodedMessage += newLetter.lowercased()\n      }\n    } else {\n      encodedMessage += String(letter)\n    }\n  }\n  return encodedMessage\n}",
  "TypeScript_humaneval-093": "function encode(message: string): string {\n  const vowels = \"aeiouAEIOU\";\n  let encoded_message = \"\";\n  for (let letter of message) {\n    if (letter.match(/[a-zA-Z]/)) {\n      if (vowels.includes(letter)) {\n        letter = String.fromCharCode(letter.charCodeAt(0) + 2);\n      }\n      encoded_message +=\n        letter.toLowerCase() === letter\n          ? letter.toUpperCase()\n          : letter.toLowerCase();\n    } else {\n      encoded_message += letter;\n    }\n  }\n  return encoded_message;\n}",
  "Dart_humaneval-093": "String encode(String message) {\n  String vowels = \"aeiouAEIOU\";\n  String encodedMessage = \"\";\n  for (int i = 0; i < message.length; i++) {\n    String letter = message[i];\n    if (letter.contains(new RegExp(r'[a-zA-Z]'))) {\n      if (vowels.contains(letter)) {\n        letter = String.fromCharCode(letter.codeUnitAt(0) + 2);\n      }\n      if (letter == letter.toLowerCase()) {\n        encodedMessage += letter.toUpperCase();\n      } else {\n        encodedMessage += letter.toLowerCase();\n      }\n    } else {\n      encodedMessage += letter;\n    }\n  }\n  return encodedMessage;\n}",
  "Rust_humaneval-093": "fn encode(message: String) -> String {\n    let vowels = \"aeiouAEIOU\";\n    let mut encoded_message = String::new();\n    for letter in message.chars() {\n        if letter.is_alphabetic() {\n            let mut new_letter = letter;\n            if vowels.contains(letter) {\n                new_letter = (letter as u8 + 2) as char;\n            }\n            if letter.is_ascii_lowercase() {\n                encoded_message.push(new_letter.to_ascii_uppercase());\n            } else {\n                encoded_message.push(new_letter.to_ascii_lowercase());\n            }\n        } else {\n            encoded_message.push(letter);\n        }\n    }\n    encoded_message\n}",
  "Scala_humaneval-093": "def encode(message: String): String = {\n  val vowels = \"aeiouAEIOU\"\n  var encoded_message = \"\"\n  for (letter <- message) {\n    if (letter.isLetter) {\n      var new_letter = letter\n      if (vowels.contains(letter)) {\n        new_letter = (letter.toInt + 2).toChar\n      }\n      if (letter.isLower) {\n        encoded_message += new_letter.toUpper\n      } else {\n        encoded_message += new_letter.toLower\n      }\n    } else {\n      encoded_message += letter\n    }\n  }\n  encoded_message\n}",
  "Kotlin_humaneval-093": "fun encode(message: String): String {\n  val vowels = \"aeiouAEIOU\"\n  var encodedMessage = \"\"\n  for (letter in message) {\n    if (letter.isLetter()) {\n      var encodedLetter = letter\n      if (letter in vowels) {\n        encodedLetter = (letter.toInt() + 2).toChar()\n      }\n      if (letter.isLowerCase()) {\n        encodedMessage += encodedLetter.toUpperCase()\n      } else {\n        encodedMessage += encodedLetter.toLowerCase()\n      }\n    } else {\n      encodedMessage += letter\n    }\n  }\n  return encodedMessage\n}",
  "C++_humaneval-094": "bool isPrime(int n) {\n  for (int i = 2; i <= sqrt(n); i++) {\n    if (n % i == 0) {\n      return false;\n    }\n  }\n  return true;\n}\nint skjkasdkd(vector<int> l) {\n  int largest_prime = -1;\n  for (int num : l) {\n    if (isPrime(num)) {\n      if (largest_prime == -1 || num > largest_prime) {\n        largest_prime = num;\n      }\n    }\n  }\n  if (largest_prime == -1) {\n    return 0;\n  }\n  int sum = 0;\n  string str_num = to_string(largest_prime);\n  for (char digit : str_num) {\n    sum += digit - '0';\n  }\n  return sum;\n}",
  "Java_humaneval-094": "public static boolean isPrime(int n) {\n  for (int i = 2; i <= Math.sqrt(n); i++) {\n    if (n % i == 0) {\n      return false;\n    }\n  }\n  return true;\n}\npublic static Integer skjkasdkd(List<Integer> l) {\n  int largestPrime = -1;\n  for (int num : l) {\n    if (isPrime(num)) {\n      if (largestPrime == -1 || num > largestPrime) {\n        largestPrime = num;\n      }\n    }\n  }\n  if (largestPrime == -1) {\n    return 0;\n  }\n  int sum = 0;\n  String str = Integer.toString(largestPrime);\n  for (int i = 0; i < str.length(); i++) {\n    sum += Character.getNumericValue(str.charAt(i));\n  }\n  return sum;\n}",
  "Python_humaneval-094": "def is_prime(n):\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\ndef skjkasdkd(l: List[int]) -> int:\n    largest_prime = -1\n    for num in l:\n        if is_prime(num):\n            if largest_prime is -1 or num > largest_prime:\n                largest_prime = num\n    if largest_prime is -1:\n        return 0\n    return sum(int(digit) for digit in str(largest_prime))",
  "C#_humaneval-094": "public static bool IsPrime(int n) {\n  for (int i = 2; i <= Math.Sqrt(n); i++) {\n    if (n % i == 0) {\n      return false;\n    }\n  }\n  return true;\n}\npublic static int Skjkasdkd(List<int> l) {\n  int largest_prime = -1;\n  foreach (int num in l) {\n    if (IsPrime(num)) {\n      if (largest_prime == -1 || num > largest_prime) {\n        largest_prime = num;\n      }\n    }\n  }\n  if (largest_prime == -1) {\n    return 0;\n  }\n  return largest_prime.ToString().Sum(digit => int.Parse(digit.ToString()));\n}",
  "JavaScript_humaneval-094": "function is_prime(n) {\n  for (let i = 2; i <= Math.sqrt(n); i++) {\n    if (n % i === 0) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction skjkasdkd(l) {\n  let largest_prime = -1;\n  for (let num of l) {\n    if (is_prime(num)) {\n      if (largest_prime === -1 || num > largest_prime) {\n        largest_prime = num;\n      }\n    }\n  }\n  if (largest_prime === -1) {\n    return 0;\n  }\n  return Array.from(String(largest_prime), Number).reduce((a, b) => a + b, 0);\n}",
  "Go_humaneval-094": "func isPrime(n int) bool {\n    for i := 2; i <= int(math.Sqrt(float64(n))); i++ {\n        if n%i == 0 {\n            return false\n        }\n    }\n    return true\n}\nfunc skjkasdkd(l []int) int {\n    largestPrime := -1\n    for _, num := range l {\n        if isPrime(num) {\n            if largestPrime == -1 || num > largestPrime {\n                largestPrime = num\n            }\n        }\n    }\n    if largestPrime == -1 {\n        return 0\n    }\n    sum := 0\n    for _, digit := range strconv.Itoa(largestPrime) {\n        sum += int(digit - '0')\n    }\n    return sum\n}",
  "PHP_humaneval-094": "function is_prime($n) {\n    for ($i = 2; $i <= sqrt($n); $i++) {\n        if ($n % $i == 0) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction skjkasdkd(array $l): int {\n    $largest_prime = -1;\n    foreach ($l as $num) {\n        if (is_prime($num)) {\n            if ($largest_prime == -1 || $num > $largest_prime) {\n                $largest_prime = $num;\n            }\n        }\n    }\n    if ($largest_prime == -1) {\n        return 0;\n    }\n    return array_sum(str_split($largest_prime));\n}",
  "Ruby_humaneval-094": "def is_prime(n)\n  (2..Math.sqrt(n).to_i).each { |i| return false if n % i == 0 }\n  true\nend\ndef skjkasdkd(l)\n  largest_prime = -1\n  l.each do |num|\n    if is_prime(num)\n      largest_prime = num if largest_prime == -1 || num > largest_prime\n    end\n  end\n  return 0 if largest_prime == -1\n  largest_prime.to_s.chars.map(&:to_i).sum\nend",
  "Swift_humaneval-094": "func isPrime(_ n: Int) -> Bool {\n  if n < 2 {\n    return false\n  }\n  for i in 2..<Int(1 + sqrt(Double(n))) {\n    if n % i == 0 {\n      return false\n    }\n  }\n  return true\n}\nfunc skjkasdkd(_ l: [Int]) -> Int {\n  var largestPrime = -1\n  for num in l {\n    if isPrime(num) {\n      if largestPrime == -1 || num > largestPrime {\n        largestPrime = num\n      }\n    }\n  }\n  if largestPrime == -1 {\n    return 0\n  }\n  return String(largestPrime).compactMap { Int(String($0)) }.reduce(0, +)\n}",
  "TypeScript_humaneval-094": "function is_prime(n: number): boolean {\n  for (let i = 2; i <= Math.sqrt(n); i++) {\n    if (n % i === 0) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction skjkasdkd(l: number[]): number {\n  let largest_prime = -1;\n  for (const num of l) {\n    if (is_prime(num)) {\n      if (largest_prime === -1 || num > largest_prime) {\n        largest_prime = num;\n      }\n    }\n  }\n  if (largest_prime === -1) {\n    return 0;\n  }\n  return Array.from(String(largest_prime), Number).reduce((a, b) => a + b, 0);\n}",
  "Dart_humaneval-094": "bool isPrime(int n) {\n  for (int i = 2; i <= sqrt(n); i++) {\n    if (n % i == 0) {\n      return false;\n    }\n  }\n  return true;\n}\nint skjkasdkd(List<int> l) {\n  int largestPrime = -1;\n  for (int num in l) {\n    if (isPrime(num)) {\n      if (largestPrime == -1 || num > largestPrime) {\n        largestPrime = num;\n      }\n    }\n  }\n  if (largestPrime == -1) {\n    return 0;\n  }\n  return largestPrime\n      .toString()\n      .split('')\n      .map(int.parse)\n      .reduce((a, b) => a + b);\n}",
  "Rust_humaneval-094": "fn is_prime(n: i32) -> bool {\n    for i in 2..=(n as f64).sqrt() as i32 {\n        if n % i == 0 {\n            return false;\n        }\n    }\n    true\n}\nfn skjkasdkd(l: Vec<i32>) -> i32 {\n    let mut largest_prime = -1;\n    for num in l {\n        if is_prime(num) {\n            if largest_prime == -1 || num > largest_prime {\n                largest_prime = num;\n            }\n        }\n    }\n    if largest_prime == -1 {\n        return 0;\n    }\n    largest_prime\n        .to_string()\n        .chars()\n        .map(|c| c.to_digit(10).unwrap() as i32)\n        .sum()\n}",
  "Scala_humaneval-094": "def is_prime(n: Int): Boolean = {\n  for (i <- 2 to sqrt(n).toInt)\n    if (n % i == 0)\n      return false\n  true\n}\ndef skjkasdkd(l: List[Int]): Int = {\n  var largest_prime = -1\n  for (num <- l) {\n    if (is_prime(num)) {\n      if (largest_prime == -1 || num > largest_prime) {\n        largest_prime = num\n      }\n    }\n  }\n  if (largest_prime == -1) {\n    return 0\n  }\n  largest_prime.toString.map(_.asDigit).sum\n}",
  "Kotlin_humaneval-094": "fun isPrime(n: Int): Boolean {\n  for (i in 2..(n.toDouble().pow(0.5)).toInt()) {\n    if (n % i == 0) {\n      return false\n    }\n  }\n  return true\n}\nfun skjkasdkd(l: List<Int>): Int {\n  var largestPrime = -1\n  for (num in l) {\n    if (isPrime(num)) {\n      if (largestPrime == -1 || num > largestPrime) {\n        largestPrime = num\n      }\n    }\n  }\n  if (largestPrime == -1) {\n    return 0\n  }\n  return largestPrime.toString().map { it.toString().toInt() }.sum()\n}",
  "C++_humaneval-095": "bool checkDictCase(unordered_map<string, string> d) {\n  if (d.empty()) {\n    return false;\n  }\n  bool lowerCase = false;\n  bool upperCase = false;\n  for (const auto& pair : d) {\n    const string& key = pair.first;\n    if (all_of(key.begin(), key.end(), ::islower)) {\n      lowerCase = true;\n    } else if (all_of(key.begin(), key.end(), ::isupper)) {\n      upperCase = true;\n    } else {\n      return false;\n    }\n  }\n  return lowerCase != upperCase;\n}",
  "Java_humaneval-095": "public static Boolean checkDictCase(Map<String, String> d) {\n  if (d == null || d.isEmpty()) {\n    return false;\n  }\n  boolean lowerCase = false;\n  boolean upperCase = false;\n  for (String key : d.keySet()) {\n    if (key.chars().allMatch(Character::isLowerCase)) {\n      lowerCase = true;\n    } else if (key.chars().allMatch(Character::isUpperCase)) {\n      upperCase = true;\n    } else {\n      return false;\n    }\n  }\n  return lowerCase != upperCase;\n}",
  "Python_humaneval-095": "def check_dict_case(d: Dict[str, str]) -> bool:\n    if not d:\n        return False\n    lower_case = False\n    upper_case = False\n    for key in d.keys():\n        if key.islower():\n            lower_case = True\n        elif key.isupper():\n            upper_case = True\n        else:\n            return False\n    return lower_case != upper_case",
  "C#_humaneval-095": "public static bool CheckDictCase(Dictionary<string, string> d) {\n  if (d == null || d.Count == 0) {\n    return false;\n  }\n  bool lowerCase = false;\n  bool upperCase = false;\n  foreach (string key in d.Keys) {\n    if (key.All(char.IsLower)) {\n      lowerCase = true;\n    } else if (key.All(char.IsUpper)) {\n      upperCase = true;\n    } else {\n      return false;\n    }\n  }\n  return lowerCase != upperCase;\n}",
  "JavaScript_humaneval-095": "function checkDictCase(d) {\n  if (!d || d.size === 0) {\n    return false;\n  }\n  let lowerCase = false;\n  let upperCase = false;\n  for (let [key, value] of d) {\n    if (/^[a-z]+$/.test(key)) {\n      lowerCase = true;\n    } else if (/^[A-Z]+$/.test(key)) {\n      upperCase = true;\n    } else {\n      return false;\n    }\n  }\n  return lowerCase !== upperCase;\n}",
  "Go_humaneval-095": "func checkDictCase(d map[string]string) bool {\n    if len(d) == 0 {\n        return false\n    }\n    lowerCase := false\n    upperCase := false\n    for key := range d {\n        if strings.ToLower(key) == key && strings.ToUpper(key) != key {\n            lowerCase = true\n        } else if strings.ToUpper(key) == key && strings.ToLower(key) != key {\n            upperCase = true\n        } else {\n            return false\n        }\n    }\n    return lowerCase != upperCase\n}",
  "PHP_humaneval-095": "function checkDictCase(array $d): bool {\n    if (!$d) {\n        return false;\n    }\n    $lower_case = false;\n    $upper_case = false;\n    foreach (array_keys($d) as $key) {\n        if (ctype_lower($key)) {\n            $lower_case = true;\n        } elseif (ctype_upper($key)) {\n            $upper_case = true;\n        } else {\n            return false;\n        }\n    }\n    return $lower_case !== $upper_case;\n}",
  "Ruby_humaneval-095": "def check_dict_case(d)\n  return false if d.empty?\n  lower_case = false\n  upper_case = false\n  d.keys.each do |key|\n    if key =~ /^[[:lower:]]+$/\n      lower_case = true\n    elsif key =~ /^[[:upper:]]+$/\n      upper_case = true\n    else\n      return false\n    end\n  end\n  lower_case != upper_case\nend",
  "Swift_humaneval-095": "func checkDictCase(_ d: [String: String]) -> Bool {\n  if d.isEmpty {\n    return false\n  }\n  var lowerCase = false\n  var upperCase = false\n  for key in d.keys {\n    if key.allSatisfy { $0.isLowercase } {\n      lowerCase = true\n    } else if key.allSatisfy { $0.isUppercase } {\n      upperCase = true\n    } else {\n      return false\n    }\n  }\n  return lowerCase != upperCase\n}",
  "TypeScript_humaneval-095": "function checkDictCase(d: Map<string, string>): boolean {\n  if (!d || d.size === 0) {\n    return false;\n  }\n  let lowerCase = false;\n  let upperCase = false;\n  for (let [key, value] of d) {\n    if (key === key.toLowerCase() && key !== key.toUpperCase()) {\n      lowerCase = true;\n    } else if (key === key.toUpperCase() && key !== key.toLowerCase()) {\n      upperCase = true;\n    } else {\n      return false;\n    }\n  }\n  return lowerCase !== upperCase;\n}",
  "Dart_humaneval-095": "bool checkDictCase(Map<String, String> d) {\n  if (d == null || d.isEmpty) {\n    return false;\n  }\n  bool lowerCase = false;\n  bool upperCase = false;\n  for (String key in d.keys) {\n    if (key.toLowerCase() == key && key.toUpperCase() != key) {\n      lowerCase = true;\n    } else if (key.toUpperCase() == key && key.toLowerCase() != key) {\n      upperCase = true;\n    } else {\n      return false;\n    }\n  }\n  return lowerCase != upperCase;\n}",
  "Rust_humaneval-095": "fn check_dict_case(d: HashMap<String, String>) -> bool {\n    if d.is_empty() {\n        return false;\n    }\n    let mut lower_case = false;\n    let mut upper_case = false;\n    for key in d.keys() {\n        if key.chars().all(char::is_lowercase) {\n            lower_case = true;\n        } else if key.chars().all(char::is_uppercase) {\n            upper_case = true;\n        } else {\n            return false;\n        }\n    }\n    lower_case != upper_case\n}",
  "Scala_humaneval-095": "def checkDictCase(d: Map[String, String]): Boolean = {\n  if (d == null || d.isEmpty) {\n    false\n  } else {\n    var lowerCase = false\n    var upperCase = false\n    for (key <- d.keys) {\n      if (key.forall(_.isLower)) {\n        lowerCase = true\n      } else if (key.forall(_.isUpper)) {\n        upperCase = true\n      } else {\n        return false\n      }\n    }\n    lowerCase != upperCase\n  }\n}",
  "Kotlin_humaneval-095": "fun checkDictCase(d: Map<String, String>): Boolean {\n  if (d == null || d.isEmpty()) {\n    return false\n  }\n  var lowerCase = false\n  var upperCase = false\n  for (key in d.keys) {\n    if (key.all { it.isLowerCase() }) {\n      lowerCase = true\n    } else if (key.all { it.isUpperCase() }) {\n      upperCase = true\n    } else {\n      return false\n    }\n  }\n  return lowerCase != upperCase\n}",
  "C++_humaneval-096": "vector<int> countUpTo(int n) {\n  vector<int> primes;\n  for (int num = 2; num < n; ++num) {\n    bool isPrime = true;\n    for (int p : primes) {\n      if (num % p == 0) {\n        isPrime = false;\n        break;\n      }\n    }\n    if (isPrime) {\n      primes.push_back(num);\n    }\n  }\n  return primes;\n}",
  "Java_humaneval-096": "public static List<Integer> countUpTo(Integer n) {\n  List<Integer> primes = new ArrayList<>();\n  for (int num = 2; num < n; num++) {\n    boolean isPrime = true;\n    for (int p : primes) {\n      if (num % p == 0) {\n        isPrime = false;\n        break;\n      }\n    }\n    if (isPrime) {\n      primes.add(num);\n    }\n  }\n  return primes;\n}",
  "Python_humaneval-096": "def count_up_to(n: int) -> List[int]:\n    primes = []\n    for num in range(2, n):\n        if all(num % p != 0 for p in primes):\n            primes.append(num)\n    return primes",
  "C#_humaneval-096": "public static List<int> CountUpTo(int n) {\n  List<int> primes = new List<int>();\n  for (int num = 2; num < n; num++) {\n    bool isPrime = true;\n    foreach (int p in primes) {\n      if (num % p == 0) {\n        isPrime = false;\n        break;\n      }\n    }\n    if (isPrime) {\n      primes.Add(num);\n    }\n  }\n  return primes;\n}",
  "JavaScript_humaneval-096": "function countUpTo(n) {\n  const primes = [];\n  for (let num = 2; num < n; num++) {\n    let isPrime = true;\n    for (const p of primes) {\n      if (num % p === 0) {\n        isPrime = false;\n        break;\n      }\n    }\n    if (isPrime) {\n      primes.push(num);\n    }\n  }\n  return primes;\n}",
  "Go_humaneval-096": "func countUpTo(n int) []int {\n    primes := []int{}\n    for num := 2; num < n; num++ {\n        isPrime := true\n        for _, p := range primes {\n            if num%p == 0 {\n                isPrime = false\n                break\n            }\n        }\n        if isPrime {\n            primes = append(primes, num)\n        }\n    }\n    return primes\n}",
  "PHP_humaneval-096": "function countUpTo(int $n): array {\n    $primes = [];\n    for ($num = 2; $num < $n; $num++) {\n        $isPrime = true;\n        foreach ($primes as $p) {\n            if ($num % $p === 0) {\n                $isPrime = false;\n                break;\n            }\n        }\n        if ($isPrime) {\n            $primes[] = $num;\n        }\n    }\n    return $primes;\n}",
  "Ruby_humaneval-096": "def count_up_to(n)\n  primes = []\n  (2...n).each do |num|\n    is_prime = primes.all? { |p| num % p != 0 }\n    primes << num if is_prime\n  end\n  primes\nend",
  "Swift_humaneval-096": "func countUpTo(_ n: Int) -> [Int] {\n  var primes = [Int]()\n  if n < 2 {\n    return primes\n  }\n  for num in 2..<n {\n    var isPrime = true\n    for p in primes {\n      if num % p == 0 {\n        isPrime = false\n        break\n      }\n    }\n    if isPrime {\n      primes.append(num)\n    }\n  }\n  return primes\n}",
  "TypeScript_humaneval-096": "function countUpTo(n: number): number[] {\n  const primes: number[] = [];\n  for (let num = 2; num < n; num++) {\n    let isPrime = true;\n    for (const p of primes) {\n      if (num % p === 0) {\n        isPrime = false;\n        break;\n      }\n    }\n    if (isPrime) {\n      primes.push(num);\n    }\n  }\n  return primes;\n}",
  "Dart_humaneval-096": "List<int> countUpTo(int n) {\n  List<int> primes = [];\n  for (int num = 2; num < n; num++) {\n    bool isPrime = true;\n    for (int p in primes) {\n      if (num % p == 0) {\n        isPrime = false;\n        break;\n      }\n    }\n    if (isPrime) {\n      primes.add(num);\n    }\n  }\n  return primes;\n}",
  "Rust_humaneval-096": "fn count_up_to(n: i32) -> Vec<i32> {\n    let mut primes = Vec::new();\n    for num in 2..n {\n        let mut is_prime = true;\n        for &p in &primes {\n            if num % p == 0 {\n                is_prime = false;\n                break;\n            }\n        }\n        if is_prime {\n            primes.push(num);\n        }\n    }\n    primes\n}",
  "Scala_humaneval-096": "def countUpTo(n: Int): List[Int] = {\n  var primes = List[Int]()\n  for (num <- 2 until n) {\n    var isPrime = true\n    for (p <- primes) {\n      if (num % p == 0) {\n        isPrime = false\n      }\n    }\n    if (isPrime) {\n      primes :+= num\n    }\n  }\n  primes\n}",
  "Kotlin_humaneval-096": "fun countUpTo(n: Int): List<Int> {\n  val primes = mutableListOf<Int>()\n  for (num in 2 until n) {\n    var isPrime = true\n    for (p in primes) {\n      if (num % p == 0) {\n        isPrime = false\n        break\n      }\n    }\n    if (isPrime) {\n      primes.add(num)\n    }\n  }\n  return primes\n}",
  "C++_humaneval-097": "int multiply(int a, int b) {\n  int a_units = abs(a) % 10;\n  int b_units = abs(b) % 10;\n  return a_units * b_units;\n}",
  "Java_humaneval-097": "public static Integer multiply(Integer a, Integer b) {\n  Integer aUnits = Math.abs(a) % 10;\n  Integer bUnits = Math.abs(b) % 10;\n  return aUnits * bUnits;\n}",
  "Python_humaneval-097": "def multiply(a: int, b: int) -> int:\n    a_units = abs(a) % 10\n    b_units = abs(b) % 10\n    return a_units * b_units",
  "C#_humaneval-097": "public static int Multiply(int a, int b) {\n  int a_units = Math.Abs(a) % 10;\n  int b_units = Math.Abs(b) % 10;\n  return a_units * b_units;\n}",
  "JavaScript_humaneval-097": "function multiply(a, b) {\n  let a_units = Math.abs(a) % 10;\n  let b_units = Math.abs(b) % 10;\n  return a_units * b_units;\n}",
  "Go_humaneval-097": "func multiply(a int, b int) int {\n    aUnits := int(math.Abs(float64(a))) % 10\n    bUnits := int(math.Abs(float64(b))) % 10\n    return aUnits * bUnits\n}",
  "PHP_humaneval-097": "function multiply(int $a, int $b): int {\n    $a_units = abs($a) % 10;\n    $b_units = abs($b) % 10;\n    return $a_units * $b_units;\n}",
  "Ruby_humaneval-097": "def multiply(a, b)\n  a_units = a.abs % 10\n  b_units = b.abs % 10\n  return a_units * b_units\nend",
  "Swift_humaneval-097": "func multiply(_ a: Int, _ b: Int) -> Int {\n  let aUnits = abs(a) % 10\n  let bUnits = abs(b) % 10\n  return aUnits * bUnits\n}",
  "TypeScript_humaneval-097": "function multiply(a: number, b: number): number {\n  const a_units = Math.abs(a) % 10;\n  const b_units = Math.abs(b) % 10;\n  return a_units * b_units;\n}",
  "Dart_humaneval-097": "int multiply(int a, int b) {\n  int aUnits = a.abs() % 10;\n  int bUnits = b.abs() % 10;\n  return aUnits * bUnits;\n}",
  "Rust_humaneval-097": "fn multiply(a: i32, b: i32) -> i32 {\n    let a_units = (a.abs() % 10) as i32;\n    let b_units = (b.abs() % 10) as i32;\n    return a_units * b_units;\n}",
  "Scala_humaneval-097": "def multiply(a: Int, b: Int): Int = {\n  val aUnits = abs(a) % 10\n  val bUnits = abs(b) % 10\n  aUnits * bUnits\n}",
  "Kotlin_humaneval-097": "fun multiply(a: Int, b: Int): Int {\n  val aUnits = Math.abs(a) % 10\n  val bUnits = Math.abs(b) % 10\n  return aUnits * bUnits\n}",
  "C++_humaneval-098": "int countUpper(string s) {\n  string vowels = \"AEIOU\";\n  int count = 0;\n  for (int i = 0; i < s.length(); i += 2) {\n    if (vowels.find(s[i]) != string::npos && isupper(s[i])) {\n      count++;\n    }\n  }\n  return count;\n}",
  "Java_humaneval-098": "public static Integer countUpper(String s) {\n  String[] vowels = {\"A\", \"E\", \"I\", \"O\", \"U\"};\n  int count = 0;\n  for (int i = 0; i < s.length(); i += 2) {\n    if (Arrays.asList(vowels).contains(String.valueOf(s.charAt(i)))\n        && Character.isUpperCase(s.charAt(i))) {\n      count++;\n    }\n  }\n  return count;\n}",
  "Python_humaneval-098": "def count_upper(s: str) -> int:\n    vowels = [\"A\", \"E\", \"I\", \"O\", \"U\"]\n    count = 0\n    for i in range(0, len(s), 2):\n        if s[i] in vowels and s[i].isupper():\n            count += 1\n    return count",
  "C#_humaneval-098": "public static int CountUpper(string s) {\n  char[] vowels = { 'A', 'E', 'I', 'O', 'U' };\n  int count = 0;\n  for (int i = 0; i < s.Length; i += 2) {\n    if (vowels.Contains(s[i]) && Char.IsUpper(s[i])) {\n      count++;\n    }\n  }\n  return count;\n}",
  "JavaScript_humaneval-098": "function countUpper(s) {\n  const vowels = [\"A\", \"E\", \"I\", \"O\", \"U\"];\n  let count = 0;\n  for (let i = 0; i < s.length; i += 2) {\n    if (vowels.includes(s[i]) && s[i] === s[i].toUpperCase()) {\n      count++;\n    }\n  }\n  return count;\n}",
  "Go_humaneval-098": "func countUpper(s string) int {\n    vowels := []string{\"A\", \"E\", \"I\", \"O\", \"U\"}\n    count := 0\n    for i := 0; i < len(s); i += 2 {\n        if contains(vowels, string(s[i])) && unicode.IsUpper(rune(s[i])) {\n            count++\n        }\n    }\n    return count\n}\nfunc contains(s []string, e string) bool {\n    for _, a := range s {\n        if a == e {\n            return true\n        }\n    }\n    return false\n}",
  "PHP_humaneval-098": "function countUpper(string $s): int {\n    $vowels = [\"A\", \"E\", \"I\", \"O\", \"U\"];\n    $count = 0;\n    for ($i = 0; $i < strlen($s); $i += 2) {\n        if (in_array($s[$i], $vowels) && ctype_upper($s[$i])) {\n            $count++;\n        }\n    }\n    return $count;\n}",
  "Ruby_humaneval-098": "def count_upper(s)\n  vowels = %w[A E I O U]\n  count = 0\n  (0...s.length).step(2) do |i|\n    count += 1 if vowels.include?(s[i]) && s[i].upcase == s[i]\n  end\n  return count\nend",
  "Swift_humaneval-098": "func countUpper(_ s: String) -> Int {\n  let vowels = [\"A\", \"E\", \"I\", \"O\", \"U\"]\n  var count = 0\n  for i in stride(from: 0, to: s.count, by: 2) {\n    let index = s.index(s.startIndex, offsetBy: i)\n    if vowels.contains(String(s[index])) && s[index].isUppercase {\n      count += 1\n    }\n  }\n  return count\n}",
  "TypeScript_humaneval-098": "function countUpper(s: string): number {\n  const vowels = [\"A\", \"E\", \"I\", \"O\", \"U\"];\n  let count = 0;\n  for (let i = 0; i < s.length; i += 2) {\n    if (vowels.includes(s[i]) && s[i] === s[i].toUpperCase()) {\n      count += 1;\n    }\n  }\n  return count;\n}",
  "Dart_humaneval-098": "int countUpper(String s) {\n  List<String> vowels = [\"A\", \"E\", \"I\", \"O\", \"U\"];\n  int count = 0;\n  for (int i = 0; i < s.length; i += 2) {\n    if (vowels.contains(s[i]) && s[i].toUpperCase() == s[i]) {\n      count++;\n    }\n  }\n  return count;\n}",
  "Rust_humaneval-098": "fn count_upper(s: String) -> i32 {\n    let vowels = vec!['A', 'E', 'I', 'O', 'U'];\n    let mut count = 0;\n    for (i, c) in s.chars().enumerate().step_by(2) {\n        if vowels.contains(&c) && c.is_uppercase() {\n            count += 1;\n        }\n    }\n    count\n}",
  "Scala_humaneval-098": "def countUpper(s: String): Int = {\n  val vowels = List(\"A\", \"E\", \"I\", \"O\", \"U\")\n  var count = 0\n  for (i <- 0 until s.length by 2) {\n    if (vowels.contains(s(i).toString) && s(i).isUpper) {\n      count += 1\n    }\n  }\n  count\n}",
  "Kotlin_humaneval-098": "fun countUpper(s: String): Int {\n  val vowels = listOf('A', 'E', 'I', 'O', 'U')\n  var count = 0\n  for (i in s.indices step 2) {\n    if (s[i] in vowels) {\n      count++\n    }\n  }\n  return count\n}",
  "C++_humaneval-099": "int closestInteger(string value) {\n  float num = stof(value);\n  if (num >= 0) {\n    return int(num + 0.5);\n  } else {\n    return int(num - 0.5);\n  }\n}",
  "Java_humaneval-099": "public static Integer closestInteger(String value) {\n  double num = Double.parseDouble(value);\n  if (num >= 0) {\n    return (int) (num + 0.5);\n  } else {\n    return (int) (num - 0.5);\n  }\n}",
  "Python_humaneval-099": "def closest_integer(value: str) -> int:\n    num = float(value)\n    if num >= 0:\n        return int(num + 0.5)\n    else:\n        return int(num - 0.5)",
  "C#_humaneval-099": "public static int ClosestInteger(string value) {\n  double num = double.Parse(value);\n  if (num >= 0) {\n    return (int)(num + 0.5);\n  } else {\n    return (int)(num - 0.5);\n  }\n}",
  "JavaScript_humaneval-099": "function closestInteger(value) {\n  let num = parseFloat(value);\n  if (num >= 0) {\n    return Math.trunc(num + 0.5);\n  } else {\n    return Math.trunc(num - 0.5);\n  }\n}",
  "Go_humaneval-099": "func closestInteger(value string) int {\n    num, _ := strconv.ParseFloat(value, 64)\n    if num >= 0 {\n        return int(num + 0.5)\n    } else {\n        return int(num - 0.5)\n    }\n}",
  "PHP_humaneval-099": "function closestInteger(string $value): int {\n    $num = (float) $value;\n    if ($num >= 0) {\n        return (int) ($num + 0.5);\n    } else {\n        return (int) ($num - 0.5);\n    }\n}",
  "Ruby_humaneval-099": "def closest_integer(value)\n  num = value.to_f\n  if num >= 0\n    return (num + 0.5).to_i\n  else\n    return (num - 0.5).to_i\n  end\nend",
  "Swift_humaneval-099": "func closestInteger(_ value: String) -> Int {\n  let num = Double(value)!\n  if num >= 0 {\n    return Int(num + 0.5)\n  } else {\n    return Int(num - 0.5)\n  }\n}",
  "TypeScript_humaneval-099": "function closestInteger(value: string): number {\n  const num = parseFloat(value);\n  if (num >= 0) {\n    return Math.trunc(num + 0.5);\n  } else {\n    return Math.trunc(num - 0.5);\n  }\n}",
  "Dart_humaneval-099": "int closestInteger(String value) {\n  double num = double.parse(value);\n  if (num >= 0) {\n    return (num + 0.5).toInt();\n  } else {\n    return (num - 0.5).toInt();\n  }\n}",
  "Rust_humaneval-099": "fn closest_integer(value: String) -> i32 {\n    let num = value.parse::<f64>().unwrap();\n    if num >= 0.0 {\n        (num + 0.5) as i32\n    } else {\n        (num - 0.5) as i32\n    }\n}",
  "Scala_humaneval-099": "def closestInteger(value: String): Int = {\n  val num = value.toFloat\n  if (num >= 0) {\n    (num + 0.5).toInt\n  } else {\n    (num - 0.5).toInt\n  }\n}",
  "Kotlin_humaneval-099": "fun closestInteger(value: String): Int {\n  val num = value.toFloat()\n  return if (num >= 0) {\n    (num + 0.5).toInt()\n  } else {\n    (num - 0.5).toInt()\n  }\n}",
  "C++_humaneval-100": "vector<int> makeAPile(int n) {\n  vector<int> pile(n);\n  for (int i = 0; i < n; i++) {\n    pile[i] = n + 2 * i;\n  }\n  return pile;\n}",
  "Java_humaneval-100": "public static List<Integer> makeAPile(Integer n) {\n  List<Integer> pile = new ArrayList<>();\n  for (int i = 0; i < n; i++) {\n    pile.add(n + 2 * i);\n  }\n  return pile;\n}",
  "Python_humaneval-100": "def make_a_pile(n: int) -> List[int]:\n    return [n + 2 * i for i in range(n)]",
  "C#_humaneval-100": "public static List<int> MakeAPile(int n) {\n  List<int> pile = new List<int>();\n  for (int i = 0; i < n; i++) {\n    pile.Add(n + 2 * i);\n  }\n  return pile;\n}",
  "JavaScript_humaneval-100": "function makeAPile(n) {\n  let pile = [];\n  for (let i = 0; i < n; i++) {\n    pile.push(n + 2 * i);\n  }\n  return pile;\n}",
  "Go_humaneval-100": "func makeAPile(n int) []int {\n    pile := make([]int, n)\n    for i := 0; i < n; i++ {\n        pile[i] = n + 2*i\n    }\n    return pile\n}",
  "PHP_humaneval-100": "function makeAPile(int $n): array {\n    $result = array();\n    for ($i = 0; $i < $n; $i++) {\n        $result[] = $n + 2 * $i;\n    }\n    return $result;\n}",
  "Ruby_humaneval-100": "def make_a_pile(n)\n  (0...n).map { |i| n + 2 * i }\nend",
  "Swift_humaneval-100": "func makeAPile(_ n: Int) -> [Int] {\n  return (0..<n).map { n + 2 * $0 }\n}",
  "TypeScript_humaneval-100": "function makeAPile(n: number): number[] {\n  const pile = [];\n  for (let i = 0; i < n; i++) {\n    pile.push(n + 2 * i);\n  }\n  return pile;\n}",
  "Dart_humaneval-100": "List<int> makeAPile(int n) {\n  List<int> pile = [];\n  for (int i = 0; i < n; i++) {\n    pile.add(n + 2 * i);\n  }\n  return pile;\n}",
  "Rust_humaneval-100": "fn make_a_pile(n: i32) -> Vec<i32> {\n    (0..n).map(|i| n + 2 * i).collect()\n}",
  "Scala_humaneval-100": "def makeAPile(n: Int): List[Int] = {\n  (0 until n).map(i => n + 2 * i).toList\n}",
  "Kotlin_humaneval-100": "fun makeAPile(n: Int): List<Int> {\n  return List(n) { i -> n + 2 * i }\n}",
  "C++_humaneval-101": "vector<string> wordsString(string s) {\n  vector<string> words;\n  stringstream ss(s);\n  string word;\n  while (getline(ss, word, ',')) {\n    stringstream ss2(word);\n    while (ss2 >> word) {\n      if (word.length() > 0) {\n        words.push_back(word);\n      }\n    }\n  }\n  return words;\n}",
  "Java_humaneval-101": "public static List<String> wordsString(String s) {\n  String[] words = s.split(\",\");\n  List<String> result = new ArrayList<String>();\n  for (String word : words) {\n    String[] subwords = word.split(\" \");\n    for (String subword : subwords) {\n      if (subword.length() > 0) {\n        result.add(subword);\n      }\n    }\n  }\n  return result;\n}",
  "Python_humaneval-101": "def words_string(s: str) -> List[str]:\n    words = s.split(\",\")\n    words = [word.split(\" \") for word in words]\n    words = [word for sublist in words for word in sublist if len(word) > 0]\n    return words",
  "C#_humaneval-101": "public static List<string> WordsString(string s) {\n  List<string> words = s.Split(',').ToList();\n  words = words.SelectMany(word => word.Split(' ')).Where(word => word.Length > 0).ToList();\n  return words;\n}",
  "JavaScript_humaneval-101": "function wordsString(s) {\n  let words = s.split(\",\");\n  words = words.map((word) => word.split(\" \"));\n  words = words.flat().filter((word) => word.length > 0);\n  return words;\n}",
  "Go_humaneval-101": "func wordsString(s string) []string {\n    words := strings.Split(s, \",\")\n    var result []string\n    for _, word := range words {\n        subWords := strings.Split(word, \" \")\n        for _, subWord := range subWords {\n            if len(subWord) > 0 {\n                result = append(result, subWord)\n            }\n        }\n    }\n    return result\n}",
  "PHP_humaneval-101": "function wordsString(string $s): array {\n    $words = explode(\",\", $s);\n    $words = array_map(function($word) {\n        return explode(\" \", $word);\n    }, $words);\n    $words = array_filter(array_merge(...$words), function($word) {\n        return strlen($word) > 0;\n    });\n    return array_values($words);\n}",
  "Ruby_humaneval-101": "def words_string(s)\n  words = s.split(\",\")\n  words =\n    words\n      .map { |word| word.split(\" \") }\n      .flatten\n      .select { |word| word.length > 0 }\n  return words\nend",
  "Swift_humaneval-101": "func wordsString(_ s: String) -> [String] {\n  var words = s.components(separatedBy: \",\")\n  words = words.map { $0.components(separatedBy: \" \") }.flatMap { $0 }\n  words = words.filter { !$0.isEmpty }\n  return words\n}",
  "TypeScript_humaneval-101": "function wordsString(s: string): string[] {\n  let words = s.split(\",\");\n  let subwords = words.map((word) => word.split(\" \"));\n  words = subwords.flat().filter((word) => word.length > 0);\n  return words;\n}",
  "Dart_humaneval-101": "List<String> wordsString(String s) {\n  List<String> words = s.split(\",\");\n  List<List<String>> subwords = words.map((word) => word.split(\" \")).toList();\n  words = subwords\n      .expand((sublist) => sublist)\n      .where((word) => word.length > 0)\n      .toList();\n  return words;\n}",
  "Rust_humaneval-101": "fn words_string(s: String) -> Vec<String> {\n    let mut words: Vec<String> = s\n        .split(\",\")\n        .map(|word| word.split(\" \").collect::<Vec<&str>>())\n        .flatten()\n        .filter(|word| !word.is_empty())\n        .map(|word| word.to_string())\n        .collect();\n    words\n}",
  "Scala_humaneval-101": "def wordsString(s: String): List[String] = {\n  var words = s.split(\",\")\n  words = words.map(_.split(\" \")).flatten\n  words.filter(_.length > 0).toList\n}",
  "Kotlin_humaneval-101": "fun wordsString(s: String): List<String> {\n  var words = s.split(\",\")\n  words = words.map { it.split(\" \") }.flatten()\n  return words.filter { it.isNotEmpty() }\n}",
  "C++_humaneval-102": "int chooseNum(int x, int y) {\n  int max_even = -1;\n  for (int i = x; i <= y; i++) {\n    if (i % 2 == 0 && i > max_even) {\n      max_even = i;\n    }\n  }\n  return max_even;\n}",
  "Java_humaneval-102": "public static Integer chooseNum(Integer x, Integer y) {\n  Integer max_even = -1;\n  for (int i = x; i <= y; i++) {\n    if (i % 2 == 0 && i > max_even) {\n      max_even = i;\n    }\n  }\n  return max_even;\n}",
  "Python_humaneval-102": "def choose_num(x: int, y: int) -> int:\n    max_even = -1\n    for i in range(x, y + 1):\n        if i % 2 == 0 and i > max_even:\n            max_even = i\n    return max_even",
  "C#_humaneval-102": "public static int ChooseNum(int x, int y) {\n  int max_even = -1;\n  for (int i = x; i <= y; i++) {\n    if (i % 2 == 0 && i > max_even) {\n      max_even = i;\n    }\n  }\n  return max_even;\n}",
  "JavaScript_humaneval-102": "function chooseNum(x, y) {\n  let max_even = -1;\n  for (let i = x; i <= y; i++) {\n    if (i % 2 === 0 && i > max_even) {\n      max_even = i;\n    }\n  }\n  return max_even;\n}",
  "Go_humaneval-102": "func chooseNum(x int, y int) int {\n    maxEven := -1\n    for i := x; i <= y; i++ {\n        if i%2 == 0 && i > maxEven {\n            maxEven = i\n        }\n    }\n    return maxEven\n}",
  "PHP_humaneval-102": "function chooseNum(int $x, int $y): int {\n    $max_even = -1;\n    for ($i = $x; $i <= $y; $i++) {\n        if ($i % 2 == 0 && $i > $max_even) {\n            $max_even = $i;\n        }\n    }\n    return $max_even;\n}",
  "Ruby_humaneval-102": "def choose_num(x, y)\n  max_even = -1\n  (x..y).each { |i| max_even = i if i % 2 == 0 && i > max_even }\n  max_even\nend",
  "Swift_humaneval-102": "func chooseNum(_ x: Int, _ y: Int) -> Int {\n  var maxEven = -1\n  for i in stride(from: x, to: y, by: 1) {\n    if i % 2 == 0 && i > maxEven {\n      maxEven = i\n    }\n  }\n  return maxEven\n}",
  "TypeScript_humaneval-102": "function chooseNum(x: number, y: number): number {\n  let maxEven = -1;\n  for (let i = x; i <= y; i++) {\n    if (i % 2 === 0 && i > maxEven) {\n      maxEven = i;\n    }\n  }\n  return maxEven;\n}",
  "Dart_humaneval-102": "int chooseNum(int x, int y) {\n  int maxEven = -1;\n  for (int i = x; i <= y; i++) {\n    if (i % 2 == 0 && i > maxEven) {\n      maxEven = i;\n    }\n  }\n  return maxEven;\n}",
  "Rust_humaneval-102": "fn choose_num(x: i32, y: i32) -> i32 {\n    let mut max_even = -1;\n    for i in x..=y {\n        if i % 2 == 0 && i > max_even {\n            max_even = i;\n        }\n    }\n    max_even\n}",
  "Scala_humaneval-102": "def chooseNum(x: Int, y: Int): Int = {\n  var maxEven = -1\n  for (i <- x to y) {\n    if (i % 2 == 0 && i > maxEven) {\n      maxEven = i\n    }\n  }\n  maxEven\n}",
  "Kotlin_humaneval-102": "fun chooseNum(x: Int, y: Int): Int {\n  var maxEven = -1\n  for (i in x..y) {\n    if (i % 2 == 0 && i > maxEven) {\n      maxEven = i\n    }\n  }\n  return maxEven\n}",
  "C++_humaneval-103": "string roundedAvg(int n, int m) {\n  if (n > m) {\n    return \"\";\n  }\n  int sum = 0;\n  for (int i = n; i <= m; ++i) {\n    sum += i;\n  }\n  int avg = sum / (m - n + 1);\n  string binary = bitset<32>(avg).to_string();\n  binary.erase(0, binary.find_first_not_of('0'));\n  return \"0b\" + binary;\n}",
  "Java_humaneval-103": "public static String roundedAvg(Integer n, Integer m) {\n  if (n > m) {\n    return \"\";\n  }\n  int sum = 0;\n  for (int i = n; i <= m; ++i) {\n    sum += i;\n  }\n  int avg = sum / (m - n + 1);\n  String binary = Integer.toBinaryString(avg);\n  return \"0b\" + binary;\n}",
  "Python_humaneval-103": "def rounded_avg(n: int, m: int) -> str:\n    if n > m:\n        return \"\"\n    avg = sum(range(n, m + 1)) // (m - n + 1)\n    return bin(avg)",
  "C#_humaneval-103": "public static string RoundedAvg(int n, int m) {\n  if (n > m) {\n    return \"\";\n  }\n  int sum = 0;\n  for (int i = n; i <= m; ++i) {\n    sum += i;\n  }\n  int avg = sum / (m - n + 1);\n  string binary = Convert.ToString(avg, 2);\n  return \"0b\" + binary;\n}",
  "JavaScript_humaneval-103": "function roundedAvg(n, m) {\n  if (n > m) {\n    return \"\";\n  }\n  let sum = 0;\n  for (let i = n; i <= m; ++i) {\n    sum += i;\n  }\n  let avg = Math.floor(sum / (m - n + 1));\n  let binary = avg.toString(2);\n  return \"0b\" + binary;\n}",
  "Go_humaneval-103": "func roundedAvg(n int, m int) string {\n    if n > m {\n        return \"\"\n    }\n    sum := 0\n    for i := n; i <= m; i++ {\n        sum += i\n    }\n    avg := sum / (m - n + 1)\n    binary := strconv.FormatInt(int64(avg), 2)\n    return \"0b\" + binary\n}",
  "PHP_humaneval-103": "function roundedAvg(int $n, int $m): string {\n    if ($n > $m) {\n        return \"\";\n    }\n    $sum = 0;\n    for ($i = $n; $i <= $m; ++$i) {\n        $sum += $i;\n    }\n    $avg = $sum / ($m - $n + 1);\n    $binary = decbin($avg);\n    return \"0b\" . $binary;\n}",
  "Ruby_humaneval-103": "def rounded_avg(n, m)\n  return \"\" if n > m\n  sum = (n..m).sum\n  avg = sum / (m - n + 1)\n  binary = avg.to_i.to_s(2)\n  \"0b#{binary}\"\nend",
  "Swift_humaneval-103": "func roundedAvg(_ n: Int, _ m: Int) -> String {\n  if n > m {\n    return \"\"\n  }\n  var sum = 0\n  for i in n...m {\n    sum += i\n  }\n  let avg = sum / (m - n + 1)\n  let binary = String(avg, radix: 2)\n  return \"0b\" + binary\n}",
  "TypeScript_humaneval-103": "function roundedAvg(n: number, m: number): string {\n  if (n > m) {\n    return \"\";\n  }\n  let sum = 0;\n  for (let i = n; i <= m; ++i) {\n    sum += i;\n  }\n  let avg = Math.floor(sum / (m - n + 1));\n  let binary = avg.toString(2);\n  return \"0b\" + binary;\n}",
  "Dart_humaneval-103": "String roundedAvg(int n, int m) {\n  if (n > m) {\n    return \"\";\n  }\n  int sum = 0;\n  for (int i = n; i <= m; ++i) {\n    sum += i;\n  }\n  int avg = sum ~/ (m - n + 1);\n  String binary = avg.toRadixString(2);\n  return \"0b$binary\";\n}",
  "Rust_humaneval-103": "fn rounded_avg(n: i32, m: i32) -> String {\n    if n > m {\n        return \"\".to_string();\n    }\n    let sum: i32 = (n..=m).sum();\n    let avg: i32 = sum / (m - n + 1);\n    let binary = format!(\"0b{:b}\", avg);\n    binary\n}",
  "Scala_humaneval-103": "def roundedAvg(n: Int, m: Int): String = {\n  if (n > m) {\n    \"\"\n  } else {\n    val sum = (n to m).sum\n    val avg = sum / (m - n + 1)\n    val binary = avg.toBinaryString\n    s\"0b$binary\"\n  }\n}",
  "Kotlin_humaneval-103": "fun roundedAvg(n: Int, m: Int): String {\n  if (n > m) {\n    return \"\"\n  }\n  var sum = 0\n  for (i in n..m) {\n    sum += i\n  }\n  val avg = sum / (m - n + 1)\n  val binary = Integer.toBinaryString(avg)\n  return \"0b$binary\"\n}",
  "C++_humaneval-104": "vector<int> uniqueDigits(vector<int> x) {\n  vector<int> result;\n  for (int num : x) {\n    bool all_odd = true;\n    string num_str = to_string(num);\n    for (char digit : num_str) {\n      if ((digit - '0') % 2 == 0) {\n        all_odd = false;\n        break;\n      }\n    }\n    if (all_odd) {\n      result.push_back(num);\n    }\n  }\n  sort(result.begin(), result.end());\n  return result;\n}",
  "Java_humaneval-104": "public static List<Integer> uniqueDigits(List<Integer> x) {\n  List<Integer> result = new ArrayList<>();\n  for (int num : x) {\n    boolean allOdd = true;\n    for (char digit : String.valueOf(num).toCharArray()) {\n      if (digit % 2 == 0) {\n        allOdd = false;\n        break;\n      }\n    }\n    if (allOdd) {\n      result.add(num);\n    }\n  }\n  result.sort(null);\n  return result;\n}",
  "Python_humaneval-104": "def unique_digits(x: List[int]) -> List[int]:\n    result = []\n    for num in x:\n        if all(int(digit) % 2 != 0 for digit in str(num)):\n            result.append(num)\n    return sorted(result)",
  "C#_humaneval-104": "public static List<int> UniqueDigits(List<int> x) {\n  List<int> result = new List<int>();\n  foreach (int num in x) {\n    if (num.ToString().All(digit => int.Parse(digit.ToString()) % 2 != 0)) {\n      result.Add(num);\n    }\n  }\n  return result.OrderBy(num => num).ToList();\n}",
  "JavaScript_humaneval-104": "function uniqueDigits(x) {\n  let result = [];\n  for (let num of x) {\n    if ([...String(num)].every((digit) => parseInt(digit) % 2 !== 0)) {\n      result.push(num);\n    }\n  }\n  return result.sort((a, b) => a - b);\n}",
  "Go_humaneval-104": "func uniqueDigits(x []int) []int {\n    var result []int\n    for _, num := range x {\n        allOdd := true\n        for _, digit := range strconv.Itoa(num) {\n            if digit%2 == 0 {\n                allOdd = false\n                break\n            }\n        }\n        if allOdd {\n            result = append(result, num)\n        }\n    }\n    sort.Ints(result)\n    return result\n}",
  "PHP_humaneval-104": "function uniqueDigits(array $x): array {\n    $result = [];\n    foreach ($x as $num) {\n        if (preg_match('/^[13579]+$/', $num)) {\n            $result[] = $num;\n        }\n    }\n    sort($result);\n    return $result;\n}",
  "Ruby_humaneval-104": "def unique_digits(x)\n  result = []\n  x.each do |num|\n    result << num if num.to_s.chars.all? { |digit| digit.to_i.odd? }\n  end\n  result.sort\nend",
  "Swift_humaneval-104": "func uniqueDigits(_ x: [Int]) -> [Int] {\n  var result = [Int]()\n  for num in x {\n    if String(num).allSatisfy({ Int(String($0))! % 2 != 0 }) {\n      result.append(num)\n    }\n  }\n  return result.sorted()\n}",
  "TypeScript_humaneval-104": "function uniqueDigits(x: number[]): number[] {\n  const result: number[] = [];\n  for (const num of x) {\n    if (Array.from(String(num)).every((digit) => parseInt(digit) % 2 !== 0)) {\n      result.push(num);\n    }\n  }\n  return result.sort((a, b) => a - b);\n}",
  "Dart_humaneval-104": "List<int> uniqueDigits(List<int> x) {\n  List<int> result = [];\n  for (int num in x) {\n    if (num.toString().split('').every((digit) => int.parse(digit) % 2 != 0)) {\n      result.add(num);\n    }\n  }\n  return result..sort();\n}",
  "Rust_humaneval-104": "fn unique_digits(x: Vec<i32>) -> Vec<i32> {\n    let mut result = Vec::new();\n    for num in x {\n        if num\n            .to_string()\n            .chars()\n            .all(|digit| digit.to_digit(10).unwrap() % 2 != 0)\n        {\n            result.push(num);\n        }\n    }\n    result.sort();\n    result\n}",
  "Scala_humaneval-104": "def uniqueDigits(x: List[Int]): List[Int] = {\n  var result = List[Int]()\n  for (num <- x) {\n    if (num.toString.forall(_.asDigit % 2 != 0)) {\n      result = num :: result\n    }\n  }\n  result.sorted\n}",
  "Kotlin_humaneval-104": "fun uniqueDigits(x: List<Int>): List<Int> {\n  val result = mutableListOf<Int>()\n  for (num in x) {\n    if (num.toString().all { it.toInt() % 2 != 0 }) {\n      result.add(num)\n    }\n  }\n  return result.sorted()\n}",
  "C++_humaneval-105": "vector<string> byLength(vector<int> arr) {\n  vector<string> digit_names = {\n      \"\",     \"One\", \"Two\",   \"Three\", \"Four\",\n      \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\",\n  };\n  vector<int> sorted_arr;\n  for (int x : arr) {\n    if (1 <= x && x <= 9) {\n      sorted_arr.push_back(x);\n    }\n  }\n  sort(sorted_arr.begin(), sorted_arr.end(), greater<int>());\n  vector<string> result;\n  for (int x : sorted_arr) {\n    result.push_back(digit_names[x]);\n  }\n  return result;\n}",
  "Java_humaneval-105": "public static List<String> byLength(List<Integer> arr) {\n  String[] digitNames = {\n      \"\",\n      \"One\",\n      \"Two\",\n      \"Three\",\n      \"Four\",\n      \"Five\",\n      \"Six\",\n      \"Seven\",\n      \"Eight\",\n      \"Nine\",\n  };\n  List<Integer> sortedArr = arr.stream()\n                                .filter(x -> x >= 1 && x <= 9)\n                                .sorted(Comparator.reverseOrder())\n                                .collect(Collectors.toList());\n  return sortedArr.stream().map(x -> digitNames[x]).collect(Collectors.toList());\n}",
  "Python_humaneval-105": "def by_length(arr: List[int]) -> List[str]:\n    digit_names = [\n        \"\",\n        \"One\",\n        \"Two\",\n        \"Three\",\n        \"Four\",\n        \"Five\",\n        \"Six\",\n        \"Seven\",\n        \"Eight\",\n        \"Nine\",\n    ]\n    sorted_arr = sorted([x for x in arr if 1 <= x <= 9])\n    sorted_arr.reverse()\n    return [digit_names[x] for x in sorted_arr]",
  "C#_humaneval-105": "public static List<string> ByLength(List<int> arr) {\n  string[] digitNames = { \"\",     \"One\", \"Two\",   \"Three\", \"Four\",\n                          \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\" };\n  List<int> sortedArr = arr.Where(x => x >= 1 && x <= 9).OrderByDescending(x => x).ToList();\n  return sortedArr.Select(x => digitNames[x]).ToList();\n}",
  "JavaScript_humaneval-105": "function byLength(arr) {\n  const digitNames = [\n    \"\",\n    \"One\",\n    \"Two\",\n    \"Three\",\n    \"Four\",\n    \"Five\",\n    \"Six\",\n    \"Seven\",\n    \"Eight\",\n    \"Nine\",\n  ];\n  const sortedArr = arr\n    .filter((x) => 1 <= x && x <= 9)\n    .sort()\n    .reverse();\n  return sortedArr.map((x) => digitNames[x]);\n}",
  "Go_humaneval-105": "func byLength(arr []int) []string {\n    digitNames := []string{\n        \"\",\n        \"One\",\n        \"Two\",\n        \"Three\",\n        \"Four\",\n        \"Five\",\n        \"Six\",\n        \"Seven\",\n        \"Eight\",\n        \"Nine\",\n    }\n    var sortedArr []int\n    for _, x := range arr {\n        if x >= 1 && x <= 9 {\n            sortedArr = append(sortedArr, x)\n        }\n    }\n    sort.Sort(sort.Reverse(sort.IntSlice(sortedArr)))\n    var result []string\n    for _, x := range sortedArr {\n        result = append(result, digitNames[x])\n    }\n    return result\n}",
  "PHP_humaneval-105": "function byLength(array $arr): array {\n    $digit_names = [\n        \"\",\n        \"One\",\n        \"Two\",\n        \"Three\",\n        \"Four\",\n        \"Five\",\n        \"Six\",\n        \"Seven\",\n        \"Eight\",\n        \"Nine\",\n    ];\n    $sorted_arr = array_values(array_filter($arr, function($x) {\n        return 1 <= $x && $x <= 9;\n    }));\n    rsort($sorted_arr);\n    return array_map(function($x) use ($digit_names) {\n        return $digit_names[$x];\n    }, $sorted_arr);\n}",
  "Ruby_humaneval-105": "def by_length(arr)\n  digit_names = [\n    \"\",\n    \"One\",\n    \"Two\",\n    \"Three\",\n    \"Four\",\n    \"Five\",\n    \"Six\",\n    \"Seven\",\n    \"Eight\",\n    \"Nine\"\n  ]\n  sorted_arr = arr.select { |x| (1..9).include?(x) }.sort.reverse\n  sorted_arr.map { |x| digit_names[x] }\nend",
  "Swift_humaneval-105": "func byLength(_ arr: [Int]) -> [String] {\n  let digitNames = [\n    \"\",\n    \"One\",\n    \"Two\",\n    \"Three\",\n    \"Four\",\n    \"Five\",\n    \"Six\",\n    \"Seven\",\n    \"Eight\",\n    \"Nine\",\n  ]\n  let sortedArr = arr.filter { 1...9 ~= $0 }.sorted().reversed()\n  return sortedArr.map { digitNames[$0] }\n}",
  "TypeScript_humaneval-105": "function byLength(arr: number[]): string[] {\n  const digitNames: string[] = [\n    \"\",\n    \"One\",\n    \"Two\",\n    \"Three\",\n    \"Four\",\n    \"Five\",\n    \"Six\",\n    \"Seven\",\n    \"Eight\",\n    \"Nine\",\n  ];\n  const sortedArr: number[] = arr\n    .filter((x) => x >= 1 && x <= 9)\n    .sort((a, b) => b - a);\n  return sortedArr.map((x) => digitNames[x]);\n}",
  "Dart_humaneval-105": "List<String> byLength(List<int> arr) {\n  List<String> digitNames = [\n    \"\",\n    \"One\",\n    \"Two\",\n    \"Three\",\n    \"Four\",\n    \"Five\",\n    \"Six\",\n    \"Seven\",\n    \"Eight\",\n    \"Nine\",\n  ];\n  List<int> sortedArr = arr.where((x) => x >= 1 && x <= 9).toList()\n    ..sort((a, b) => b.compareTo(a));\n  return sortedArr.map((x) => digitNames[x]).toList();\n}",
  "Rust_humaneval-105": "fn by_length(arr: Vec<i32>) -> Vec<String> {\n    let digit_names = vec![\n        \"\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\",\n    ];\n    let mut sorted_arr: Vec<i32> = arr.into_iter().filter(|&x| 1 <= x && x <= 9).collect();\n    sorted_arr.sort();\n    sorted_arr.reverse();\n    sorted_arr\n        .into_iter()\n        .map(|x| digit_names[x as usize].to_string())\n        .collect()\n}",
  "Scala_humaneval-105": "def byLength(arr: List[Int]): List[String] = {\n  val digitNames = List(\n    \"\",\n    \"One\",\n    \"Two\",\n    \"Three\",\n    \"Four\",\n    \"Five\",\n    \"Six\",\n    \"Seven\",\n    \"Eight\",\n    \"Nine\"\n  )\n  val sortedArr = arr.filter(x => x >= 1 && x <= 9).sorted.reverse\n  sortedArr.map(x => digitNames(x))\n}",
  "Kotlin_humaneval-105": "fun byLength(arr: List<Int>): List<String> {\n  val digitNames =\n    listOf(\"\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\")\n  val sortedArr = arr.filter { it in 1..9 }.sortedDescending()\n  return sortedArr.map { digitNames[it] }\n}",
  "C++_humaneval-106": "vector<int> f(int n) {\n  vector<int> result;\n  for (int i = 1; i <= n; i++) {\n    if (i % 2 == 0) {\n      int fact = 1;\n      for (int j = 1; j <= i; j++) {\n        fact *= j;\n      }\n      result.push_back(fact);\n    } else {\n      int s = 0;\n      for (int j = 1; j <= i; j++) {\n        s += j;\n      }\n      result.push_back(s);\n    }\n  }\n  return result;\n}",
  "Java_humaneval-106": "public static List<Integer> f(Integer n) {\n  List<Integer> result = new ArrayList<>();\n  for (int i = 1; i <= n; i++) {\n    if (i % 2 == 0) {\n      int fact = 1;\n      for (int j = 1; j <= i; j++) {\n        fact *= j;\n      }\n      result.add(fact);\n    } else {\n      int s = 0;\n      for (int j = 1; j <= i; j++) {\n        s += j;\n      }\n      result.add(s);\n    }\n  }\n  return result;\n}",
  "Python_humaneval-106": "def f(n: int) -> List[int]:\n    result = []\n    for i in range(1, n + 1):\n        if i % 2 == 0:\n            fact = 1\n            for j in range(1, i + 1):\n                fact *= j\n            result.append(fact)\n        else:\n            s = 0\n            for j in range(1, i + 1):\n                s += j\n            result.append(s)\n    return result",
  "C#_humaneval-106": "public static List<int> F(int n) {\n  List<int> result = new List<int>();\n  for (int i = 1; i <= n; i++) {\n    if (i % 2 == 0) {\n      int fact = 1;\n      for (int j = 1; j <= i; j++) {\n        fact *= j;\n      }\n      result.Add(fact);\n    } else {\n      int s = 0;\n      for (int j = 1; j <= i; j++) {\n        s += j;\n      }\n      result.Add(s);\n    }\n  }\n  return result;\n}",
  "JavaScript_humaneval-106": "function f(n) {\n  let result = [];\n  for (let i = 1; i <= n; i++) {\n    if (i % 2 === 0) {\n      let fact = 1;\n      for (let j = 1; j <= i; j++) {\n        fact *= j;\n      }\n      result.push(fact);\n    } else {\n      let s = 0;\n      for (let j = 1; j <= i; j++) {\n        s += j;\n      }\n      result.push(s);\n    }\n  }\n  return result;\n}",
  "Go_humaneval-106": "func f(n int) []int {\n    var result []int\n    for i := 1; i <= n; i++ {\n        if i%2 == 0 {\n            fact := 1\n            for j := 1; j <= i; j++ {\n                fact *= j\n            }\n            result = append(result, fact)\n        } else {\n            s := 0\n            for j := 1; j <= i; j++ {\n                s += j\n            }\n            result = append(result, s)\n        }\n    }\n    return result\n}",
  "PHP_humaneval-106": "function f(int $n): array {\n    $result = [];\n    for ($i = 1; $i <= $n; $i++) {\n        if ($i % 2 == 0) {\n            $fact = 1;\n            for ($j = 1; $j <= $i; $j++) {\n                $fact *= $j;\n            }\n            $result[] = $fact;\n        } else {\n            $s = 0;\n            for ($j = 1; $j <= $i; $j++) {\n                $s += $j;\n            }\n            $result[] = $s;\n        }\n    }\n    return $result;\n}",
  "Ruby_humaneval-106": "def f(n)\n  result = []\n  (1..n).each do |i|\n    if i % 2 == 0\n      fact = 1\n      (1..i).each { |j| fact *= j }\n      result << fact\n    else\n      s = 0\n      (1..i).each { |j| s += j }\n      result << s\n    end\n  end\n  result\nend",
  "Swift_humaneval-106": "func f(_ n: Int) -> [Int] {\n  var result = [Int]()\n  for i in 1...n {\n    if i % 2 == 0 {\n      var fact = 1\n      for j in 1...i {\n        fact *= j\n      }\n      result.append(fact)\n    } else {\n      var s = 0\n      for j in 1...i {\n        s += j\n      }\n      result.append(s)\n    }\n  }\n  return result\n}",
  "TypeScript_humaneval-106": "function f(n: number): number[] {\n  const result: number[] = [];\n  for (let i = 1; i <= n; i++) {\n    if (i % 2 === 0) {\n      let fact = 1;\n      for (let j = 1; j <= i; j++) {\n        fact *= j;\n      }\n      result.push(fact);\n    } else {\n      let s = 0;\n      for (let j = 1; j <= i; j++) {\n        s += j;\n      }\n      result.push(s);\n    }\n  }\n  return result;\n}",
  "Dart_humaneval-106": "List<int> f(int n) {\n  List<int> result = [];\n  for (int i = 1; i <= n; i++) {\n    if (i % 2 == 0) {\n      int fact = 1;\n      for (int j = 1; j <= i; j++) {\n        fact *= j;\n      }\n      result.add(fact);\n    } else {\n      int s = 0;\n      for (int j = 1; j <= i; j++) {\n        s += j;\n      }\n      result.add(s);\n    }\n  }\n  return result;\n}",
  "Rust_humaneval-106": "fn f(n: i32) -> Vec<i32> {\n    let mut result = vec![];\n    for i in 1..=n {\n        if i % 2 == 0 {\n            let mut fact = 1;\n            for j in 1..=i {\n                fact *= j;\n            }\n            result.push(fact);\n        } else {\n            let mut s = 0;\n            for j in 1..=i {\n                s += j;\n            }\n            result.push(s);\n        }\n    }\n    result\n}",
  "Scala_humaneval-106": "def f(n: Int): List[Int] = {\n  val result = ListBuffer[Int]()\n  for (i <- 1 to n) {\n    if (i % 2 == 0) {\n      var fact = 1\n      for (j <- 1 to i) {\n        fact *= j\n      }\n      result += fact\n    } else {\n      var s = 0\n      for (j <- 1 to i) {\n        s += j\n      }\n      result += s\n    }\n  }\n  result.toList\n}",
  "Kotlin_humaneval-106": "fun f(n: Int): List<Int> {\n  val result = mutableListOf<Int>()\n  for (i in 1..n) {\n    if (i % 2 == 0) {\n      var fact = 1\n      for (j in 1..i) {\n        fact *= j\n      }\n      result.add(fact)\n    } else {\n      var s = 0\n      for (j in 1..i) {\n        s += j\n      }\n      result.add(s)\n    }\n  }\n  return result\n}",
  "C++_humaneval-107": "vector<int> evenOddPalindrome(int n) {\n  int even_count = 0;\n  int odd_count = 0;\n  for (int i = 1; i <= n; i++) {\n    string str_i = to_string(i);\n    if (str_i == string(str_i.rbegin(), str_i.rend())) {\n      if (i % 2 == 0) {\n        even_count += 1;\n      } else {\n        odd_count += 1;\n      }\n    }\n  }\n  return {even_count, odd_count};\n}",
  "Java_humaneval-107": "public static List<Integer> evenOddPalindrome(Integer n) {\n  int evenCount = 0;\n  int oddCount = 0;\n  for (int i = 1; i <= n; i++) {\n    if (Integer.toString(i).equals(new StringBuilder(Integer.toString(i)).reverse().toString())) {\n      if (i % 2 == 0) {\n        evenCount++;\n      } else {\n        oddCount++;\n      }\n    }\n  }\n  List<Integer> result = new ArrayList<>();\n  result.add(evenCount);\n  result.add(oddCount);\n  return result;\n}",
  "Python_humaneval-107": "def even_odd_palindrome(n: int) -> List[int]:\n    even_count = 0\n    odd_count = 0\n    for i in range(1, n + 1):\n        if str(i) == str(i)[::-1]:\n            if i % 2 == 0:\n                even_count += 1\n            else:\n                odd_count += 1\n    return [even_count, odd_count]",
  "C#_humaneval-107": "public static List<int> EvenOddPalindrome(int n) {\n  int evenCount = 0;\n  int oddCount = 0;\n  for (int i = 1; i <= n; i++) {\n    if (i.ToString() == new string(i.ToString().Reverse().ToArray())) {\n      if (i % 2 == 0) {\n        evenCount++;\n      } else {\n        oddCount++;\n      }\n    }\n  }\n  return new List<int> { evenCount, oddCount };\n}",
  "JavaScript_humaneval-107": "function evenOddPalindrome(n) {\n  let evenCount = 0;\n  let oddCount = 0;\n  for (let i = 1; i <= n; i++) {\n    if (i.toString() === i.toString().split(\"\").reverse().join(\"\")) {\n      if (i % 2 === 0) {\n        evenCount++;\n      } else {\n        oddCount++;\n      }\n    }\n  }\n  return [evenCount, oddCount];\n}",
  "Go_humaneval-107": "func evenOddPalindrome(n int) []int {\n    evenCount := 0\n    oddCount := 0\n    for i := 1; i <= n; i++ {\n        if strconv.Itoa(i) == reverse(strconv.Itoa(i)) {\n            if i%2 == 0 {\n                evenCount++\n            } else {\n                oddCount++\n            }\n        }\n    }\n    return []int{evenCount, oddCount}\n}\nfunc reverse(s string) string {\n    r := []rune(s)\n    for i, j := 0, len(r)-1; i < len(r)/2; i, j = i+1, j-1 {\n        r[i], r[j] = r[j], r[i]\n    }\n    return string(r)\n}",
  "PHP_humaneval-107": "function evenOddPalindrome(int $n): array {\n    $even_count = 0;\n    $odd_count = 0;\n    for ($i = 1; $i <= $n; $i++) {\n        if ((string)$i === strrev((string)$i)) {\n            if ($i % 2 === 0) {\n                $even_count++;\n            } else {\n                $odd_count++;\n            }\n        }\n    }\n    return [$even_count, $odd_count];\n}",
  "Ruby_humaneval-107": "def even_odd_palindrome(n)\n  even_count = 0\n  odd_count = 0\n  (1..n).each do |i|\n    if i.to_s == i.to_s.reverse\n      if i.even?\n        even_count += 1\n      else\n        odd_count += 1\n      end\n    end\n  end\n  [even_count, odd_count]\nend",
  "Swift_humaneval-107": "func evenOddPalindrome(_ n: Int) -> [Int] {\n  var evenCount = 0\n  var oddCount = 0\n  for i in 1...n {\n    if String(i) == String(String(i).reversed()) {\n      if i % 2 == 0 {\n        evenCount += 1\n      } else {\n        oddCount += 1\n      }\n    }\n  }\n  return [evenCount, oddCount]\n}",
  "TypeScript_humaneval-107": "function evenOddPalindrome(n: number): number[] {\n  let evenCount = 0;\n  let oddCount = 0;\n  for (let i = 1; i <= n; i++) {\n    if (i.toString() === i.toString().split(\"\").reverse().join(\"\")) {\n      if (i % 2 === 0) {\n        evenCount++;\n      } else {\n        oddCount++;\n      }\n    }\n  }\n  return [evenCount, oddCount];\n}",
  "Dart_humaneval-107": "List<int> evenOddPalindrome(int n) {\n  int evenCount = 0;\n  int oddCount = 0;\n  for (int i = 1; i <= n; i++) {\n    if (i.toString() == i.toString().split('').reversed.join()) {\n      if (i % 2 == 0) {\n        evenCount++;\n      } else {\n        oddCount++;\n      }\n    }\n  }\n  return [evenCount, oddCount];\n}",
  "Rust_humaneval-107": "fn even_odd_palindrome(n: i32) -> Vec<i32> {\n    let mut even_count = 0;\n    let mut odd_count = 0;\n    for i in 1..=n {\n        if i.to_string() == i.to_string().chars().rev().collect::<String>() {\n            if i % 2 == 0 {\n                even_count += 1;\n            } else {\n                odd_count += 1;\n            }\n        }\n    }\n    vec![even_count, odd_count]\n}",
  "Scala_humaneval-107": "def evenOddPalindrome(n: Int): List[Int] = {\n  var evenCount = 0\n  var oddCount = 0\n  for (i <- 1 to n) {\n    if (i.toString == i.toString.reverse) {\n      if (i % 2 == 0) {\n        evenCount += 1\n      } else {\n        oddCount += 1\n      }\n    }\n  }\n  List(evenCount, oddCount)\n}",
  "Kotlin_humaneval-107": "fun evenOddPalindrome(n: Int): List<Int> {\n  var evenCount = 0\n  var oddCount = 0\n  for (i in 1..n) {\n    if (i.toString() == i.toString().reversed()) {\n      if (i % 2 == 0) {\n        evenCount++\n      } else {\n        oddCount++\n      }\n    }\n  }\n  return listOf(evenCount, oddCount)\n}",
  "C++_humaneval-108": "int digitsSum(int n) {\n  int neg = 1;\n  if (n < 0) {\n    n = -1 * n;\n    neg = -1;\n  }\n  string str_n = to_string(n);\n  vector<int> digits;\n  for (char c : str_n) {\n    digits.push_back(c - '0');\n  }\n  digits[0] = digits[0] * neg;\n  int sum = 0;\n  for (int digit : digits) {\n    sum += digit;\n  }\n  return sum;\n}\nint countNums(vector<int> arr) {\n  vector<int> digit_sums;\n  for (int i : arr) {\n    digit_sums.push_back(digitsSum(i));\n  }\n  vector<int> positive_sums;\n  for (int i : digit_sums) {\n    if (i > 0) {\n      positive_sums.push_back(i);\n    }\n  }\n  return positive_sums.size();\n}",
  "Java_humaneval-108": "public static Integer digitsSum(Integer n) {\n  Integer neg = 1;\n  if (n < 0) {\n    n = -1 * n;\n    neg = -1;\n  }\n  String numString = n.toString();\n  Integer[] numArray = new Integer[numString.length()];\n  for (int i = 0; i < numString.length(); i++) {\n    numArray[i] = Integer.parseInt(String.valueOf(numString.charAt(i)));\n  }\n  numArray[0] = numArray[0] * neg;\n  Integer sum = 0;\n  for (Integer num : numArray) {\n    sum += num;\n  }\n  return sum;\n}\npublic static Integer countNums(List<Integer> arr) {\n  Integer[] digitSums = new Integer[arr.size()];\n  for (int i = 0; i < arr.size(); i++) {\n    digitSums[i] = digitsSum(arr.get(i));\n  }\n  Integer count = 0;\n  for (Integer digitSum : digitSums) {\n    if (digitSum > 0) {\n      count++;\n    }\n  }\n  return count;\n}",
  "Python_humaneval-108": "def digits_sum(n):\n    neg = 1\n    if n < 0:\n        n, neg = -1 * n, -1\n    n = [int(i) for i in str(n)]\n    n[0] = n[0] * neg\n    return sum(n)\ndef count_nums(arr: List[int]) -> int:\n    digit_sums = [digits_sum(i) for i in arr]\n    positive_sums = [i for i in digit_sums if i > 0]\n    return len(positive_sums)",
  "C#_humaneval-108": "public static int DigitsSum(int n) {\n  int neg = 1;\n  if (n < 0) {\n    n = -1 * n;\n    neg = -1;\n  }\n  int[] digits = n.ToString().Select(c => int.Parse(c.ToString())).ToArray();\n  digits[0] = digits[0] * neg;\n  return digits.Sum();\n}\npublic static int CountNums(List<int> arr) {\n  List<int> digitSums = arr.Select(i => DigitsSum(i)).ToList();\n  List<int> positiveSums = digitSums.Where(i => i > 0).ToList();\n  return positiveSums.Count;\n}",
  "JavaScript_humaneval-108": "function digitsSum(n) {\n  let neg = 1;\n  if (n < 0) {\n    n = -1 * n;\n    neg = -1;\n  }\n  n = Array.from(String(n), Number);\n  n[0] = n[0] * neg;\n  return n.reduce((a, b) => a + b, 0);\n}\nfunction countNums(arr) {\n  const digitSums = arr.map(digitsSum);\n  const positiveSums = digitSums.filter((sum) => sum > 0);\n  return positiveSums.length;\n}",
  "Go_humaneval-108": "func digitsSum(n int) int {\n    neg := 1\n    if n < 0 {\n        n, neg = -1*n, -1\n    }\n    nStr := strconv.Itoa(n)\n    nArr := make([]int, len(nStr))\n    for i, digit := range nStr {\n        nArr[i], _ = strconv.Atoi(string(digit))\n    }\n    nArr[0] = nArr[0] * neg\n    sum := 0\n    for _, digit := range nArr {\n        sum += digit\n    }\n    return sum\n}\nfunc countNums(arr []int) int {\n    digitSums := make([]int, len(arr))\n    for i, num := range arr {\n        digitSums[i] = digitsSum(num)\n    }\n    positiveSums := make([]int, 0)\n    for _, sum := range digitSums {\n        if sum > 0 {\n            positiveSums = append(positiveSums, sum)\n        }\n    }\n    return len(positiveSums)\n}",
  "PHP_humaneval-108": "function digits_sum($n) {\n    $neg = 1;\n    if ($n < 0) {\n        $n = -1 * $n;\n        $neg = -1;\n    }\n    $n = str_split($n);\n    $n[0] = $n[0] * $neg;\n    return array_sum($n);\n}\nfunction countNums(array $arr): int {\n    $digit_sums = array_map('digits_sum', $arr);\n    $positive_sums = array_filter($digit_sums, function($i) {\n        return $i > 0;\n    });\n    return count($positive_sums);\n}",
  "Ruby_humaneval-108": "def digits_sum(n)\n  neg = 1\n  n, neg = -1 * n, -1 if n < 0\n  n = n.to_s.chars.map(&:to_i)\n  n[0] = n[0] * neg\n  return n.sum\nend\ndef count_nums(arr)\n  digit_sums = arr.map { |i| digits_sum(i) }\n  positive_sums = digit_sums.select { |i| i > 0 }\n  return positive_sums.length\nend",
  "Swift_humaneval-108": "func digitsSum(_ n: Int) -> Int {\n  var neg = 1\n  var n = n\n  if n < 0 {\n    n *= -1\n    neg = -1\n  }\n  var digits = String(n).compactMap { Int(String($0)) }\n  digits[0] *= neg\n  return digits.reduce(0, +)\n}\nfunc countNums(_ arr: [Int]) -> Int {\n  let digitSums = arr.map(digitsSum)\n  let positiveSums = digitSums.filter { $0 > 0 }\n  return positiveSums.count\n}",
  "TypeScript_humaneval-108": "function digitsSum(n: number): number {\n  let neg = 1;\n  if (n < 0) {\n    n = -1 * n;\n    neg = -1;\n  }\n  const digits = Array.from(String(n), Number);\n  digits[0] = digits[0] * neg;\n  return digits.reduce((a, b) => a + b, 0);\n}\nfunction countNums(arr: number[]): number {\n  const digitSums = arr.map((i) => digitsSum(i));\n  const positiveSums = digitSums.filter((i) => i > 0);\n  return positiveSums.length;\n}",
  "Dart_humaneval-108": "int digitsSum(int n) {\n  int neg = 1;\n  if (n < 0) {\n    n = -1 * n;\n    neg = -1;\n  }\n  List<int> digits = n.toString().split('').map(int.parse).toList();\n  digits[0] = digits[0] * neg;\n  return digits.reduce((a, b) => a + b);\n}\nint countNums(List<int> arr) {\n  List<int> digitSums = arr.map((i) => digitsSum(i)).toList();\n  List<int> positiveSums = digitSums.where((i) => i > 0).toList();\n  return positiveSums.length;\n}",
  "Rust_humaneval-108": "fn digits_sum(n: i32) -> i32 {\n    let mut neg = 1;\n    let mut num = n;\n    if n < 0 {\n        num = -n;\n        neg = -1;\n    }\n    let str_n = num.to_string();\n    let mut digits: Vec<i32> = str_n\n        .chars()\n        .map(|c| c.to_digit(10).unwrap() as i32)\n        .collect();\n    digits[0] *= neg;\n    let mut sum = 0;\n    for digit in digits {\n        sum += digit;\n    }\n    sum\n}\nfn count_nums(arr: Vec<i32>) -> i32 {\n    let digit_sums: Vec<i32> = arr.iter().map(|&i| digits_sum(i)).collect();\n    let positive_sums: Vec<i32> = digit_sums.iter().filter(|&&i| i > 0).cloned().collect();\n    positive_sums.len() as i32\n}",
  "Scala_humaneval-108": "def digitsSum(n: Int): Int = {\n  val neg = if (n < 0) -1 else 1\n  val digits = n.abs.toString.map(_.asDigit).toArray\n  digits(0) *= neg\n  digits.sum\n}\ndef countNums(arr: List[Int]): Int = {\n  val digitSums = arr.map(digitsSum)\n  val positiveSums = digitSums.filter(_ > 0)\n  positiveSums.length\n}",
  "Kotlin_humaneval-108": "fun digitsSum(n: Int): Int {\n  var neg = 1\n  var num = n\n  if (n < 0) {\n    num = -1 * n\n    neg = -1\n  }\n  val digits = num.toString().map { it.toString().toInt() }.toMutableList()\n  digits[0] = digits[0] * neg\n  return digits.sum()\n}\nfun countNums(arr: List<Int>): Int {\n  val digitSums = arr.map { digitsSum(it) }\n  val positiveSums = digitSums.filter { it > 0 }\n  return positiveSums.size\n}",
  "C++_humaneval-109": "bool moveOneBall(vector<int> arr) {\n  if (arr.size() == 0) {\n    return true;\n  }\n  vector<int> my_arr;\n  int min_value = *min_element(arr.begin(), arr.end());\n  int min_index = find(arr.begin(), arr.end(), min_value) - arr.begin();\n  my_arr.insert(my_arr.end(), arr.begin() + min_index, arr.end());\n  my_arr.insert(my_arr.end(), arr.begin(), arr.begin() + min_index);\n  vector<int> sorted_array = arr;\n  sort(sorted_array.begin(), sorted_array.end());\n  for (int i = 0; i < arr.size(); i++) {\n    if (my_arr[i] != sorted_array[i]) {\n      return false;\n    }\n  }\n  return true;\n}",
  "Java_humaneval-109": "public static Boolean moveOneBall(List<Integer> arr) {\n  if (arr.size() == 0) {\n    return true;\n  }\n  List<Integer> myArr = new ArrayList<Integer>();\n  int minIndex = arr.indexOf(Collections.min(arr));\n  myArr.addAll(arr.subList(minIndex, arr.size()));\n  myArr.addAll(arr.subList(0, minIndex));\n  List<Integer> sortedArray = new ArrayList<Integer>(arr);\n  Collections.sort(sortedArray);\n  for (int i = 0; i < arr.size(); i++) {\n    if (!myArr.get(i).equals(sortedArray.get(i))) {\n      return false;\n    }\n  }\n  return true;\n}",
  "Python_humaneval-109": "def move_one_ball(arr: List[int]) -> bool:\n    if len(arr) == 0:\n        return True\n    my_arr = []\n    min_value = min(arr)\n    min_index = arr.index(min_value)\n    my_arr = arr[min_index:] + arr[0:min_index]\n    sorted_array = sorted(arr)\n    for i in range(len(arr)):\n        if my_arr[i] != sorted_array[i]:\n            return False\n    return True",
  "C#_humaneval-109": "public static bool MoveOneBall(List<int> arr) {\n  if (arr.Count == 0) {\n    return true;\n  }\n  List<int> myArr = new List<int>();\n  int minIndex = arr.IndexOf(arr.Min());\n  myArr = arr.GetRange(minIndex, arr.Count - minIndex).Concat(arr.GetRange(0, minIndex)).ToList();\n  List<int> sortedArray = arr.OrderBy(x => x).ToList();\n  for (int i = 0; i < arr.Count; i++) {\n    if (myArr[i] != sortedArray[i]) {\n      return false;\n    }\n  }\n  return true;\n}",
  "JavaScript_humaneval-109": "function moveOneBall(arr) {\n  if (arr.length === 0) {\n    return true;\n  }\n  let myArr = [];\n  let minValue = Math.min(...arr);\n  let minIndex = arr.indexOf(minValue);\n  myArr = arr.slice(minIndex).concat(arr.slice(0, minIndex));\n  let sortedArray = [...arr].sort((a, b) => a - b);\n  for (let i = 0; i < arr.length; i++) {\n    if (myArr[i] !== sortedArray[i]) {\n      return false;\n    }\n  }\n  return true;\n}",
  "Go_humaneval-109": "func moveOneBall(arr []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    myArr := []int{}\n    minValue := arr[0]\n    minIndex := 0\n    for i, val := range arr {\n        if val < minValue {\n            minValue = val\n            minIndex = i\n        }\n    }\n    myArr = append(arr[minIndex:], arr[0:minIndex]...)\n    sortedArray := make([]int, len(arr))\n    copy(sortedArray, arr)\n    sort.Ints(sortedArray)\n    for i := 0; i < len(arr); i++ {\n        if myArr[i] != sortedArray[i] {\n            return false\n        }\n    }\n    return true\n}",
  "PHP_humaneval-109": "function moveOneBall(array $arr): bool {\n    if (count($arr) == 0) {\n        return true;\n    }\n    $my_arr = [];\n    $min_value = min($arr);\n    $min_index = array_search($min_value, $arr);\n    $my_arr = array_merge(array_slice($arr, $min_index), array_slice($arr, 0, $min_index));\n    $sorted_array = $arr;\n    sort($sorted_array);\n    for ($i = 0; $i < count($arr); $i++) {\n        if ($my_arr[$i] != $sorted_array[$i]) {\n            return false;\n        }\n    }\n    return true;\n}",
  "Ruby_humaneval-109": "def move_one_ball(arr)\n  return true if arr.empty?\n  my_arr = []\n  min_value = arr.min\n  min_index = arr.index(min_value)\n  my_arr = arr[min_index..-1] + arr[0...min_index]\n  sorted_array = arr.sort\n  (0...arr.length).each { |i| return false if my_arr[i] != sorted_array[i] }\n  true\nend",
  "Swift_humaneval-109": "func moveOneBall(_ arr: [Int]) -> Bool {\n  if arr.isEmpty {\n    return true\n  }\n  var myArr = [Int]()\n  let minValue = arr.min()!\n  let minIndex = arr.firstIndex(of: minValue)!\n  myArr = Array(arr[minIndex...]) + Array(arr[..<minIndex])\n  let sortedArray = arr.sorted()\n  for i in 0..<arr.count {\n    if myArr[i] != sortedArray[i] {\n      return false\n    }\n  }\n  return true\n}",
  "TypeScript_humaneval-109": "function moveOneBall(arr: number[]): boolean {\n  if (arr.length === 0) {\n    return true;\n  }\n  const myArr: number[] = [];\n  const minIndex = arr.indexOf(Math.min(...arr));\n  myArr.push(...arr.slice(minIndex), ...arr.slice(0, minIndex));\n  const sortedArray = [...arr].sort((a, b) => a - b);\n  for (let i = 0; i < arr.length; i++) {\n    if (myArr[i] !== sortedArray[i]) {\n      return false;\n    }\n  }\n  return true;\n}",
  "Dart_humaneval-109": "bool moveOneBall(List<int> arr) {\n  if (arr.isEmpty) {\n    return true;\n  }\n  List<int> myArr = [];\n  int minValue = arr.reduce(min);\n  int minIndex = arr.indexOf(minValue);\n  myArr = arr.sublist(minIndex) + arr.sublist(0, minIndex);\n  List<int> sortedArray = List.from(arr)..sort();\n  for (int i = 0; i < arr.length; i++) {\n    if (myArr[i] != sortedArray[i]) {\n      return false;\n    }\n  }\n  return true;\n}",
  "Rust_humaneval-109": "fn move_one_ball(arr: Vec<i32>) -> bool {\n    if arr.is_empty() {\n        return true;\n    }\n    let min_value = *arr.iter().min().unwrap();\n    let min_index = arr.iter().position(|&x| x == min_value).unwrap();\n    let mut my_arr = arr[min_index..].to_vec();\n    my_arr.extend(&arr[..min_index]);\n    let mut sorted_array = arr.clone();\n    sorted_array.sort();\n    for i in 0..arr.len() {\n        if my_arr[i] != sorted_array[i] {\n            return false;\n        }\n    }\n    true\n}",
  "Scala_humaneval-109": "def moveOneBall(arr: List[Int]): Boolean = {\n  if (arr.isEmpty) {\n    true\n  } else {\n    val minIndex = arr.indexOf(arr.min)\n    val myArr = arr.drop(minIndex) ++ arr.take(minIndex)\n    val sortedArray = arr.sorted\n    myArr == sortedArray\n  }\n}",
  "Kotlin_humaneval-109": "fun moveOneBall(arr: List<Int>): Boolean {\n  if (arr.isEmpty()) {\n    return true\n  }\n  val myArr = mutableListOf<Int>()\n  val minVal = arr.minOrNull()!!\n  val minIndex = arr.indexOf(minVal)\n  myArr.addAll(arr.subList(minIndex, arr.size))\n  myArr.addAll(arr.subList(0, minIndex))\n  val sortedArr = arr.sorted()\n  for (i in arr.indices) {\n    if (myArr[i] != sortedArr[i]) {\n      return false\n    }\n  }\n  return true\n}",
  "C++_humaneval-110": "string exchange(vector<int> l1, vector<int> l2) {\n  if (all_of(l1.begin(), l1.end(), [](int num) { return num % 2 == 0; })) {\n    return \"YES\";\n  }\n  vector<int> odd_nums;\n  for (int num : l1) {\n    if (num % 2 != 0) {\n      odd_nums.push_back(num);\n    }\n  }\n  vector<int> even_nums;\n  for (int num : l2) {\n    if (num % 2 == 0) {\n      even_nums.push_back(num);\n    }\n  }\n  if (even_nums.size() >= odd_nums.size()) {\n    return \"YES\";\n  } else {\n    return \"NO\";\n  }\n}",
  "Java_humaneval-110": "public static String exchange(List<Integer> l1, List<Integer> l2) {\n  if (l1.stream().allMatch(num -> num % 2 == 0)) {\n    return \"YES\";\n  }\n  List<Integer> oddNums = l1.stream().filter(num -> num % 2 != 0).collect(Collectors.toList());\n  List<Integer> evenNums = l2.stream().filter(num -> num % 2 == 0).collect(Collectors.toList());\n  if (evenNums.size() >= oddNums.size()) {\n    return \"YES\";\n  } else {\n    return \"NO\";\n  }\n}",
  "Python_humaneval-110": "def exchange(l1: List[int], l2: List[int]) -> str:\n    if all(num % 2 == 0 for num in l1):\n        return \"YES\"\n    odd_nums = [num for num in l1 if num % 2 != 0]\n    even_nums = [num for num in l2 if num % 2 == 0]\n    if len(even_nums) >= len(odd_nums):\n        return \"YES\"\n    else:\n        return \"NO\"",
  "C#_humaneval-110": "public static string Exchange(List<int> l1, List<int> l2) {\n  if (l1.All(num => num % 2 == 0)) {\n    return \"YES\";\n  }\n  List<int> odd_nums = l1.Where(num => num % 2 != 0).ToList();\n  List<int> even_nums = l2.Where(num => num % 2 == 0).ToList();\n  if (even_nums.Count >= odd_nums.Count) {\n    return \"YES\";\n  } else {\n    return \"NO\";\n  }\n}",
  "JavaScript_humaneval-110": "function exchange(l1, l2) {\n  if (l1.every((num) => num % 2 === 0)) {\n    return \"YES\";\n  }\n  let odd_nums = l1.filter((num) => num % 2 !== 0);\n  let even_nums = l2.filter((num) => num % 2 === 0);\n  if (even_nums.length >= odd_nums.length) {\n    return \"YES\";\n  } else {\n    return \"NO\";\n  }\n}",
  "Go_humaneval-110": "func exchange(l1 []int, l2 []int) string {\n    allEven := true\n    for _, num := range l1 {\n        if num%2 != 0 {\n            allEven = false\n            break\n        }\n    }\n    if allEven {\n        return \"YES\"\n    }\n    oddNums := []int{}\n    for _, num := range l1 {\n        if num%2 != 0 {\n            oddNums = append(oddNums, num)\n        }\n    }\n    evenNums := []int{}\n    for _, num := range l2 {\n        if num%2 == 0 {\n            evenNums = append(evenNums, num)\n        }\n    }\n    if len(evenNums) >= len(oddNums) {\n        return \"YES\"\n    } else {\n        return \"NO\"\n    }\n}",
  "PHP_humaneval-110": "function exchange(array $l1, array $l2): string {\n    if (array_filter($l1, function($num) { return $num % 2 !== 0; }) === []) {\n        return \"YES\";\n    }\n    $odd_nums = array_filter($l1, function($num) { return $num % 2 !== 0; });\n    $even_nums = array_filter($l2, function($num) { return $num % 2 === 0; });\n    if (count($even_nums) >= count($odd_nums)) {\n        return \"YES\";\n    } else {\n        return \"NO\";\n    }\n}",
  "Ruby_humaneval-110": "def exchange(l1, l2)\n  return \"YES\" if l1.all? { |num| num.even? }\n  odd_nums = l1.select { |num| num.odd? }\n  even_nums = l2.select { |num| num.even? }\n  if even_nums.length >= odd_nums.length\n    return \"YES\"\n  else\n    return \"NO\"\n  end\nend",
  "Swift_humaneval-110": "func exchange(_ l1: [Int], _ l2: [Int]) -> String {\n  if l1.allSatisfy({ $0 % 2 == 0 }) {\n    return \"YES\"\n  }\n  let oddNums = l1.filter { $0 % 2 != 0 }\n  let evenNums = l2.filter { $0 % 2 == 0 }\n  if evenNums.count >= oddNums.count {\n    return \"YES\"\n  } else {\n    return \"NO\"\n  }\n}",
  "TypeScript_humaneval-110": "function exchange(l1: number[], l2: number[]): string {\n  if (l1.every((num) => num % 2 === 0)) {\n    return \"YES\";\n  }\n  const odd_nums = l1.filter((num) => num % 2 !== 0);\n  const even_nums = l2.filter((num) => num % 2 === 0);\n  if (even_nums.length >= odd_nums.length) {\n    return \"YES\";\n  } else {\n    return \"NO\";\n  }\n}",
  "Dart_humaneval-110": "String exchange(List<int> l1, List<int> l2) {\n  if (l1.every((num) => num % 2 == 0)) {\n    return \"YES\";\n  }\n  var oddNums = l1.where((num) => num % 2 != 0).toList();\n  var evenNums = l2.where((num) => num % 2 == 0).toList();\n  if (evenNums.length >= oddNums.length) {\n    return \"YES\";\n  } else {\n    return \"NO\";\n  }\n}",
  "Rust_humaneval-110": "fn exchange(l1: Vec<i32>, l2: Vec<i32>) -> String {\n    if l1.iter().all(|&num| num % 2 == 0) {\n        return String::from(\"YES\");\n    }\n    let odd_nums: Vec<i32> = l1.iter().filter(|&num| num % 2 != 0).cloned().collect();\n    let even_nums: Vec<i32> = l2.iter().filter(|&num| num % 2 == 0).cloned().collect();\n    if even_nums.len() >= odd_nums.len() {\n        return String::from(\"YES\");\n    } else {\n        return String::from(\"NO\");\n    }\n}",
  "Scala_humaneval-110": "def exchange(l1: List[Int], l2: List[Int]): String = {\n  if (l1.forall(_ % 2 == 0)) {\n    \"YES\"\n  } else {\n    val oddNums = l1.filter(_ % 2 != 0)\n    val evenNums = l2.filter(_ % 2 == 0)\n    if (evenNums.length >= oddNums.length) {\n      \"YES\"\n    } else {\n      \"NO\"\n    }\n  }\n}",
  "Kotlin_humaneval-110": "fun exchange(l1: List<Int>, l2: List<Int>): String {\n  if (l1.all { num -> num % 2 == 0 }) {\n    return \"YES\"\n  }\n  val oddNums = l1.filter { num -> num % 2 != 0 }\n  val evenNums = l2.filter { num -> num % 2 == 0 }\n  return if (evenNums.size >= oddNums.size) \"YES\" else \"NO\"\n}",
  "C++_humaneval-111": "unorderedMap<string, int> histogram(string test) {\n  unordered_map<string, int> counts;\n  int max_count = 0;\n  istringstream iss(test);\n  string letter;\n  while (iss >> letter) {\n    if (counts.find(letter) != counts.end()) {\n      counts[letter]++;\n    } else {\n      counts[letter] = 1;\n    }\n    if (counts[letter] > max_count) {\n      max_count = counts[letter];\n    }\n  }\n  unordered_map<string, int> result;\n  for (auto& kv : counts) {\n    if (kv.second == max_count) {\n      result[kv.first] = kv.second;\n    }\n  }\n  return result;\n}",
  "Java_humaneval-111": "public static Map<String, Integer> histogram(String test) {\n  String[] letters = test.split(\" \");\n  Map<String, Integer> counts = new HashMap<>();\n  int maxCount = 0;\n  for (String letter : letters) {\n    if (counts.containsKey(letter)) {\n      counts.put(letter, counts.get(letter) + 1);\n    } else {\n      counts.put(letter, 1);\n    }\n    if (counts.get(letter) > maxCount) {\n      maxCount = counts.get(letter);\n    }\n  }\n  Map<String, Integer> result = new HashMap<>();\n  for (Map.Entry<String, Integer> entry : counts.entrySet()) {\n    if (entry.getValue() == maxCount) {\n      result.put(entry.getKey(), entry.getValue());\n    }\n  }\n  return result;\n}",
  "Python_humaneval-111": "def histogram(test: str) -> Dict[str, int]:\n    letters = test.split()\n    counts = {}\n    max_count = 0\n    for letter in letters:\n        if letter in counts:\n            counts[letter] += 1\n        else:\n            counts[letter] = 1\n        if counts[letter] > max_count:\n            max_count = counts[letter]\n    result = {}\n    for letter, count in counts.items():\n        if count == max_count:\n            result[letter] = count\n    return result",
  "C#_humaneval-111": "public static Dictionary<string, int> Histogram(string test) {\n  string[] letters = test.Split();\n  Dictionary<string, int> counts = new Dictionary<string, int>();\n  int max_count = 0;\n  foreach (string letter in letters) {\n    if (counts.ContainsKey(letter)) {\n      counts[letter]++;\n    } else {\n      counts[letter] = 1;\n    }\n    if (counts[letter] > max_count) {\n      max_count = counts[letter];\n    }\n  }\n  Dictionary<string, int> result = new Dictionary<string, int>();\n  foreach (KeyValuePair<string, int> pair in counts) {\n    if (pair.Value == max_count) {\n      result[pair.Key] = pair.Value;\n    }\n  }\n  return result;\n}",
  "JavaScript_humaneval-111": "function histogram(test) {\n  let letters = test.split(\" \");\n  let counts = new Map();\n  let maxCount = 0;\n  for (let letter of letters) {\n    if (counts.has(letter)) {\n      counts.set(letter, counts.get(letter) + 1);\n    } else {\n      counts.set(letter, 1);\n    }\n    if (counts.get(letter) > maxCount) {\n      maxCount = counts.get(letter);\n    }\n  }\n  let result = new Map();\n  for (let [letter, count] of counts) {\n    if (count === maxCount) {\n      result.set(letter, count);\n    }\n  }\n  return result;\n}",
  "Go_humaneval-111": "func histogram(test string) map[string]int {\n    letters := strings.Fields(test)\n    counts := make(map[string]int)\n    maxCount := 0\n    for _, letter := range letters {\n        counts[letter]++\n        if counts[letter] > maxCount {\n            maxCount = counts[letter]\n        }\n    }\n    result := make(map[string]int)\n    for letter, count := range counts {\n        if count == maxCount {\n            result[letter] = count\n        }\n    }\n    return result\n}",
  "PHP_humaneval-111": "function histogram(string $test): array {\n    $letters = explode(' ', $test);\n    $counts = [];\n    $max_count = 0;\n    foreach ($letters as $letter) {\n        if (isset($counts[$letter])) {\n            $counts[$letter] += 1;\n        } else {\n            $counts[$letter] = 1;\n        }\n        if ($counts[$letter] > $max_count) {\n            $max_count = $counts[$letter];\n        }\n    }\n    $result = [];\n    foreach ($counts as $letter => $count) {\n        if ($count == $max_count) {\n            $result[$letter] = $count;\n        }\n    }\n    return $result;\n}",
  "Ruby_humaneval-111": "def histogram(test)\n  letters = test.split\n  counts = {}\n  max_count = 0\n  letters.each do |letter|\n    if counts.key?(letter)\n      counts[letter] += 1\n    else\n      counts[letter] = 1\n    end\n    max_count = counts[letter] if counts[letter] > max_count\n  end\n  result = {}\n  counts.each { |letter, count| result[letter] = count if count == max_count }\n  result\nend",
  "Swift_humaneval-111": "func histogram(_ test: String) -> [String: Int] {\n  let letters = test.split(separator: \" \").map({ String($0) })\n  var counts = [String: Int]()\n  var maxCount = 0\n  for letter in letters {\n    counts[letter, default: 0] += 1\n    if counts[letter]! > maxCount {\n      maxCount = counts[letter]!\n    }\n  }\n  var result = [String: Int]()\n  for (letter, count) in counts {\n    if count == maxCount {\n      result[letter] = count\n    }\n  }\n  return result\n}",
  "TypeScript_humaneval-111": "function histogram(test: string): Map<string, number> {\n  const letters = test.split(\" \");\n  const counts: { [key: string]: number } = {};\n  let maxCount = 0;\n  for (const letter of letters) {\n    if (letter in counts) {\n      counts[letter] += 1;\n    } else {\n      counts[letter] = 1;\n    }\n    if (counts[letter] > maxCount) {\n      maxCount = counts[letter];\n    }\n  }\n  const result: Map<string, number> = new Map();\n  for (const [letter, count] of Object.entries(counts)) {\n    if (count === maxCount) {\n      result.set(letter, count);\n    }\n  }\n  return result;\n}",
  "Dart_humaneval-111": "Map<String, int> histogram(String test) {\n  List<String> letters = test.split(\" \");\n  Map<String, int> counts = {};\n  int maxCount = 0;\n  for (String letter in letters) {\n    counts[letter] = (counts[letter] ?? 0) + 1;\n    if (counts[letter]! > maxCount) {\n      maxCount = counts[letter]!;\n    }\n  }\n  Map<String, int> result = {};\n  for (String letter in counts.keys) {\n    if (counts[letter]! == maxCount) {\n      result[letter] = counts[letter]!;\n    }\n  }\n  return result;\n}",
  "Rust_humaneval-111": "fn histogram(test: String) -> HashMap<String, i32> {\n    let letters = test.split_whitespace();\n    let mut counts = HashMap::new();\n    let mut max_count = 0;\n    for letter in letters {\n        let count = counts.entry(String::from(letter)).or_insert(0);\n        *count += 1;\n        if *count > max_count {\n            max_count = *count;\n        }\n    }\n    let mut result = HashMap::new();\n    for (letter, count) in counts {\n        if count == max_count {\n            result.insert(letter, count);\n        }\n    }\n    result\n}",
  "Scala_humaneval-111": "def histogram(test: String): Map[String, Int] = {\n  val letters = test.split(\" \")\n  var counts = Map[String, Int]()\n  var maxCount = 0\n  for (letter <- letters) {\n    counts = counts + (letter -> (counts.getOrElse(letter, 0) + 1))\n    if (counts(letter) > maxCount) {\n      maxCount = counts(letter)\n    }\n  }\n  val result = counts.filter(_._2 == maxCount)\n  result\n}",
  "Kotlin_humaneval-111": "fun histogram(test: String): Map<String, Int> {\n  val letters = test.split(\" \")\n  val counts = mutableMapOf<String, Int>()\n  var maxCount = 0\n  for (letter in letters) {\n    if (counts.containsKey(letter)) {\n      counts[letter] = counts[letter]!! + 1\n    } else {\n      counts[letter] = 1\n    }\n    if (counts[letter]!! > maxCount) {\n      maxCount = counts[letter]!!\n    }\n  }\n  val result = mutableMapOf<String, Int>()\n  for ((letter, count) in counts) {\n    if (count == maxCount) {\n      result[letter] = count\n    }\n  }\n  return result\n}",
  "C++_humaneval-112": "vector<string> reverseDelete(string s, string c) {\n  for (char ch : c) {\n    s.erase(remove(s.begin(), s.end(), ch), s.end());\n  }\n  string s_reversed(s.rbegin(), s.rend());\n  bool is_palindrome = s == s_reversed;\n  return {s, (is_palindrome ? \"YES\" : \"NO\")};\n}",
  "Java_humaneval-112": "public static List<String> reverseDelete(String s, String c) {\n  List<String> result = new ArrayList<>();\n  for (char ch : c.toCharArray()) {\n    s = s.replace(String.valueOf(ch), \"\");\n  }\n  boolean isPalindrome = s.equals(new StringBuilder(s).reverse().toString());\n  result.add(s);\n  result.add(isPalindrome ? \"YES\" : \"NO\");\n  return result;\n}",
  "Python_humaneval-112": "def reverse_delete(s: str, c: str) -> List[str]:\n    for char in c:\n        s = s.replace(char, \"\")\n    is_palindrome = s == s[::-1]\n    return [s, \"YES\" if is_palindrome else \"NO\"]",
  "C#_humaneval-112": "public static List<string> ReverseDelete(string s, string c) {\n  foreach (char ch in c) {\n    s = s.Replace(ch.ToString(), \"\");\n  }\n  bool isPalindrome = s.SequenceEqual(s.Reverse());\n  return new List<string> { s, isPalindrome ? \"YES\" : \"NO\" };\n}",
  "JavaScript_humaneval-112": "function reverseDelete(s, c) {\n  for (let i = 0; i < c.length; i++) {\n    s = s.replaceAll(c[i], \"\");\n  }\n  const isPalindrome = s === s.split(\"\").reverse().join(\"\");\n  return [s, isPalindrome ? \"YES\" : \"NO\"];\n}",
  "Go_humaneval-112": "func reverseDelete(s string, c string) []string {\n    for _, char := range c {\n        s = strings.ReplaceAll(s, string(char), \"\")\n    }\n    isPalindrome := true\n    for i := 0; i < len(s)/2; i++ {\n        if s[i] != s[len(s)-i-1] {\n            isPalindrome = false\n            break\n        }\n    }\n    if isPalindrome {\n        return []string{s, \"YES\"}\n    } else {\n        return []string{s, \"NO\"}\n    }\n}",
  "PHP_humaneval-112": "function reverseDelete(string $s, string $c): array {\n    $s = str_replace(str_split($c), '', $s);\n    $is_palindrome = $s === strrev($s);\n    return [$s, $is_palindrome ? 'YES' : 'NO'];\n}",
  "Ruby_humaneval-112": "def reverse_delete(s, c)\n  c.each_char { |char| s.gsub!(char, \"\") }\n  is_palindrome = s == s.reverse\n  [s, is_palindrome ? \"YES\" : \"NO\"]\nend",
  "Swift_humaneval-112": "func reverseDelete(_ s: String, _ c: String) -> [String] {\n  var s = s\n  for char in c {\n    s = s.replacingOccurrences(of: String(char), with: \"\")\n  }\n  let isPalindrome = s == String(s.reversed())\n  return [s, isPalindrome ? \"YES\" : \"NO\"]\n}",
  "TypeScript_humaneval-112": "function reverseDelete(s: string, c: string): string[] {\n  for (const char of c) {\n    s = s.replaceAll(char, \"\");\n  }\n  const isPalindrome = s === s.split(\"\").reverse().join(\"\");\n  return [s, isPalindrome ? \"YES\" : \"NO\"];\n}",
  "Dart_humaneval-112": "List<String> reverseDelete(String s, String c) {\n  for (var char in c.split('')) {\n    s = s.replaceAll(char, '');\n  }\n  bool isPalindrome = s == s.split('').reversed.join();\n  return [s, isPalindrome ? 'YES' : 'NO'];\n}",
  "Rust_humaneval-112": "fn reverse_delete(s: String, c: String) -> Vec<String> {\n    let mut s = s;\n    for char in c.chars() {\n        s = s.replace(char, \"\");\n    }\n    let is_palindrome = s == s.chars().rev().collect::<String>();\n    vec![s, if is_palindrome { \"YES\" } else { \"NO\" }.to_string()]\n}",
  "Scala_humaneval-112": "def reverseDelete(s: String, c: String): List[String] = {\n  val newS = c.foldLeft(s)((acc, char) => acc.replace(char.toString, \"\"))\n  val isPalindrome = newS == newS.reverse\n  List(newS, if (isPalindrome) \"YES\" else \"NO\")\n}",
  "Kotlin_humaneval-112": "fun reverseDelete(s: String, c: String): List<String> {\n  var str = s\n  for (char in c) {\n    str = str.replace(char.toString(), \"\")\n  }\n  val isPalindrome = str == str.reversed()\n  return listOf(str, if (isPalindrome) \"YES\" else \"NO\")\n}",
  "C++_humaneval-113": "vector<string> oddCount(vector<string> l) {\n  vector<string> res;\n  for (const string& arr : l) {\n    int n = 0;\n    for (char c : arr) {\n      if (isdigit(c) && (c - '0') % 2 == 1) {\n        n++;\n      }\n    }\n    string resultStr =\n        \"the number of odd elements in the string i of the input.\";\n    size_t found = resultStr.find(\"i\");\n    while (found != std::string::npos) {\n      resultStr.replace(found, 1, std::to_string(n));\n      found = resultStr.find(\"i\", found + 1);\n    }\n    res.push_back(resultStr);\n  }\n  return res;\n}",
  "Java_humaneval-113": "public static List<String> oddCount(List<String> l) {\n  List<String> res = new ArrayList<>();\n  for (String arr : l) {\n    int n = 0;\n    for (char c : arr.toCharArray()) {\n      if (Character.isDigit(c) && (c - '0') % 2 == 1) {\n        n++;\n      }\n    }\n    String resultStr = \"the number of odd elements in the string i of the input.\";\n    resultStr = resultStr.replace(\"i\", Integer.toString(n));\n    res.add(resultStr);\n  }\n  return res;\n}",
  "Python_humaneval-113": "def odd_count(l: List[str]) -> List[str]:\n    res = []\n    for arr in l:\n        n = sum(int(d) % 2 == 1 for d in arr)\n        result_str = f\"the number of odd elements in the string i of the input.\"\n        result_str = result_str.replace(\"i\", str(n))\n        res.append(result_str)\n    return res",
  "C#_humaneval-113": "public static List<string> OddCount(List<string> l) {\n  List<string> res = new List<string>();\n  foreach (string arr in l) {\n    int n = 0;\n    foreach (char c in arr) {\n      if (Char.IsDigit(c) && (c - '0') % 2 == 1) {\n        n++;\n      }\n    }\n    string resultStr = \"the number of odd elements in the string i of the input.\";\n    resultStr = resultStr.Replace(\"i\", n.ToString());\n    res.Add(resultStr);\n  }\n  return res;\n}",
  "JavaScript_humaneval-113": "function oddCount(l) {\n  const res = [];\n  for (const arr of l) {\n    let n = 0;\n    for (const c of arr) {\n      if (!isNaN(c) && parseInt(c) % 2 === 1) {\n        n++;\n      }\n    }\n    let resultStr = \"the number of odd elements in the string i of the input.\";\n    resultStr = resultStr.replaceAll(\"i\", n.toString());\n    res.push(resultStr);\n  }\n  return res;\n}",
  "Go_humaneval-113": "func oddCount(l []string) []string {\n    var res []string\n    for _, arr := range l {\n        n := 0\n        for _, c := range arr {\n            if c >= '0' && c <= '9' && int(c-'0')%2 == 1 {\n                n++\n            }\n        }\n        resultStr := \"the number of odd elements in the string i of the input.\"\n        resultStr = strings.ReplaceAll(resultStr, \"i\", strconv.Itoa(n))\n        res = append(res, resultStr)\n    }\n    return res\n}",
  "PHP_humaneval-113": "function oddCount(array $l): array {\n    $res = [];\n    foreach ($l as $arr) {\n        $n = 0;\n        for ($i = 0; $i < strlen($arr); $i++) {\n            $c = $arr[$i];\n            if (is_numeric($c) && intval($c) % 2 == 1) {\n                $n++;\n            }\n        }\n        $resultStr = \"the number of odd elements in the string i of the input.\";\n        $resultStr = str_replace(\"i\", strval($n), $resultStr);\n        array_push($res, $resultStr);\n    }\n    return $res;\n}",
  "Ruby_humaneval-113": "def odd_count(l)\n  res = []\n  l.each do |arr|\n    n = 0\n    arr.each_char { |c| n += 1 if c.match?(/\\d/) && c.to_i % 2 == 1 }\n    result_str = \"the number of odd elements in the string i of the input.\"\n    result_str.gsub!(\"i\", n.to_s)\n    res.push(result_str)\n  end\n  res\nend",
  "Swift_humaneval-113": "func oddCount(_ l: [String]) -> [String] {\n  var res = [String]()\n  for arr in l {\n    var n = 0\n    for c in arr {\n      if let digit = Int(String(c)), digit % 2 == 1 {\n        n += 1\n      }\n    }\n    var resultStr = \"the number of odd elements in the string i of the input.\"\n    resultStr = resultStr.replacingOccurrences(of: \"i\", with: String(n))\n    res.append(resultStr)\n  }\n  return res\n}",
  "TypeScript_humaneval-113": "function oddCount(l: string[]): string[] {\n  const res: string[] = [];\n  for (const arr of l) {\n    let n = 0;\n    for (const c of arr) {\n      if (!isNaN(Number(c)) && parseInt(c) % 2 === 1) {\n        n++;\n      }\n    }\n    let resultStr = \"the number of odd elements in the string i of the input.\";\n    resultStr = resultStr.replaceAll(\"i\", n.toString());\n    res.push(resultStr);\n  }\n  return res;\n}",
  "Dart_humaneval-113": "List<String> oddCount(List<String> l) {\n  List<String> res = [];\n  for (String arr in l) {\n    int n = 0;\n    for (var c in arr.runes) {\n      if (c >= 48 && c <= 57 && (c - 48) % 2 == 1) {\n        n++;\n      }\n    }\n    String resultStr =\n        \"the number of odd elements in the string i of the input.\";\n    resultStr = resultStr.replaceAll(\"i\", n.toString());\n    res.add(resultStr);\n  }\n  return res;\n}",
  "Rust_humaneval-113": "fn odd_count(l: Vec<String>) -> Vec<String> {\n    let mut res = Vec::new();\n    for arr in l {\n        let mut n = 0;\n        for c in arr.chars() {\n            if c.is_digit(10) && (c.to_digit(10).unwrap() % 2 == 1) {\n                n += 1;\n            }\n        }\n        let mut result_str =\n            String::from(\"the number of odd elements in the string i of the input.\");\n        result_str = result_str.replace(\"i\", &n.to_string());\n        res.push(result_str);\n    }\n    res\n}",
  "Scala_humaneval-113": "def oddCount(l: List[String]): List[String] = {\n  var res = List[String]()\n  for (arr <- l) {\n    var n = 0\n    for (c <- arr) {\n      if (c.isDigit && (c - '0') % 2 == 1) {\n        n += 1\n      }\n    }\n    var resultStr = \"the number of odd elements in the string i of the input.\"\n    resultStr = resultStr.replace(\"i\", n.toString)\n    res = res :+ resultStr\n  }\n  res\n}",
  "Kotlin_humaneval-113": "fun oddCount(l: List<String>): List<String> {\n  val res = mutableListOf<String>()\n  for (arr in l) {\n    var n = 0\n    for (c in arr.toCharArray()) {\n      if (c.isDigit() && (c - '0') % 2 == 1) {\n        n++\n      }\n    }\n    var resultStr = \"the number of odd elements in the string i of the input.\"\n    resultStr = resultStr.replace(\"i\", n.toString())\n    res.add(resultStr)\n  }\n  return res\n}",
  "C++_humaneval-114": "int minSubArraySum(vector<int> nums) {\n  int min_sum = numeric_limits<int>::max();\n  int current_sum = 0;\n  for (int num : nums) {\n    current_sum += num;\n    current_sum = min(current_sum, 0);\n    min_sum = min(min_sum, current_sum);\n  }\n  if (min_sum == 0) {\n    min_sum = *min_element(nums.begin(), nums.end());\n  }\n  return min_sum;\n}",
  "Java_humaneval-114": "public static Integer minSubArraySum(List<Integer> nums) {\n  int minSum = Integer.MAX_VALUE;\n  int currentSum = 0;\n  for (int num : nums) {\n    currentSum += num;\n    currentSum = Math.min(currentSum, 0);\n    minSum = Math.min(minSum, currentSum);\n  }\n  if (minSum == 0) {\n    minSum = Collections.min(nums);\n  }\n  return minSum;\n}",
  "Python_humaneval-114": "def min_sub_array_sum(nums: List[int]) -> int:\n    min_sum = float(\"inf\")\n    current_sum = 0\n    for num in nums:\n        current_sum += num\n        current_sum = min(current_sum, 0)\n        min_sum = min(min_sum, current_sum)\n    if min_sum == 0:\n        min_sum = min(i for i in nums)\n    return min_sum",
  "C#_humaneval-114": "public static int MinSubArraySum(List<int> nums) {\n  int min_sum = int.MaxValue;\n  int current_sum = 0;\n  foreach (int num in nums) {\n    current_sum += num;\n    current_sum = Math.Min(current_sum, 0);\n    min_sum = Math.Min(min_sum, current_sum);\n  }\n  if (min_sum == 0) {\n    min_sum = nums.Min();\n  }\n  return min_sum;\n}",
  "JavaScript_humaneval-114": "function minSubArraySum(nums) {\n  let min_sum = Infinity;\n  let current_sum = 0;\n  for (let num of nums) {\n    current_sum += num;\n    current_sum = Math.min(current_sum, 0);\n    min_sum = Math.min(min_sum, current_sum);\n  }\n  if (min_sum === 0) {\n    min_sum = Math.min(...nums);\n  }\n  return min_sum;\n}",
  "Go_humaneval-114": "func minSubArraySum(nums []int) int {\n    minSum := math.MaxInt64\n    currentSum := 0\n    for _, num := range nums {\n        currentSum += num\n        currentSum = min(currentSum, 0)\n        minSum = min(minSum, currentSum)\n    }\n    if minSum == 0 {\n        minSum = min(nums...)\n    }\n    return minSum\n}\nfunc min(nums ...int) int {\n    minNum := math.MaxInt64\n    for _, num := range nums {\n        if num < minNum {\n            minNum = num\n        }\n    }\n    return minNum\n}",
  "PHP_humaneval-114": "function minSubArraySum(array $nums): int {\n    $min_sum = INF;\n    $current_sum = 0;\n    foreach ($nums as $num) {\n        $current_sum += $num;\n        $current_sum = min($current_sum, 0);\n        $min_sum = min($min_sum, $current_sum);\n    }\n    if ($min_sum == 0) {\n        $min_sum = min($nums);\n    }\n    return $min_sum;\n}",
  "Ruby_humaneval-114": "def min_sub_array_sum(nums)\n  min_sum = Float::INFINITY\n  current_sum = 0\n  nums.each do |num|\n    current_sum += num\n    current_sum = [current_sum, 0].min\n    min_sum = [min_sum, current_sum].min\n  end\n  min_sum = nums.min if min_sum == 0\n  min_sum\nend",
  "Swift_humaneval-114": "func minSubArraySum(_ nums: [Int]) -> Int {\n  var minSum = Int.max\n  var currentSum = 0\n  for num in nums {\n    currentSum += num\n    currentSum = min(currentSum, 0)\n    minSum = min(minSum, currentSum)\n  }\n  if minSum == 0 {\n    minSum = nums.min() ?? 0\n  }\n  return minSum\n}",
  "TypeScript_humaneval-114": "function minSubArraySum(nums: number[]): number {\n  let minSum = Number.POSITIVE_INFINITY;\n  let currentSum = 0;\n  for (const num of nums) {\n    currentSum += num;\n    currentSum = Math.min(currentSum, 0);\n    minSum = Math.min(minSum, currentSum);\n  }\n  if (minSum === 0) {\n    minSum = Math.min(...nums);\n  }\n  return minSum;\n}",
  "Dart_humaneval-114": "int minSubArraySum(List<int> nums) {\n  int minSum = double.maxFinite.toInt();\n  int currentSum = 0;\n  for (int num in nums) {\n    currentSum += num;\n    currentSum = min(currentSum, 0);\n    minSum = min(minSum, currentSum);\n  }\n  if (minSum == 0) {\n    minSum = nums.reduce(min);\n  }\n  return minSum;\n}",
  "Rust_humaneval-114": "fn min_sub_array_sum(nums: Vec<i32>) -> i32 {\n    let mut min_sum = i32::MAX;\n    let mut current_sum = 0;\n    for num in &nums {\n        current_sum += num;\n        current_sum = current_sum.min(0);\n        min_sum = min_sum.min(current_sum);\n    }\n    if min_sum == 0 {\n        min_sum = *nums.iter().min().unwrap();\n    }\n    min_sum\n}",
  "Scala_humaneval-114": "def minSubArraySum(nums: List[Int]): Int = {\n  var minSum = Int.MaxValue\n  var currentSum = 0\n  for (num <- nums) {\n    currentSum += num\n    currentSum = currentSum.min(0)\n    minSum = minSum.min(currentSum)\n  }\n  if (minSum == 0) {\n    minSum = nums.min\n  }\n  minSum\n}",
  "Kotlin_humaneval-114": "fun minSubArraySum(nums: List<Int>): Int {\n  var minSum = Int.MAX_VALUE\n  var currentSum = 0\n  for (num in nums) {\n    currentSum += num\n    currentSum = min(currentSum, 0)\n    minSum = min(minSum, currentSum)\n  }\n  if (minSum == 0) {\n    minSum = nums.minOrNull() ?: 0\n  }\n  return minSum\n}",
  "C++_humaneval-115": "int maxFill(vector<vector<int>> grid, int capacity) {\n  int result = 0;\n  for (auto arr : grid) {\n    result += ceil((double)accumulate(arr.begin(), arr.end(), 0) / capacity);\n  }\n  return result;\n}",
  "Java_humaneval-115": "public static Integer maxFill(List<List<Integer>> grid, Integer capacity) {\n  return grid.stream()\n      .mapToInt(arr\n          -> (int) Math.ceil(arr.stream().mapToInt(Integer::intValue).sum() / (double) capacity))\n      .sum();\n}",
  "Python_humaneval-115": "def max_fill(grid: List[List[int]], capacity: int) -> int:\n    return sum([math.ceil(sum(arr) / capacity) for arr in grid])",
  "C#_humaneval-115": "public static int MaxFill(List<List<int>> grid, int capacity) {\n  return grid.Sum(arr => (int)Math.Ceiling(arr.Sum() / (double)capacity));\n}",
  "JavaScript_humaneval-115": "function maxFill(grid, capacity) {\n  return grid.reduce(\n    (acc, arr) => acc + Math.ceil(arr.reduce((a, b) => a + b) / capacity),\n    0,\n  );\n}",
  "Go_humaneval-115": "func maxFill(grid [][]int, capacity int) int {\n    var total int\n    for _, arr := range grid {\n        sum := 0\n        for _, val := range arr {\n            sum += val\n        }\n        total += int(math.Ceil(float64(sum) / float64(capacity)))\n    }\n    return total\n}",
  "PHP_humaneval-115": "function maxFill(array $grid, int $capacity): int {\n    $sum = 0;\n    foreach ($grid as $arr) {\n        $sum += ceil(array_sum($arr) / $capacity);\n    }\n    return $sum;\n}",
  "Ruby_humaneval-115": "def max_fill(grid, capacity)\n  grid.sum { |arr| (arr.sum / capacity.to_f).ceil }\nend",
  "Swift_humaneval-115": "func maxFill(_ grid: [[Int]], _ capacity: Int) -> Int {\n  return grid.reduce(0) { $0 + Int(ceil(Double($1.reduce(0, +)) / Double(capacity))) }\n}",
  "TypeScript_humaneval-115": "function maxFill(grid: number[][], capacity: number): number {\n  return grid.reduce(\n    (acc, arr) => acc + Math.ceil(arr.reduce((a, b) => a + b, 0) / capacity),\n    0,\n  );\n}",
  "Dart_humaneval-115": "int maxFill(List<List<int>> grid, int capacity) {\n  return grid\n      .map((arr) => (arr.reduce((a, b) => a + b) / capacity).ceil())\n      .reduce((a, b) => a + b);\n}",
  "Rust_humaneval-115": "fn max_fill(grid: Vec<Vec<i32>>, capacity: i32) -> i32 {\n    let mut total = 0;\n    for arr in grid {\n        let sum_arr: f64 = arr.iter().sum::<i32>() as f64;\n        total += (sum_arr / capacity as f64).ceil() as i32;\n    }\n    total\n}",
  "Scala_humaneval-115": "def maxFill(grid: List[List[Int]], capacity: Int): Int = {\n  grid.map(arr => ceil(arr.sum.toDouble / capacity).toInt).sum\n}",
  "Kotlin_humaneval-115": "fun maxFill(grid: List<List<Int>>, capacity: Int): Int {\n  return grid.sumBy { ceil(it.sum().toDouble() / capacity).toInt() }\n}",
  "C++_humaneval-116": "vector<int> sortArray(vector<int> arr) {\n  sort(arr.begin(), arr.end(), [](int a, int b) {\n    int a1 = bitset<32>(a).count();\n    int b1 = bitset<32>(b).count();\n    if (a1 == b1) {\n      return a < b;\n    } else {\n      return a1 < b1;\n    }\n  });\n  return arr;\n}",
  "Java_humaneval-116": "public static List<Integer> sortArray(List<Integer> arr) {\n  arr.sort((a, b) -> {\n    int a1 = Integer.bitCount(a);\n    int b1 = Integer.bitCount(b);\n    if (a1 == b1) {\n      return a - b;\n    } else {\n      return a1 - b1;\n    }\n  });\n  return arr;\n}",
  "Python_humaneval-116": "def sort_array(arr: List[int]) -> List[int]:\n    return sorted(arr, key=lambda x: (bin(x).count(\"1\"), x))",
  "C#_humaneval-116": "public static List<int> SortArray(List<int> arr) {\n  arr.Sort((a, b) => {\n    int a1 = Convert.ToString(a, 2).Count(c => c == '1');\n    int b1 = Convert.ToString(b, 2).Count(c => c == '1');\n    if (a1 == b1) {\n      return a - b;\n    } else {\n      return a1 - b1;\n    }\n  });\n  return arr;\n}",
  "JavaScript_humaneval-116": "function sortArray(arr) {\n  arr.sort((a, b) => {\n    const a1 = a.toString(2).split(\"1\").length - 1;\n    const b1 = b.toString(2).split(\"1\").length - 1;\n    if (a1 === b1) {\n      return a - b;\n    } else {\n      return a1 - b1;\n    }\n  });\n  return arr;\n}",
  "Go_humaneval-116": "func sortArray(arr []int) []int {\n    sort.SliceStable(arr, func(i, j int) bool {\n        a1 := bits.OnesCount(uint(arr[i]))\n        b1 := bits.OnesCount(uint(arr[j]))\n        if a1 == b1 {\n            return arr[i] < arr[j]\n        }\n        return a1 < b1\n    })\n    return arr\n}",
  "PHP_humaneval-116": "function sortArray(array $arr): array {\n    usort($arr, function ($a, $b) {\n        $a1 = substr_count(decbin($a), '1');\n        $b1 = substr_count(decbin($b), '1');\n        if ($a1 == $b1) {\n            return $a - $b;\n        }\n        return $a1 - $b1;\n    });\n    return $arr;\n}",
  "Ruby_humaneval-116": "def sort_array(arr)\n  arr.sort_by { |x| [x.to_s(2).count(\"1\"), x] }\nend",
  "Swift_humaneval-116": "func sortArray(_ arr: [Int]) -> [Int] {\n  return arr.sorted(by: { a, b in\n    let a1 = String(a, radix: 2).filter { $0 == \"1\" }.count\n    let b1 = String(b, radix: 2).filter { $0 == \"1\" }.count\n    if a1 == b1 {\n      return a < b\n    } else {\n      return a1 < b1\n    }\n  })\n}",
  "TypeScript_humaneval-116": "function sortArray(arr: number[]): number[] {\n  arr.sort((a, b) => {\n    const a1 = a.toString(2).split(\"1\").length - 1;\n    const b1 = b.toString(2).split(\"1\").length - 1;\n    if (a1 === b1) {\n      return a - b;\n    } else {\n      return a1 - b1;\n    }\n  });\n  return arr;\n}",
  "Dart_humaneval-116": "List<int> sortArray(List<int> arr) {\n  arr.sort((a, b) {\n    int a1 = a.toRadixString(2).split('').where((c) => c == '1').length;\n    int b1 = b.toRadixString(2).split('').where((c) => c == '1').length;\n    if (a1 == b1) {\n      return a.compareTo(b);\n    } else {\n      return a1.compareTo(b1);\n    }\n  });\n  return arr;\n}",
  "Rust_humaneval-116": "fn sort_array(arr: Vec<i32>) -> Vec<i32> {\n    let mut arr = arr;\n    arr.sort_by(|a, b| {\n        let a1 = a.count_ones();\n        let b1 = b.count_ones();\n        if a1 == b1 {\n            a.cmp(b)\n        } else {\n            a1.cmp(&b1)\n        }\n    });\n    arr\n}",
  "Scala_humaneval-116": "def sortArray(arr: List[Int]): List[Int] = {\n  arr.sortBy(x => (Integer.bitCount(x), x))\n}",
  "Kotlin_humaneval-116": "fun sortArray(arr: List<Int>): List<Int> {\n  val arr = arr.toMutableList()\n  arr.sortWith(compareBy({ Integer.bitCount(it) }, { it }))\n  return arr\n}",
  "C++_humaneval-117": "vector<string> selectWords(string s, int n) {\n  vector<string> words;\n  string word = \"\";\n  for (auto c : s) {\n    if (c == ' ') {\n      words.push_back(word);\n      word = \"\";\n    } else {\n      word += c;\n    }\n  }\n  words.push_back(word);\n  vector<string> result;\n  for (auto word : words) {\n    int consonants = 0;\n    for (auto letter : word) {\n      if (tolower(letter) != 'a' && tolower(letter) != 'e' &&\n          tolower(letter) != 'i' && tolower(letter) != 'o' &&\n          tolower(letter) != 'u' && isalpha(letter)) {\n        consonants++;\n      }\n    }\n    if (consonants == n) {\n      result.push_back(word);\n    }\n  }\n  return result;\n}",
  "Java_humaneval-117": "public static List<String> selectWords(String s, Integer n) {\n  String[] words = s.split(\" \");\n  List<String> result = new ArrayList<>();\n  for (String word : words) {\n    int consonants = 0;\n    for (char letter : word.toCharArray()) {\n      if (!\"AEIOUaeiou\".contains(Character.toString(letter)) && Character.isLetter(letter)) {\n        consonants++;\n      }\n    }\n    if (consonants == n) {\n      result.add(word);\n    }\n  }\n  return result;\n}",
  "Python_humaneval-117": "def select_words(s: str, n: int) -> List[str]:\n    words = s.split()\n    result = []\n    for word in words:\n        consonants = 0\n        for letter in word:\n            if letter.lower() not in \"aeiou\" and letter.isalpha():\n                consonants += 1\n        if consonants == n:\n            result.append(word)\n    return result",
  "C#_humaneval-117": "public static List<string> SelectWords(string s, int n) {\n  string[] words = s.Split();\n  List<string> result = new List<string>();\n  foreach (string word in words) {\n    int consonants = 0;\n    foreach (char letter in word) {\n      if (!\"aeiou\".Contains(letter.ToString().ToLower()) && char.IsLetter(letter)) {\n        consonants++;\n      }\n    }\n    if (consonants == n) {\n      result.Add(word);\n    }\n  }\n  return result;\n}",
  "JavaScript_humaneval-117": "function selectWords(s, n) {\n  const words = s.split(\" \");\n  const result = [];\n  for (const word of words) {\n    let consonants = 0;\n    for (const letter of word) {\n      if (!\"aeiou\".includes(letter.toLowerCase()) && letter.match(/[a-z]/i)) {\n        consonants++;\n      }\n    }\n    if (consonants === n) {\n      result.push(word);\n    }\n  }\n  return result;\n}",
  "Go_humaneval-117": "func selectWords(s string, n int) []string {\n    words := strings.Split(s, \" \")\n    result := []string{}\n    for _, word := range words {\n        consonants := 0\n        for _, letter := range word {\n            if !strings.Contains(\"aeiouAEIOU\", string(letter)) && unicode.IsLetter(letter) {\n                consonants++\n            }\n        }\n        if consonants == n {\n            result = append(result, word)\n        }\n    }\n    return result\n}",
  "PHP_humaneval-117": "function selectWords(string $s, int $n): array {\n    $words = explode(\" \", $s);\n    $result = [];\n    foreach ($words as $word) {\n        $consonants = 0;\n        $letters = str_split($word);\n        foreach ($letters as $letter) {\n            if (!in_array(strtolower($letter), [\"a\", \"e\", \"i\", \"o\", \"u\"]) && ctype_alpha($letter)) {\n                $consonants++;\n            }\n        }\n        if ($consonants == $n) {\n            $result[] = $word;\n        }\n    }\n    return $result;\n}",
  "Ruby_humaneval-117": "def select_words(s, n)\n  words = s.split\n  result = []\n  words.each do |word|\n    consonants = 0\n    word.each_char do |letter|\n      if !(\"aeiou\".include?(letter.downcase)) && letter.match?(/[[:alpha:]]/)\n        consonants += 1\n      end\n    end\n    result << word if consonants == n\n  end\n  result\nend",
  "Swift_humaneval-117": "func selectWords(_ s: String, _ n: Int) -> [String] {\n  let words = s.split(separator: \" \")\n  var result = [String]()\n  for word in words {\n    var consonants = 0\n    for letter in word.lowercased() {\n      if !(\"aeiou\".contains(letter)) && letter.isLetter {\n        consonants += 1\n      }\n    }\n    if consonants == n {\n      result.append(String(word))\n    }\n  }\n  return result\n}",
  "TypeScript_humaneval-117": "function selectWords(s: string, n: number): string[] {\n  const words = s.split(\" \");\n  const result: string[] = [];\n  for (const word of words) {\n    let consonants = 0;\n    for (const letter of word) {\n      if (!\"aeiou\".includes(letter.toLowerCase()) && letter.match(/[a-zA-Z]/)) {\n        consonants++;\n      }\n    }\n    if (consonants === n) {\n      result.push(word);\n    }\n  }\n  return result;\n}",
  "Dart_humaneval-117": "List<String> selectWords(String s, int n) {\n  List<String> words = s.split(' ');\n  List<String> result = [];\n  for (String word in words) {\n    int consonants = 0;\n    for (int i = 0; i < word.length; i++) {\n      String letter = word[i];\n      if (!\"aeiou\".contains(letter.toLowerCase()) &&\n          letter.contains(RegExp('[a-zA-Z]'))) {\n        consonants++;\n      }\n    }\n    if (consonants == n) {\n      result.add(word);\n    }\n  }\n  return result;\n}",
  "Rust_humaneval-117": "fn select_words(s: String, n: i32) -> Vec<String> {\n    let words: Vec<&str> = s.split_whitespace().collect();\n    let mut result = Vec::new();\n    for word in words {\n        let mut consonants = 0;\n        for letter in word.chars() {\n            if !matches!(letter.to_ascii_lowercase(), 'a' | 'e' | 'i' | 'o' | 'u')\n                && letter.is_alphabetic()\n            {\n                consonants += 1;\n            }\n        }\n        if consonants == n {\n            result.push(word.to_string());\n        }\n    }\n    result\n}",
  "Scala_humaneval-117": "def selectWords(s: String, n: Int): List[String] = {\n  val words = s.split(\" \")\n  var result = List[String]()\n  for (word <- words) {\n    var consonants = 0\n    for (letter <- word) {\n      if (!\"aeiou\".contains(letter.toLower) && letter.isLetter) {\n        consonants += 1\n      }\n    }\n    if (consonants == n) {\n      result = result :+ word\n    }\n  }\n  result\n}",
  "Kotlin_humaneval-117": "fun selectWords(s: String, n: Int): List<String> {\n  val words = s.split(\" \")\n  val result = mutableListOf<String>()\n  for (word in words) {\n    var consonants = 0\n    for (letter in word) {\n      if (letter.toLowerCase() !in \"aeiou\" && letter.isLetter()) {\n        consonants++\n      }\n    }\n    if (consonants == n) {\n      result.add(word)\n    }\n  }\n  return result\n}",
  "C++_humaneval-118": "string getClosestVowel(string word) {\n  unordered_set<char> vowels = {'a', 'e', 'i', 'o', 'u'};\n  transform(word.begin(), word.end(), word.begin(), ::tolower);\n  for (int i = word.size() - 2; i > 0; i--) {\n    if (vowels.count(word[i]) && !vowels.count(word[i - 1]) &&\n        !vowels.count(word[i + 1])) {\n      return isupper(word[i]) ? string(1, toupper(word[i]))\n                              : string(1, word[i]);\n    }\n  }\n  return \"\";\n}",
  "Java_humaneval-118": "public static String getClosestVowel(String word) {\n  Set<Character> vowels = new HashSet<>(Arrays.asList('a', 'e', 'i', 'o', 'u'));\n  word = word.toLowerCase();\n  for (int i = word.length() - 2; i > 0; i--) {\n    if (vowels.contains(word.charAt(i)) && !vowels.contains(word.charAt(i - 1))\n        && !vowels.contains(word.charAt(i + 1))) {\n      return Character.isUpperCase(word.charAt(i))\n          ? Character.toString(word.charAt(i)).toUpperCase()\n          : Character.toString(word.charAt(i));\n    }\n  }\n  return \"\";\n}",
  "Python_humaneval-118": "def get_closest_vowel(word: str) -> str:\n    vowels = set([\"a\", \"e\", \"i\", \"o\", \"u\"])\n    word = word.lower()\n    for i in range(len(word) - 2, 0, -1):\n        if (\n            word[i] in vowels\n            and word[i - 1] not in vowels\n            and word[i + 1] not in vowels\n        ):\n            return word[i].upper() if word[i].isupper() else word[i]\n    return \"\"",
  "C#_humaneval-118": "public static string GetClosestVowel(string word) {\n  HashSet<char> vowels = new HashSet<char>(new char[] { 'a', 'e', 'i', 'o', 'u' });\n  word = word.ToLower();\n  for (int i = word.Length - 2; i > 0; i--) {\n    if (vowels.Contains(word[i]) && !vowels.Contains(word[i - 1]) &&\n        !vowels.Contains(word[i + 1])) {\n      return char.IsUpper(word[i]) ? char.ToUpper(word[i]).ToString() : word[i].ToString();\n    }\n  }\n  return \"\";\n}",
  "JavaScript_humaneval-118": "function getClosestVowel(word) {\n  const vowels = new Set([\"a\", \"e\", \"i\", \"o\", \"u\"]);\n  word = word.toLowerCase();\n  for (let i = word.length - 2; i > 0; i--) {\n    if (\n      vowels.has(word[i]) &&\n      !vowels.has(word[i - 1]) &&\n      !vowels.has(word[i + 1])\n    ) {\n      return word[i].toUpperCase() === word[i]\n        ? word[i].toUpperCase()\n        : word[i];\n    }\n  }\n  return \"\";\n}",
  "Go_humaneval-118": "func getClosestVowel(word string) string {\n    vowels := map[rune]bool{'a': true, 'e': true, 'i': true, 'o': true, 'u': true}\n    word = strings.ToLower(word)\n    for i := len(word) - 2; i > 0; i-- {\n        if vowels[rune(word[i])] && !vowels[rune(word[i-1])] && !vowels[rune(word[i+1])] {\n            if unicode.IsUpper(rune(word[i])) {\n                return strings.ToUpper(string(word[i]))\n            }\n            return string(word[i])\n        }\n    }\n    return \"\"\n}",
  "PHP_humaneval-118": "function getClosestVowel(string $word): string {\n    $vowels = array(\"a\", \"e\", \"i\", \"o\", \"u\");\n    $word = strtolower($word);\n    for ($i = strlen($word) - 2; $i > 0; $i--) {\n        if (in_array($word[$i], $vowels) && !in_array($word[$i - 1], $vowels) && !in_array($word[$i + 1], $vowels)) {\n            return strtoupper($word[$i]) === $word[$i] ? strtoupper($word[$i]) : $word[$i];\n        }\n    }\n    return \"\";\n}",
  "Ruby_humaneval-118": "def get_closest_vowel(word)\n  vowels = %w[a e i o u]\n  word = word.downcase\n  (word.length - 2).downto(1) do |i|\n    if vowels.include?(word[i]) && !vowels.include?(word[i - 1]) &&\n         !vowels.include?(word[i + 1])\n      return word[i].upcase if word[i] == word[i].upcase\n      return word[i]\n    end\n  end\n  \"\"\nend",
  "Swift_humaneval-118": "func getClosestVowel(_ word: String) -> String {\n  let vowels: Set<Character> = [\"a\", \"e\", \"i\", \"o\", \"u\"]\n  var word = word.lowercased()\n  for i in stride(from: word.count - 2, to: 0, by: -1) {\n    let index = word.index(word.startIndex, offsetBy: i)\n    if vowels.contains(word[index])\n      && !vowels.contains(word[word.index(before: index)])\n      && !vowels.contains(word[word.index(after: index)])\n    {\n      return word[index].isUppercase ? String(word[index]).uppercased() : String(word[index])\n    }\n  }\n  return \"\"\n}",
  "TypeScript_humaneval-118": "function getClosestVowel(word: string): string {\n  const vowels = new Set([\"a\", \"e\", \"i\", \"o\", \"u\"]);\n  word = word.toLowerCase();\n  for (let i = word.length - 2; i > 0; i--) {\n    if (\n      vowels.has(word[i]) &&\n      !vowels.has(word[i - 1]) &&\n      !vowels.has(word[i + 1])\n    ) {\n      return word[i].toUpperCase() === word[i]\n        ? word[i].toUpperCase()\n        : word[i];\n    }\n  }\n  return \"\";\n}",
  "Dart_humaneval-118": "String getClosestVowel(String word) {\n  Set<String> vowels = {\"a\", \"e\", \"i\", \"o\", \"u\"};\n  word = word.toLowerCase();\n  for (int i = word.length - 2; i >= 1; i--) {\n    if (vowels.contains(word[i]) &&\n        !vowels.contains(word[i - 1]) &&\n        !vowels.contains(word[i + 1])) {\n      return word[i].toUpperCase() == word[i] ? word[i].toUpperCase() : word[i];\n    }\n  }\n  return \"\";\n}",
  "Rust_humaneval-118": "fn get_closest_vowel(word: String) -> String {\n    let vowels = vec!['a', 'e', 'i', 'o', 'u'];\n    let word = word.to_lowercase();\n    for i in (1..word.len() - 1).rev() {\n        if vowels.contains(&word.chars().nth(i).unwrap())\n            && !vowels.contains(&word.chars().nth(i - 1).unwrap())\n            && !vowels.contains(&word.chars().nth(i + 1).unwrap())\n        {\n            return if word.chars().nth(i).unwrap().is_uppercase() {\n                word.chars().nth(i).unwrap().to_uppercase().to_string()\n            } else {\n                word.chars().nth(i).unwrap().to_string()\n            };\n        }\n    }\n    \"\".to_string()\n}",
  "Scala_humaneval-118": "def getClosestVowel(word: String): String = {\n  val vowels = Set('a', 'e', 'i', 'o', 'u')\n  val lowerCaseWord = word.toLowerCase()\n  for (i <- Range(word.length - 2, 0, -1)) {\n    if (\n      vowels.contains(lowerCaseWord(i)) && !vowels.contains(\n        lowerCaseWord(i - 1)\n      ) && !vowels.contains(lowerCaseWord(i + 1))\n    ) {\n      return if (word(i).isUpper) word(i).toString.toUpperCase\n      else word(i).toString\n    }\n  }\n  \"\"\n}",
  "Kotlin_humaneval-118": "fun getClosestVowel(word: String): String {\n  val vowels = setOf('a', 'e', 'i', 'o', 'u')\n  val lowerCaseWord = word.toLowerCase()\n  for (i in lowerCaseWord.length - 2 downTo 1) {\n    if (lowerCaseWord[i] in vowels && lowerCaseWord[i - 1] !in vowels && lowerCaseWord[i + 1] !in vowels) {\n      return if (lowerCaseWord[i].isUpperCase()) lowerCaseWord[i].toString().toUpperCase() else lowerCaseWord[i].toString()\n    }\n  }\n  return \"\"\n}",
  "C++_humaneval-119": "bool check(string s) {\n  int val = 0;\n  for (char i : s) {\n    if (i == '(') {\n      val++;\n    } else {\n      val--;\n    }\n    if (val < 0) {\n      return false;\n    }\n  }\n  return (val == 0);\n}\nstring matchParens(vector<string> l) {\n  string s1 = l[0] + l[1];\n  string s2 = l[1] + l[0];\n  return (check(s1) || check(s2)) ? \"Yes\" : \"No\";\n}",
  "Java_humaneval-119": "public static String matchParens(List<String> l) {\n  String s1 = l.get(0) + l.get(1);\n  String s2 = l.get(1) + l.get(0);\n  return check(s1) || check(s2) ? \"Yes\" : \"No\";\n}\npublic static boolean check(String s) {\n  int val = 0;\n  for (char i : s.toCharArray()) {\n    if (i == '(') {\n      val++;\n    } else {\n      val--;\n    }\n    if (val < 0) {\n      return false;\n    }\n  }\n  return val == 0;\n}",
  "Python_humaneval-119": "def check(s):\n    val = 0\n    for i in s:\n        if i == \"(\":\n            val = val + 1\n        else:\n            val = val - 1\n        if val < 0:\n            return False\n    return True if val == 0 else False\ndef match_parens(l: List[str]) -> str:\n    s1 = l[0] + l[1]\n    s2 = l[1] + l[0]\n    return \"Yes\" if check(s1) or check(s2) else \"No\"",
  "C#_humaneval-119": "public static string MatchParens(List<string> l) {\n  string s1 = l[0] + l[1];\n  string s2 = l[1] + l[0];\n  return Check(s1) || Check(s2) ? \"Yes\" : \"No\";\n}\npublic static bool Check(string s) {\n  int val = 0;\n  foreach (char i in s) {\n    if (i == '(') {\n      val++;\n    } else {\n      val--;\n    }\n    if (val < 0) {\n      return false;\n    }\n  }\n  return val == 0 ? true : false;\n}",
  "JavaScript_humaneval-119": "function check(s) {\n  let val = 0;\n  for (let i of s) {\n    if (i === \"(\") {\n      val++;\n    } else {\n      val--;\n    }\n    if (val < 0) {\n      return false;\n    }\n  }\n  return val === 0 ? true : false;\n}\nfunction matchParens(l) {\n  let s1 = l[0] + l[1];\n  let s2 = l[1] + l[0];\n  return check(s1) || check(s2) ? \"Yes\" : \"No\";\n}",
  "Go_humaneval-119": "func check(s string) bool {\n    val := 0\n    for _, i := range s {\n        if i == '(' {\n            val++\n        } else {\n            val--\n        }\n        if val < 0 {\n            return false\n        }\n    }\n    return val == 0\n}\nfunc matchParens(l []string) string {\n    s1 := l[0] + l[1]\n    s2 := l[1] + l[0]\n    if check(s1) || check(s2) {\n        return \"Yes\"\n    }\n    return \"No\"\n}",
  "PHP_humaneval-119": "function check($s) {\n    $val = 0;\n    for ($i = 0; $i < strlen($s); $i++) {\n        if ($s[$i] == \"(\") {\n            $val = $val + 1;\n        } else {\n            $val = $val - 1;\n        }\n        if ($val < 0) {\n            return false;\n        }\n    }\n    return $val == 0 ? true : false;\n}\nfunction matchParens(array $l): string {\n    $s1 = $l[0] . $l[1];\n    $s2 = $l[1] . $l[0];\n    return check($s1) || check($s2) ? \"Yes\" : \"No\";\n}",
  "Ruby_humaneval-119": "def check(s)\n  val = 0\n  s.each_char do |i|\n    if i == \"(\"\n      val = val + 1\n    else\n      val = val - 1\n    end\n    return false if val < 0\n  end\n  val == 0\nend\ndef match_parens(l)\n  s1 = l[0] + l[1]\n  s2 = l[1] + l[0]\n  check(s1) || check(s2) ? \"Yes\" : \"No\"\nend",
  "Swift_humaneval-119": "func check(_ s: String) -> Bool {\n  var val = 0\n  for i in s {\n    if i == \"(\" {\n      val += 1\n    } else {\n      val -= 1\n    }\n    if val < 0 {\n      return false\n    }\n  }\n  return val == 0 ? true : false\n}\nfunc matchParens(_ l: [String]) -> String {\n  let s1 = l[0] + l[1]\n  let s2 = l[1] + l[0]\n  return check(s1) || check(s2) ? \"Yes\" : \"No\"\n}",
  "TypeScript_humaneval-119": "function check(s: string): boolean {\n  let val = 0;\n  for (let i = 0; i < s.length; i++) {\n    if (s[i] === \"(\") {\n      val++;\n    } else {\n      val--;\n    }\n    if (val < 0) {\n      return false;\n    }\n  }\n  return val === 0 ? true : false;\n}\nfunction matchParens(l: string[]): string {\n  const s1 = l[0] + l[1];\n  const s2 = l[1] + l[0];\n  return check(s1) || check(s2) ? \"Yes\" : \"No\";\n}",
  "Dart_humaneval-119": "bool check(String s) {\n  int val = 0;\n  for (int i = 0; i < s.length; i++) {\n    if (s[i] == \"(\") {\n      val++;\n    } else {\n      val--;\n    }\n    if (val < 0) {\n      return false;\n    }\n  }\n  return val == 0 ? true : false;\n}\nString matchParens(List<String> l) {\n  String s1 = l[0] + l[1];\n  String s2 = l[1] + l[0];\n  return check(s1) || check(s2) ? \"Yes\" : \"No\";\n}",
  "Rust_humaneval-119": "fn check(s: &str) -> bool {\n    let mut val = 0;\n    for i in s.chars() {\n        if i == '(' {\n            val += 1;\n        } else {\n            val -= 1;\n        }\n        if val < 0 {\n            return false;\n        }\n    }\n    val == 0\n}\nfn match_parens(l: Vec<String>) -> String {\n    let s1 = format!(\"{}{}\", l[0], l[1]);\n    let s2 = format!(\"{}{}\", l[1], l[0]);\n    if check(&s1) || check(&s2) {\n        \"Yes\".to_string()\n    } else {\n        \"No\".to_string()\n    }\n}",
  "Scala_humaneval-119": "def check(s: String): Boolean = {\n  var val1 = 0\n  for (i <- s) {\n    if (i == '(') {\n      val1 += 1\n    } else {\n      val1 -= 1\n    }\n    if (val1 < 0) {\n      return false\n    }\n  }\n  if (val1 == 0) true else false\n}\ndef matchParens(l: List[String]): String = {\n  val s1 = l(0) + l(1)\n  val s2 = l(1) + l(0)\n  if (check(s1) || check(s2)) \"Yes\" else \"No\"\n}",
  "Kotlin_humaneval-119": "fun check(s: String): Boolean {\n  var value = 0\n  for (i in s) {\n    if (i == '(') {\n      value++\n    } else {\n      value--\n    }\n    if (value < 0) {\n      return false\n    }\n  }\n  return value == 0\n}\nfun matchParens(l: List<String>): String {\n  val s1 = l[0] + l[1]\n  val s2 = l[1] + l[0]\n  return if (check(s1) || check(s2)) \"Yes\" else \"No\"\n}",
  "C++_humaneval-120": "vector<int> maximum(vector<int> arr, int k) {\n  if (k == 0) {\n    return {};\n  }\n  sort(arr.begin(), arr.end());\n  vector<int> ans(arr.end() - k, arr.end());\n  return ans;\n}",
  "Java_humaneval-120": "public static List<Integer> maximum(List<Integer> arr, Integer k) {\n  if (k == 0) {\n    return Collections.emptyList();\n  }\n  Collections.sort(arr);\n  List<Integer> ans = arr.subList(arr.size() - k, arr.size());\n  return ans;\n}",
  "Python_humaneval-120": "def maximum(arr: List[int], k: int) -> List[int]:\n    if k == 0:\n        return []\n    arr.sort()\n    ans = arr[-k:]\n    return ans",
  "C#_humaneval-120": "public static List<int> Maximum(List<int> arr, int k) {\n  if (k == 0) {\n    return new List<int>();\n  }\n  arr.Sort();\n  List<int> ans = arr.GetRange(arr.Count - k, k);\n  return ans;\n}",
  "JavaScript_humaneval-120": "function maximum(arr, k) {\n  if (k === 0) {\n    return [];\n  }\n  arr.sort((a, b) => a - b);\n  const ans = arr.slice(-k);\n  return ans;\n}",
  "Go_humaneval-120": "func maximum(arr []int, k int) []int {\n    if k == 0 {\n        return []int{}\n    }\n    sort.Ints(arr)\n    ans := arr[len(arr)-k:]\n    return ans\n}",
  "PHP_humaneval-120": "function maximum(array $arr, int $k): array {\n    if ($k == 0) {\n        return [];\n    }\n    sort($arr);\n    $ans = array_slice($arr, -$k);\n    return $ans;\n}",
  "Ruby_humaneval-120": "def maximum(arr, k)\n  return [] if k == 0\n  arr.sort!\n  ans = arr[-k..-1]\n  return ans\nend",
  "Swift_humaneval-120": "func maximum(_ arr: [Int], _ k: Int) -> [Int] {\n  if k == 0 {\n    return []\n  }\n  var sortedArr = arr.sorted()\n  let ans = Array(sortedArr.suffix(k))\n  return ans\n}",
  "TypeScript_humaneval-120": "function maximum(arr: number[], k: number): number[] {\n  if (k === 0) {\n    return [];\n  }\n  arr.sort((a, b) => a - b);\n  const ans = arr.slice(-k);\n  return ans;\n}",
  "Dart_humaneval-120": "List<int> maximum(List<int> arr, int k) {\n  if (k == 0) {\n    return [];\n  }\n  arr.sort();\n  List<int> ans = arr.sublist(arr.length - k);\n  return ans;\n}",
  "Rust_humaneval-120": "fn maximum(arr: Vec<i32>, k: i32) -> Vec<i32> {\n    if k == 0 {\n        return vec![];\n    }\n    let mut arr = arr;\n    arr.sort();\n    let ans = arr.split_off(arr.len() - k as usize);\n    ans\n}",
  "Scala_humaneval-120": "def maximum(arr: List[Int], k: Int): List[Int] = {\n  if (k == 0) {\n    return List()\n  }\n  val sortedArr = arr.sorted\n  val ans = sortedArr.takeRight(k)\n  return ans\n}",
  "Kotlin_humaneval-120": "fun maximum(arr: List<Int>, k: Int): List<Int> {\n  if (k == 0) {\n    return emptyList()\n  }\n  val sortedArr = arr.sorted()\n  val ans = sortedArr.takeLast(k)\n  return ans\n}",
  "C++_humaneval-121": "int solution(vector<int> l) {\n  int sum = 0;\n  for (int i = 0; i < l.size(); i += 2) {\n    if (l[i] % 2 != 0) {\n      sum += l[i];\n    }\n  }\n  return sum;\n}",
  "Java_humaneval-121": "public static Integer solution(List<Integer> l) {\n  int sum = 0;\n  for (int i = 0; i < l.size(); i += 2) {\n    if (l.get(i) % 2 != 0) {\n      sum += l.get(i);\n    }\n  }\n  return sum;\n}",
  "Python_humaneval-121": "def solution(l: List[int]) -> int:\n    sum = 0\n    for i in range(0, len(l), 2):\n        if l[i] % 2 != 0:\n            sum += l[i]\n    return sum",
  "C#_humaneval-121": "public static int Solution(List<int> l) {\n  int sum = 0;\n  for (int i = 0; i < l.Count; i += 2) {\n    if (l[i] % 2 != 0) {\n      sum += l[i];\n    }\n  }\n  return sum;\n}",
  "JavaScript_humaneval-121": "function solution(l) {\n  let sum = 0;\n  for (let i = 0; i < l.length; i += 2) {\n    if (l[i] % 2 !== 0) {\n      sum += l[i];\n    }\n  }\n  return sum;\n}",
  "Go_humaneval-121": "func solution(l []int) int {\n    sum := 0\n    for i := 0; i < len(l); i += 2 {\n        if l[i]%2 != 0 {\n            sum += l[i]\n        }\n    }\n    return sum\n}",
  "PHP_humaneval-121": "function solution(array $l): int {\n    $sum = 0;\n    for ($i = 0; $i < count($l); $i += 2) {\n        if ($l[$i] % 2 != 0) {\n            $sum += $l[$i];\n        }\n    }\n    return $sum;\n}",
  "Ruby_humaneval-121": "def solution(l)\n  sum = 0\n  for i in (0...l.length).step(2)\n    sum += l[i] if l[i] % 2 != 0\n  end\n  return sum\nend",
  "Swift_humaneval-121": "func solution(_ l: [Int]) -> Int {\n  var sum = 0\n  for i in stride(from: 0, to: l.count, by: 2) {\n    if l[i] % 2 != 0 {\n      sum += l[i]\n    }\n  }\n  return sum\n}",
  "TypeScript_humaneval-121": "function solution(l: number[]): number {\n  let sum = 0;\n  for (let i = 0; i < l.length; i += 2) {\n    if (l[i] % 2 !== 0) {\n      sum += l[i];\n    }\n  }\n  return sum;\n}",
  "Dart_humaneval-121": "int solution(List<int> l) {\n  int sum = 0;\n  for (int i = 0; i < l.length; i += 2) {\n    if (l[i] % 2 != 0) {\n      sum += l[i];\n    }\n  }\n  return sum;\n}",
  "Rust_humaneval-121": "fn solution(l: Vec<i32>) -> i32 {\n    let mut sum = 0;\n    for i in (0..l.len()).step_by(2) {\n        if l[i] % 2 != 0 {\n            sum += l[i];\n        }\n    }\n    sum\n}",
  "Scala_humaneval-121": "def solution(l: List[Int]): Int = {\n  var sum = 0\n  for (i <- Range(0, l.length, 2)) {\n    if (l(i) % 2 != 0) {\n      sum += l(i)\n    }\n  }\n  sum\n}",
  "Kotlin_humaneval-121": "fun solution(l: List<Int>): Int {\n  var sum = 0\n  for (i in 0 until l.size step 2) {\n    if (l[i] % 2 != 0) {\n      sum += l[i]\n    }\n  }\n  return sum\n}",
  "C++_humaneval-122": "int addElements(vector<int> arr, int k) {\n  int total = 0;\n  for (int i = 0; i < k; i++) {\n    if (to_string(arr[i]).length() <= 2) {\n      total += arr[i];\n    }\n  }\n  return total;\n}",
  "Java_humaneval-122": "public static Integer addElements(List<Integer> arr, Integer k) {\n  Integer total = 0;\n  for (int i = 0; i < k; i++) {\n    if (arr.get(i).toString().length() <= 2) {\n      total += arr.get(i);\n    }\n  }\n  return total;\n}",
  "Python_humaneval-122": "def add_elements(arr: List[int], k: int) -> int:\n    total = 0\n    for i in range(k):\n        if len(str(arr[i])) <= 2:\n            total += arr[i]\n    return total",
  "C#_humaneval-122": "public static int AddElements(List<int> arr, int k) {\n  int total = 0;\n  for (int i = 0; i < k; i++) {\n    if (arr[i].ToString().Length <= 2) {\n      total += arr[i];\n    }\n  }\n  return total;\n}",
  "JavaScript_humaneval-122": "function addElements(arr, k) {\n  let total = 0;\n  for (let i = 0; i < k; i++) {\n    if (arr[i].toString().length <= 2) {\n      total += arr[i];\n    }\n  }\n  return total;\n}",
  "Go_humaneval-122": "func addElements(arr []int, k int) int {\n    total := 0\n    for i := 0; i < k; i++ {\n        if len(strconv.Itoa(arr[i])) <= 2 {\n            total += arr[i]\n        }\n    }\n    return total\n}",
  "PHP_humaneval-122": "function addElements(array $arr, int $k): int {\n    $total = 0;\n    for ($i = 0; $i < $k; $i++) {\n        if (strlen(strval($arr[$i])) <= 2) {\n            $total += $arr[$i];\n        }\n    }\n    return $total;\n}",
  "Ruby_humaneval-122": "def add_elements(arr, k)\n  total = 0\n  for i in 0...k\n    total += arr[i] if arr[i].to_s.length <= 2\n  end\n  return total\nend",
  "Swift_humaneval-122": "func addElements(_ arr: [Int], _ k: Int) -> Int {\n  var total = 0\n  for i in 0..<k {\n    if String(arr[i]).count <= 2 {\n      total += arr[i]\n    }\n  }\n  return total\n}",
  "TypeScript_humaneval-122": "function addElements(arr: number[], k: number): number {\n  let total = 0;\n  for (let i = 0; i < k; i++) {\n    if (arr[i].toString().length <= 2) {\n      total += arr[i];\n    }\n  }\n  return total;\n}",
  "Dart_humaneval-122": "int addElements(List<int> arr, int k) {\n  int total = 0;\n  for (int i = 0; i < k; i++) {\n    if (arr[i].toString().length <= 2) {\n      total += arr[i];\n    }\n  }\n  return total;\n}",
  "Rust_humaneval-122": "fn add_elements(arr: Vec<i32>, k: i32) -> i32 {\n    let mut total = 0;\n    for i in 0..k as usize {\n        if arr[i].to_string().len() <= 2 {\n            total += arr[i];\n        }\n    }\n    total\n}",
  "Scala_humaneval-122": "def addElements(arr: List[Int], k: Int): Int = {\n  var total = 0\n  for (i <- 0 until k) {\n    if (arr(i).toString.length <= 2) {\n      total += arr(i)\n    }\n  }\n  total\n}",
  "Kotlin_humaneval-122": "fun addElements(arr: List<Int>, k: Int): Int {\n  var total = 0\n  for (i in 0 until k) {\n    if (arr[i].toString().length <= 2) {\n      total += arr[i]\n    }\n  }\n  return total\n}",
  "C++_humaneval-123": "vector<int> getOddCollatz(int n) {\n  vector<int> collatz_seq{n};\n  while (n != 1) {\n    if (n % 2 == 0) {\n      n = n / 2;\n    } else {\n      n = 3 * n + 1;\n    }\n    collatz_seq.push_back(n);\n  }\n  vector<int> odd_numbers;\n  for (int num : collatz_seq) {\n    if (num % 2 == 1) {\n      odd_numbers.push_back(num);\n    }\n  }\n  sort(odd_numbers.begin(), odd_numbers.end());\n  return odd_numbers;\n}",
  "Java_humaneval-123": "public static List<Integer> getOddCollatz(Integer n) {\n  List<Integer> collatz_seq = new ArrayList<>();\n  collatz_seq.add(n);\n  while (n != 1) {\n    if (n % 2 == 0) {\n      n = n / 2;\n    } else {\n      n = 3 * n + 1;\n    }\n    collatz_seq.add(n);\n  }\n  List<Integer> odd_numbers = new ArrayList<>();\n  for (Integer num : collatz_seq) {\n    if (num % 2 == 1) {\n      odd_numbers.add(num);\n    }\n  }\n  odd_numbers.sort(null);\n  return odd_numbers;\n}",
  "Python_humaneval-123": "def get_odd_collatz(n: int) -> List[int]:\n    collatz_seq = [n]\n    while n != 1:\n        if n % 2 == 0:\n            n = n // 2\n        else:\n            n = 3 * n + 1\n        collatz_seq.append(n)\n    odd_numbers = [num for num in collatz_seq if num % 2 == 1]\n    return sorted(odd_numbers)",
  "C#_humaneval-123": "public static List<int> GetOddCollatz(int n) {\n  List<int> collatz_seq = new List<int> { n };\n  while (n != 1) {\n    if (n % 2 == 0) {\n      n = n / 2;\n    } else {\n      n = 3 * n + 1;\n    }\n    collatz_seq.Add(n);\n  }\n  List<int> odd_numbers = collatz_seq.Where(num => num % 2 == 1).ToList();\n  odd_numbers.Sort();\n  return odd_numbers;\n}",
  "JavaScript_humaneval-123": "function getOddCollatz(n) {\n  let collatz_seq = [n];\n  while (n !== 1) {\n    if (n % 2 === 0) {\n      n = n / 2;\n    } else {\n      n = 3 * n + 1;\n    }\n    collatz_seq.push(n);\n  }\n  let odd_numbers = collatz_seq.filter((num) => num % 2 === 1);\n  return odd_numbers.sort((a, b) => a - b);\n}",
  "Go_humaneval-123": "func getOddCollatz(n int) []int {\n    collatzSeq := []int{n}\n    for n != 1 {\n        if n%2 == 0 {\n            n = n / 2\n        } else {\n            n = 3*n + 1\n        }\n        collatzSeq = append(collatzSeq, n)\n    }\n    var oddNumbers []int\n    for _, num := range collatzSeq {\n        if num%2 == 1 {\n            oddNumbers = append(oddNumbers, num)\n        }\n    }\n    sort.Ints(oddNumbers)\n    return oddNumbers\n}",
  "PHP_humaneval-123": "function getOddCollatz(int $n): array {\n    $collatz_seq = [$n];\n    while ($n != 1) {\n        if ($n % 2 == 0) {\n            $n = $n / 2;\n        } else {\n            $n = 3 * $n + 1;\n        }\n        $collatz_seq[] = $n;\n    }\n    $odd_numbers = array_filter($collatz_seq, function($num) {\n        return $num % 2 == 1;\n    });\n    sort($odd_numbers);\n    return $odd_numbers;\n}",
  "Ruby_humaneval-123": "def get_odd_collatz(n)\n  collatz_seq = [n]\n  while n != 1\n    if n % 2 == 0\n      n = n / 2\n    else\n      n = 3 * n + 1\n    end\n    collatz_seq << n\n  end\n  odd_numbers = collatz_seq.select { |num| num.odd? }\n  odd_numbers.sort\nend",
  "Swift_humaneval-123": "func getOddCollatz(_ n: Int) -> [Int] {\n  var collatzSeq = [n]\n  var num = n\n  while num != 1 {\n    if num % 2 == 0 {\n      num = num / 2\n    } else {\n      num = 3 * num + 1\n    }\n    collatzSeq.append(num)\n  }\n  let oddNumbers = collatzSeq.filter { $0 % 2 == 1 }\n  return oddNumbers.sorted()\n}",
  "TypeScript_humaneval-123": "function getOddCollatz(n: number): number[] {\n  const collatz_seq: number[] = [n];\n  while (n !== 1) {\n    if (n % 2 === 0) {\n      n = n / 2;\n    } else {\n      n = 3 * n + 1;\n    }\n    collatz_seq.push(n);\n  }\n  const odd_numbers: number[] = collatz_seq.filter((num) => num % 2 === 1);\n  return odd_numbers.sort((a, b) => a - b);\n}",
  "Dart_humaneval-123": "List<int> getOddCollatz(int n) {\n  List<int> collatzSeq = [n];\n  while (n != 1) {\n    if (n % 2 == 0) {\n      n = n ~/ 2;\n    } else {\n      n = 3 * n + 1;\n    }\n    collatzSeq.add(n);\n  }\n  List<int> oddNumbers = [\n    for (int num in collatzSeq)\n      if (num % 2 == 1) num\n  ];\n  return oddNumbers..sort();\n}",
  "Rust_humaneval-123": "fn get_odd_collatz(n: i32) -> Vec<i32> {\n    let mut collatz_seq = vec![n];\n    let mut num = n;\n    while num != 1 {\n        if num % 2 == 0 {\n            num = num / 2;\n        } else {\n            num = 3 * num + 1;\n        }\n        collatz_seq.push(num);\n    }\n    let odd_numbers: Vec<i32> = collatz_seq.into_iter().filter(|&x| x % 2 == 1).collect();\n    let mut sorted_odd_numbers = odd_numbers.clone();\n    sorted_odd_numbers.sort();\n    sorted_odd_numbers\n}",
  "Scala_humaneval-123": "def getOddCollatz(n: Int): List[Int] = {\n  var collatzSeq = List(n)\n  var num = n\n  while (num != 1) {\n    if (num % 2 == 0) {\n      num = num / 2\n    } else {\n      num = 3 * num + 1\n    }\n    collatzSeq = collatzSeq :+ num\n  }\n  val oddNumbers = collatzSeq.filter(_ % 2 != 0)\n  oddNumbers.sorted\n}",
  "Kotlin_humaneval-123": "fun getOddCollatz(n: Int): List<Int> {\n  val collatzSeq = mutableListOf(n)\n  var num = n\n  while (num != 1) {\n    num = if (num % 2 == 0) {\n      num / 2\n    } else {\n      3 * num + 1\n    }\n    collatzSeq.add(num)\n  }\n  val oddNumbers = collatzSeq.filter { it % 2 == 1 }\n  return oddNumbers.sorted()\n}",
  "C++_humaneval-124": "bool validDate(string date) {\n  if (count(date.begin(), date.end(), '-') != 2) {\n    return false;\n  }\n  int month, day, year;\n  sscanf(date.c_str(), \"%d-%d-%d\", &month, &day, &year);\n  if (month < 1 || month > 12) {\n    return false;\n  }\n  if ((month == 1 || month == 3 || month == 5 || month == 7 || month == 8 ||\n       month == 10 || month == 12) &&\n      (day < 1 || day > 31)) {\n    return false;\n  }\n  if ((month == 4 || month == 6 || month == 9 || month == 11) &&\n      (day < 1 || day > 30)) {\n    return false;\n  }\n  if (month == 2 && (day < 1 || day > 29)) {\n    return false;\n  }\n  return true;\n}",
  "Java_humaneval-124": "public static Boolean validDate(String date) {\n  if (date.split(\"-\").length != 3) {\n    return false;\n  }\n  int month = Integer.parseInt(date.split(\"-\")[0]);\n  int day = Integer.parseInt(date.split(\"-\")[1]);\n  int year = Integer.parseInt(date.split(\"-\")[2]);\n  if (month < 1 || month > 12) {\n    return false;\n  }\n  if ((month == 1 || month == 3 || month == 5 || month == 7 || month == 8 || month == 10\n          || month == 12)\n      && (day < 1 || day > 31)) {\n    return false;\n  }\n  if ((month == 4 || month == 6 || month == 9 || month == 11) && (day < 1 || day > 30)) {\n    return false;\n  }\n  if (month == 2 && (day < 1 || day > 29)) {\n    return false;\n  }\n  return true;\n}",
  "Python_humaneval-124": "def valid_date(date: str) -> bool:\n    if date.count(\"-\") != 2:\n        return False\n    month, day, year = date.split(\"-\")\n    month, day, year = int(month), int(day), int(year)\n    if month < 1 or month > 12:\n        return False\n    if month in [1, 3, 5, 7, 8, 10, 12] and day < 1 or day > 31:\n        return False\n    if month in [4, 6, 9, 11] and day < 1 or day > 30:\n        return False\n    if month == 2 and day < 1 or day > 29:\n        return False\n    return True",
  "C#_humaneval-124": "public static bool ValidDate(string date) {\n  if (date.Count(c => c == '-') != 2) {\n    return false;\n  }\n  string[] parts = date.Split('-');\n  int month = int.Parse(parts[0]);\n  int day = int.Parse(parts[1]);\n  int year = int.Parse(parts[2]);\n  if (month < 1 || month > 12) {\n    return false;\n  }\n  if ((new int[] { 1, 3, 5, 7, 8, 10, 12 }).Contains(month) && (day < 1 || day > 31)) {\n    return false;\n  }\n  if ((new int[] { 4, 6, 9, 11 }).Contains(month) && (day < 1 || day > 30)) {\n    return false;\n  }\n  if (month == 2 && (day < 1 || day > 29)) {\n    return false;\n  }\n  return true;\n}",
  "JavaScript_humaneval-124": "function validDate(date) {\n  if (date.split(\"-\").length !== 3) {\n    return false;\n  }\n  const [month, day, year] = date.split(\"-\").map(Number);\n  if (month < 1 || month > 12) {\n    return false;\n  }\n  if (\n    ([1, 3, 5, 7, 8, 10, 12].includes(month) && (day < 1 || day > 31)) ||\n    ([4, 6, 9, 11].includes(month) && (day < 1 || day > 30)) ||\n    (month === 2 && (day < 1 || day > 29))\n  ) {\n    return false;\n  }\n  return true;\n}",
  "Go_humaneval-124": "func validDate(date string) bool {\n    if strings.Count(date, \"-\") != 2 {\n        return false\n    }\n    parts := strings.Split(date, \"-\")\n    month, err := strconv.Atoi(parts[0])\n    if err != nil || month < 1 || month > 12 {\n        return false\n    }\n    day, err := strconv.Atoi(parts[1])\n    if err != nil {\n        return false\n    }\n    year, err := strconv.Atoi(parts[2])\n    if err != nil {\n        return false\n    }\n    if month == 2 {\n        if year%4 != 0 && day > 28 || day > 29 {\n            return false\n        }\n    } else if month == 4 || month == 6 || month == 9 || month == 11 {\n        if day < 1 || day > 30 {\n            return false\n        }\n    } else {\n        if day < 1 || day > 31 {\n            return false\n        }\n    }\n    return true\n}",
  "PHP_humaneval-124": "function validDate(string $date): bool {\n    if (substr_count($date, \"-\") != 2) {\n        return false;\n    }\n    list($month, $day, $year) = explode(\"-\", $date);\n    $month = (int) $month;\n    $day = (int) $day;\n    $year = (int) $year;\n    if ($month < 1 || $month > 12) {\n        return false;\n    }\n    if (in_array($month, [1, 3, 5, 7, 8, 10, 12]) && ($day < 1 || $day > 31)) {\n        return false;\n    }\n    if (in_array($month, [4, 6, 9, 11]) && ($day < 1 || $day > 30)) {\n        return false;\n    }\n    if ($month == 2 && ($day < 1 || $day > 29)) {\n        return false;\n    }\n    return true;\n}",
  "Ruby_humaneval-124": "def valid_date(date)\n  return false if date.count(\"-\") != 2\n  month, day, year = date.split(\"-\").map(&:to_i)\n  return false if month < 1 || month > 12\n  if [1, 3, 5, 7, 8, 10, 12].include?(month) && (day < 1 || day > 31)\n    return false\n  end\n  return false if [4, 6, 9, 11].include?(month) && (day < 1 || day > 30)\n  return false if month == 2 && (day < 1 || day > 29)\n  true\nend",
  "Swift_humaneval-124": "func validDate(_ date: String) -> Bool {\n  if date.components(separatedBy: \"-\").count != 3 {\n    return false\n  }\n  let components = date.components(separatedBy: \"-\")\n  guard let month = Int(components[0]), let day = Int(components[1]), let year = Int(components[2])\n  else {\n    return false\n  }\n  if month < 1 || month > 12 {\n    return false\n  }\n  if [1, 3, 5, 7, 8, 10, 12].contains(month) && (day < 1 || day > 31) {\n    return false\n  }\n  if [4, 6, 9, 11].contains(month) && (day < 1 || day > 30) {\n    return false\n  }\n  if month == 2 && (day < 1 || day > 29) {\n    return false\n  }\n  return true\n}",
  "TypeScript_humaneval-124": "function validDate(date: string): boolean {\n  if (date.split(\"-\").length !== 3) {\n    return false;\n  }\n  const [month, day, year] = date.split(\"-\").map(Number);\n  if (month < 1 || month > 12) {\n    return false;\n  }\n  if (\n    ([1, 3, 5, 7, 8, 10, 12].includes(month) && (day < 1 || day > 31)) ||\n    ([4, 6, 9, 11].includes(month) && (day < 1 || day > 30)) ||\n    (month === 2 && (day < 1 || day > 29))\n  ) {\n    return false;\n  }\n  return true;\n}",
  "Dart_humaneval-124": "bool validDate(String date) {\n  if (date.split(\"-\").length != 3) {\n    return false;\n  }\n  List<String> dateParts = date.split(\"-\");\n  int month = int.parse(dateParts[0]);\n  int day = int.parse(dateParts[1]);\n  int year = int.parse(dateParts[2]);\n  if (month < 1 || month > 12) {\n    return false;\n  }\n  if (([1, 3, 5, 7, 8, 10, 12].contains(month) && (day < 1 || day > 31)) ||\n      ([4, 6, 9, 11].contains(month) && (day < 1 || day > 30)) ||\n      (month == 2 && (day < 1 || day > 29))) {\n    return false;\n  }\n  return true;\n}",
  "Rust_humaneval-124": "fn valid_date(date: String) -> bool {\n    if date.matches(\"-\").count() != 2 {\n        return false;\n    }\n    let mut parts = date.split(\"-\").map(|part| part.parse::<i32>().unwrap());\n    let month = parts.next().unwrap();\n    let day = parts.next().unwrap();\n    let year = parts.next().unwrap();\n    if month < 1 || month > 12 {\n        return false;\n    }\n    if [1, 3, 5, 7, 8, 10, 12].contains(&month) && (day < 1 || day > 31) {\n        return false;\n    }\n    if [4, 6, 9, 11].contains(&month) && (day < 1 || day > 30) {\n        return false;\n    }\n    if month == 2 && (day < 1 || day > 29) {\n        return false;\n    }\n    true\n}",
  "Scala_humaneval-124": "def validDate(date: String): Boolean = {\n  if (date.count(_ == '-') != 2)\n    return false\n  val Array(month, day, year) = date.split(\"-\").map(_.toInt)\n  if (month < 1 || month > 12)\n    return false\n  if (List(1, 3, 5, 7, 8, 10, 12).contains(month) && (day < 1 || day > 31))\n    return false\n  if (List(4, 6, 9, 11).contains(month) && (day < 1 || day > 30))\n    return false\n  if (month == 2 && (day < 1 || day > 29))\n    return false\n  true\n}",
  "Kotlin_humaneval-124": "fun validDate(date: String): Boolean {\n  if (date.count { it == '-' } != 2) {\n    return false\n  }\n  val (month, day, year) = date.split(\"-\").map { it.toInt() }\n  if (month < 1 || month > 12) {\n    return false\n  }\n  if (month in listOf(1, 3, 5, 7, 8, 10, 12) && (day < 1 || day > 31)) {\n    return false\n  }\n  if (month in listOf(4, 6, 9, 11) && (day < 1 || day > 30)) {\n    return false\n  }\n  if (month == 2 && (day < 1 || day > 29)) {\n    return false\n  }\n  return true\n}",
  "C++_humaneval-125": "vector<string> splitWords(string txt) {\n  vector<string> words;\n  if (txt.find(\" \") != string::npos) {\n    stringstream ss(txt);\n    string word;\n    while (ss >> word) {\n      words.push_back(word);\n    }\n  } else if (txt.find(\",\") != string::npos) {\n    stringstream ss(txt);\n    string word;\n    while (getline(ss, word, ',')) {\n      words.push_back(word);\n    }\n  } else {\n    int count = 0;\n    for (char c : txt) {\n      if (islower(c) && c % 2 == 1) {\n        count++;\n      }\n    }\n    words.push_back(to_string(count));\n  }\n  return words;\n}",
  "Java_humaneval-125": "public static List<String> splitWords(String txt) {\n  if (txt.contains(\" \")) {\n    return List.of(txt.split(\" \"));\n  } else if (txt.contains(\",\")) {\n    return List.of(txt.split(\",\"));\n  } else {\n    int count = 0;\n    for (char c : txt.toCharArray()) {\n      if (Character.isLowerCase(c) && c % 2 == 1) {\n        count++;\n      }\n    }\n    return List.of(String.valueOf(count));\n  }\n}",
  "Python_humaneval-125": "def split_words(txt: str) -> List[str]:\n    if \" \" in txt:\n        return txt.split()\n    elif \",\" in txt:\n        return txt.split(\",\")\n    else:\n        count = 0\n        for char in txt:\n            if char.islower() and ord(char) % 2 == 1:\n                count += 1\n        return [str(count)]",
  "C#_humaneval-125": "public static List<string> SplitWords(string txt) {\n  if (txt.Contains(\" \")) {\n    return txt.Split().ToList();\n  } else if (txt.Contains(\",\")) {\n    return txt.Split(',').ToList();\n  } else {\n    int count = 0;\n    foreach (char c in txt) {\n      if (Char.IsLower(c) && c % 2 == 1) {\n        count++;\n      }\n    }\n    return new List<string> { count.ToString() };\n  }\n}",
  "JavaScript_humaneval-125": "function splitWords(txt) {\n  if (txt.includes(\" \")) {\n    return txt.split(\" \");\n  } else if (txt.includes(\",\")) {\n    return txt.split(\",\");\n  } else {\n    let count = 0;\n    for (let i = 0; i < txt.length; i++) {\n      let char = txt.charAt(i);\n      if (char === char.toLowerCase() && char.charCodeAt(0) % 2 === 1) {\n        count++;\n      }\n    }\n    return [count.toString()];\n  }\n}",
  "Go_humaneval-125": "func splitWords(txt string) []string {\n    if strings.Contains(txt, \" \") {\n        return strings.Split(txt, \" \")\n    } else if strings.Contains(txt, \",\") {\n        return strings.Split(txt, \",\")\n    } else {\n        count := 0\n        for _, char := range txt {\n            if unicode.IsLower(char) && int(char)%2 == 1 {\n                count++\n            }\n        }\n        return []string{strconv.Itoa(count)}\n    }\n}",
  "PHP_humaneval-125": "function splitWords(string $txt): array {\n    if (strpos($txt, \" \") !== false) {\n        return explode(\" \", $txt);\n    } elseif (strpos($txt, \",\") !== false) {\n        return explode(\",\", $txt);\n    } else {\n        $count = 0;\n        for ($i = 0; $i < strlen($txt); $i++) {\n            $char = $txt[$i];\n            if (ctype_lower($char) && ord($char) % 2 == 1) {\n                $count++;\n            }\n        }\n        return [(string) $count];\n    }\n}",
  "Ruby_humaneval-125": "def split_words(txt)\n  if txt.include?(\" \")\n    txt.split\n  elsif txt.include?(\",\")\n    txt.split(\",\")\n  else\n    count = 0\n    txt.each_char { |char| count += 1 if char.match?(/[a-z]/) && char.ord.odd? }\n    [count.to_s]\n  end\nend",
  "Swift_humaneval-125": "func splitWords(_ txt: String) -> [String] {\n  if txt.contains(\" \") {\n    return txt.components(separatedBy: \" \")\n  } else if txt.contains(\",\") {\n    return txt.components(separatedBy: \",\")\n  } else {\n    var count = 0\n    for char in txt {\n      if char.isLowercase && char.asciiValue! % 2 == 1 {\n        count += 1\n      }\n    }\n    return [String(count)]\n  }\n}",
  "TypeScript_humaneval-125": "function splitWords(txt: string): string[] {\n  if (txt.includes(\" \")) {\n    return txt.split(\" \");\n  } else if (txt.includes(\",\")) {\n    return txt.split(\",\");\n  } else {\n    let count = 0;\n    for (let char of txt) {\n      if (char.toLowerCase() === char && char.charCodeAt(0) % 2 === 1) {\n        count++;\n      }\n    }\n    return [count.toString()];\n  }\n}",
  "Dart_humaneval-125": "List<String> splitWords(String txt) {\n  if (txt.contains(\" \")) {\n    return txt.split(\" \");\n  } else if (txt.contains(\",\")) {\n    return txt.split(\",\");\n  } else {\n    int count = 0;\n    for (int i = 0; i < txt.length; i++) {\n      if (txt[i].toLowerCase() == txt[i] && txt.codeUnitAt(i) % 2 == 1) {\n        count++;\n      }\n    }\n    return [count.toString()];\n  }\n}",
  "Rust_humaneval-125": "fn split_words(txt: String) -> Vec<String> {\n    if txt.contains(' ') {\n        txt.split(' ').map(|s| s.to_string()).collect()\n    } else if txt.contains(',') {\n        txt.split(',').map(|s| s.to_string()).collect()\n    } else {\n        let mut count = 0;\n        for char in txt.chars() {\n            if char.is_ascii_lowercase() && char as u32 % 2 == 1 {\n                count += 1;\n            }\n        }\n        vec![count.to_string()]\n    }\n}",
  "Scala_humaneval-125": "def splitWords(txt: String): List[String] = {\n  if (txt.contains(\" \")) {\n    txt.split(\" \").toList\n  } else if (txt.contains(\",\")) {\n    txt.split(\",\").toList\n  } else {\n    var count = 0\n    for (char <- txt) {\n      if (char.isLower && char.toInt % 2 == 1) {\n        count += 1\n      }\n    }\n    List(count.toString)\n  }\n}",
  "Kotlin_humaneval-125": "fun splitWords(txt: String): List<String> {\n  if (\" \" in txt) {\n    return txt.split(\" \")\n  } else if (\",\" in txt) {\n    return txt.split(\",\")\n  } else {\n    var count = 0\n    for (char in txt) {\n      if (char.isLowerCase() && char.toInt() % 2 == 1) {\n        count++\n      }\n    }\n    return listOf(count.toString())\n  }\n}",
  "C++_humaneval-126": "bool isSorted(vector<int> l) {\n  for (int i = 0; i < (int)l.size() - 1; i++) {\n    if (l[i] > l[i + 1]) {\n      return false;\n    }\n  }\n  for (int i = 0; i < l.size(); i++) {\n    if (count(l.begin(), l.end(), l[i]) > 2) {\n      return false;\n    }\n  }\n  return true;\n}",
  "Java_humaneval-126": "public static Boolean isSorted(List<Integer> l) {\n  for (int i = 0; i < l.size() - 1; i++) {\n    if (l.get(i) > l.get(i + 1)) {\n      return false;\n    }\n  }\n  for (int i : l) {\n    if (Collections.frequency(l, i) > 2) {\n      return false;\n    }\n  }\n  return true;\n}",
  "Python_humaneval-126": "def is_sorted(l: List[int]) -> bool:\n    for i in range(len(l) - 1):\n        if l[i] > l[i + 1]:\n            return False\n    for i in l:\n        if l.count(i) > 2:\n            return False\n    return True",
  "C#_humaneval-126": "public static bool IsSorted(List<int> l) {\n  for (int i = 0; i < l.Count - 1; i++) {\n    if (l[i] > l[i + 1]) {\n      return false;\n    }\n  }\n  foreach (int i in l) {\n    if (l.Count(x => x == i) > 2) {\n      return false;\n    }\n  }\n  return true;\n}",
  "JavaScript_humaneval-126": "function isSorted(l) {\n  for (let i = 0; i < l.length - 1; i++) {\n    if (l[i] > l[i + 1]) {\n      return false;\n    }\n  }\n  for (let i of l) {\n    if (l.filter((n) => n === i).length > 2) {\n      return false;\n    }\n  }\n  return true;\n}",
  "Go_humaneval-126": "func isSorted(l []int) bool {\n    for i := 0; i < len(l)-1; i++ {\n        if l[i] > l[i+1] {\n            return false\n        }\n    }\n    for _, i := range l {\n        if count(l, i) > 2 {\n            return false\n        }\n    }\n    return true\n}\nfunc count(l []int, n int) int {\n    count := 0\n    for _, i := range l {\n        if i == n {\n            count++\n        }\n    }\n    return count\n}",
  "PHP_humaneval-126": "function isSorted(array $l): bool {\n    for ($i = 0; $i < count($l) - 1; $i++) {\n        if ($l[$i] > $l[$i + 1]) {\n            return false;\n        }\n    }\n    foreach ($l as $i) {\n        if (array_count_values($l)[$i] > 2) {\n            return false;\n        }\n    }\n    return true;\n}",
  "Ruby_humaneval-126": "def is_sorted(l)\n  (0...l.length - 1).each { |i| return false if l[i] > l[i + 1] }\n  l.each { |i| return false if l.count(i) > 2 }\n  true\nend",
  "Swift_humaneval-126": "func isSorted(_ l: [Int]) -> Bool {\n  if l.isEmpty {\n    return true\n  }\n  for i in 0..<l.count - 1 {\n    if l[i] > l[i + 1] {\n      return false\n    }\n  }\n  for i in l {\n    if l.filter({ $0 == i }).count > 2 {\n      return false\n    }\n  }\n  return true\n}",
  "TypeScript_humaneval-126": "function isSorted(l: number[]): boolean {\n  for (let i = 0; i < l.length - 1; i++) {\n    if (l[i] > l[i + 1]) {\n      return false;\n    }\n  }\n  for (let i = 0; i < l.length; i++) {\n    if (l.filter((x) => x === l[i]).length > 2) {\n      return false;\n    }\n  }\n  return true;\n}",
  "Dart_humaneval-126": "bool isSorted(List<int> l) {\n  for (int i = 0; i < l.length - 1; i++) {\n    if (l[i] > l[i + 1]) {\n      return false;\n    }\n  }\n  for (int i in l) {\n    if (l.where((j) => j == i).length > 2) {\n      return false;\n    }\n  }\n  return true;\n}",
  "Rust_humaneval-126": "fn is_sorted(l: Vec<i32>) -> bool {\n    if l.is_empty() {\n        return true;\n    }\n    for i in 0..l.len() - 1 {\n        if l[i] > l[i + 1] {\n            return false;\n        }\n    }\n    for i in &l {\n        if l.iter().filter(|&n| *n == *i).count() > 2 {\n            return false;\n        }\n    }\n    true\n}",
  "Scala_humaneval-126": "def isSorted(l: List[Int]): Boolean = {\n  for (i <- 0 until l.length - 1) {\n    if (l(i) > l(i + 1)) {\n      return false\n    }\n  }\n  for (i <- l) {\n    if (l.count(_ == i) > 2) {\n      return false\n    }\n  }\n  true\n}",
  "Kotlin_humaneval-126": "fun isSorted(l: List<Int>): Boolean {\n  for (i in 0 until l.size - 1) {\n    if (l[i] > l[i + 1]) {\n      return false\n    }\n  }\n  for (i in l) {\n    if (l.count { it == i } > 2) {\n      return false\n    }\n  }\n  return true\n}",
  "C++_humaneval-127": "string intersection(vector<int> interval1, vector<int> interval2) {\n  int start1 = interval1[0], end1 = interval1[1];\n  int start2 = interval2[0], end2 = interval2[1];\n  int intersection_start = max(start1, start2);\n  int intersection_end = min(end1, end2);\n  if (intersection_start > intersection_end) {\n    return \"NO\";\n  }\n  int intersection_length = intersection_end - intersection_start;\n  if (intersection_length <= 1) {\n    return \"NO\";\n  }\n  for (int i = 2; i <= sqrt(intersection_length); i++) {\n    if (intersection_length % i == 0) {\n      return \"NO\";\n    }\n  }\n  return \"YES\";\n}",
  "Java_humaneval-127": "public static String intersection(List<Integer> interval1, List<Integer> interval2) {\n  int start1 = interval1.get(0);\n  int end1 = interval1.get(1);\n  int start2 = interval2.get(0);\n  int end2 = interval2.get(1);\n  int intersection_start = Math.max(start1, start2);\n  int intersection_end = Math.min(end1, end2);\n  if (intersection_start > intersection_end) {\n    return \"NO\";\n  }\n  int intersection_length = intersection_end - intersection_start;\n  if (intersection_length <= 1) {\n    return \"NO\";\n  }\n  for (int i = 2; i <= Math.sqrt(intersection_length); i++) {\n    if (intersection_length % i == 0) {\n      return \"NO\";\n    }\n  }\n  return \"YES\";\n}",
  "Python_humaneval-127": "def intersection(interval1: List[int], interval2: List[int]) -> str:\n    start1, end1 = interval1\n    start2, end2 = interval2\n    intersection_start = max(start1, start2)\n    intersection_end = min(end1, end2)\n    if intersection_start > intersection_end:\n        return \"NO\"\n    intersection_length = intersection_end - intersection_start\n    if intersection_length <= 1:\n        return \"NO\"\n    for i in range(2, int(intersection_length**0.5) + 1):\n        if intersection_length % i == 0:\n            return \"NO\"\n    return \"YES\"",
  "C#_humaneval-127": "public static string Intersection(List<int> interval1, List<int> interval2) {\n  int start1 = interval1[0];\n  int end1 = interval1[1];\n  int start2 = interval2[0];\n  int end2 = interval2[1];\n  int intersection_start = Math.Max(start1, start2);\n  int intersection_end = Math.Min(end1, end2);\n  if (intersection_start > intersection_end) {\n    return \"NO\";\n  }\n  int intersection_length = intersection_end - intersection_start;\n  if (intersection_length <= 1) {\n    return \"NO\";\n  }\n  for (int i = 2; i <= Math.Sqrt(intersection_length); i++) {\n    if (intersection_length % i == 0) {\n      return \"NO\";\n    }\n  }\n  return \"YES\";\n}",
  "JavaScript_humaneval-127": "function intersection(interval1, interval2) {\n  const [start1, end1] = interval1;\n  const [start2, end2] = interval2;\n  const intersectionStart = Math.max(start1, start2);\n  const intersectionEnd = Math.min(end1, end2);\n  if (intersectionStart > intersectionEnd) {\n    return \"NO\";\n  }\n  const intersectionLength = intersectionEnd - intersectionStart;\n  if (intersectionLength <= 1) {\n    return \"NO\";\n  }\n  for (let i = 2; i <= Math.floor(Math.sqrt(intersectionLength)); i++) {\n    if (intersectionLength % i === 0) {\n      return \"NO\";\n    }\n  }\n  return \"YES\";\n}",
  "Go_humaneval-127": "func intersection(interval1 []int, interval2 []int) string {\n    start1, end1 := interval1[0], interval1[1]\n    start2, end2 := interval2[0], interval2[1]\n    intersectionStart := int(math.Max(float64(start1), float64(start2)))\n    intersectionEnd := int(math.Min(float64(end1), float64(end2)))\n    if intersectionStart > intersectionEnd {\n        return \"NO\"\n    }\n    intersectionLength := intersectionEnd - intersectionStart\n    if intersectionLength <= 1 {\n        return \"NO\"\n    }\n    for i := 2; i <= int(math.Sqrt(float64(intersectionLength))); i++ {\n        if intersectionLength%i == 0 {\n            return \"NO\"\n        }\n    }\n    return \"YES\"\n}",
  "PHP_humaneval-127": "function intersection(array $interval1, array $interval2): string {\n    [$start1, $end1] = $interval1;\n    [$start2, $end2] = $interval2;\n    $intersection_start = max($start1, $start2);\n    $intersection_end = min($end1, $end2);\n    if ($intersection_start > $intersection_end) {\n        return \"NO\";\n    }\n    $intersection_length = $intersection_end - $intersection_start;\n    if ($intersection_length <= 1) {\n        return \"NO\";\n    }\n    for ($i = 2; $i <= sqrt($intersection_length); $i++) {\n        if ($intersection_length % $i == 0) {\n            return \"NO\";\n        }\n    }\n    return \"YES\";\n}",
  "Ruby_humaneval-127": "def intersection(interval1, interval2)\n  start1, end1 = interval1\n  start2, end2 = interval2\n  intersection_start = [start1, start2].max\n  intersection_end = [end1, end2].min\n  return \"NO\" if intersection_start > intersection_end\n  intersection_length = intersection_end - intersection_start\n  return \"NO\" if intersection_length <= 1\n  (2..Math.sqrt(intersection_length).to_i).each do |i|\n    return \"NO\" if intersection_length % i == 0\n  end\n  \"YES\"\nend",
  "Swift_humaneval-127": "func intersection(_ interval1: [Int], _ interval2: [Int]) -> String {\n  let start1 = interval1[0]\n  let end1 = interval1[1]\n  let start2 = interval2[0]\n  let end2 = interval2[1]\n  let intersection_start = max(start1, start2)\n  let intersection_end = min(end1, end2)\n  if intersection_start > intersection_end {\n    return \"NO\"\n  }\n  let intersection_length = intersection_end - intersection_start\n  if intersection_length <= 1 {\n    return \"NO\"\n  }\n  for i in 2..<Int(sqrt(Double(intersection_length)) + 1) {\n    if intersection_length % i == 0 {\n      return \"NO\"\n    }\n  }\n  return \"YES\"\n}",
  "TypeScript_humaneval-127": "function intersection(interval1: number[], interval2: number[]): string {\n  const [start1, end1] = interval1;\n  const [start2, end2] = interval2;\n  const intersectionStart = Math.max(start1, start2);\n  const intersectionEnd = Math.min(end1, end2);\n  if (intersectionStart > intersectionEnd) {\n    return \"NO\";\n  }\n  const intersectionLength = intersectionEnd - intersectionStart;\n  if (intersectionLength <= 1) {\n    return \"NO\";\n  }\n  for (let i = 2; i <= Math.floor(Math.sqrt(intersectionLength)); i++) {\n    if (intersectionLength % i === 0) {\n      return \"NO\";\n    }\n  }\n  return \"YES\";\n}",
  "Dart_humaneval-127": "String intersection(List<int> interval1, List<int> interval2) {\n  int start1 = interval1[0], end1 = interval1[1];\n  int start2 = interval2[0], end2 = interval2[1];\n  int intersectionStart = max(start1, start2);\n  int intersectionEnd = min(end1, end2);\n  if (intersectionStart > intersectionEnd) {\n    return \"NO\";\n  }\n  int intersectionLength = intersectionEnd - intersectionStart;\n  if (intersectionLength <= 1) {\n    return \"NO\";\n  }\n  for (int i = 2; i <= sqrt(intersectionLength).floor(); i++) {\n    if (intersectionLength % i == 0) {\n      return \"NO\";\n    }\n  }\n  return \"YES\";\n}",
  "Rust_humaneval-127": "fn intersection(interval1: Vec<i32>, interval2: Vec<i32>) -> String {\n    let (start1, end1) = (interval1[0], interval1[1]);\n    let (start2, end2) = (interval2[0], interval2[1]);\n    let intersection_start = start1.max(start2);\n    let intersection_end = end1.min(end2);\n    if intersection_start > intersection_end {\n        return \"NO\".to_string();\n    }\n    let intersection_length = intersection_end - intersection_start;\n    if intersection_length <= 1 {\n        return \"NO\".to_string();\n    }\n    for i in 2..=((intersection_length as f64).sqrt() as i32) {\n        if intersection_length % i == 0 {\n            return \"NO\".to_string();\n        }\n    }\n    \"YES\".to_string()\n}",
  "Scala_humaneval-127": "def intersection(interval1: List[Int], interval2: List[Int]): String = {\n  val List(start1, end1) = interval1\n  val List(start2, end2) = interval2\n  val intersection_start = start1.max(start2)\n  val intersection_end = end1.min(end2)\n  if (intersection_start > intersection_end) {\n    \"NO\"\n  } else {\n    val intersection_length = intersection_end - intersection_start\n    if (intersection_length <= 1) {\n      \"NO\"\n    } else {\n      for (i <- 2 to sqrt(intersection_length).toInt) {\n        if (intersection_length % i == 0) {\n          return \"NO\"\n        }\n      }\n      \"YES\"\n    }\n  }\n}",
  "Kotlin_humaneval-127": "fun intersection(interval1: List<Int>, interval2: List<Int>): String {\n  val (start1, end1) = interval1\n  val (start2, end2) = interval2\n  val intersectionStart = maxOf(start1, start2)\n  val intersectionEnd = minOf(end1, end2)\n  if (intersectionStart > intersectionEnd) {\n    return \"NO\"\n  }\n  val intersectionLength = intersectionEnd - intersectionStart\n  if (intersectionLength <= 1) {\n    return \"NO\"\n  }\n  for (i in 2..(sqrt(intersectionLength.toDouble()).toInt())) {\n    if (intersectionLength % i == 0) {\n      return \"NO\"\n    }\n  }\n  return \"YES\"\n}",
  "C++_humaneval-128": "int prodSigns(vector<int> arr) {\n  int sign_product = 1;\n  int magnitude_sum = 0;\n  for (int num : arr) {\n    if (num == 0) {\n      sign_product = 0;\n    } else if (num < 0) {\n      sign_product *= -1;\n      magnitude_sum += abs(num);\n    } else {\n      magnitude_sum += num;\n    }\n  }\n  return sign_product * magnitude_sum;\n}",
  "Java_humaneval-128": "public static Integer prodSigns(List<Integer> arr) {\n  int signProduct = 1;\n  int magnitudeSum = 0;\n  for (int num : arr) {\n    if (num == 0) {\n      signProduct = 0;\n    } else if (num < 0) {\n      signProduct *= -1;\n      magnitudeSum += Math.abs(num);\n    } else {\n      magnitudeSum += num;\n    }\n  }\n  return signProduct * magnitudeSum;\n}",
  "Python_humaneval-128": "def prod_signs(arr: List[int]) -> int:\n    sign_product = 1\n    magnitude_sum = 0\n    for num in arr:\n        if num == 0:\n            sign_product = 0\n        elif num < 0:\n            sign_product *= -1\n            magnitude_sum += abs(num)\n        else:\n            magnitude_sum += num\n    return sign_product * magnitude_sum",
  "C#_humaneval-128": "public static int ProdSigns(List<int> arr) {\n  int sign_product = 1;\n  int magnitude_sum = 0;\n  foreach (int num in arr) {\n    if (num == 0) {\n      sign_product = 0;\n    } else if (num < 0) {\n      sign_product *= -1;\n      magnitude_sum += Math.Abs(num);\n    } else {\n      magnitude_sum += num;\n    }\n  }\n  return sign_product * magnitude_sum;\n}",
  "JavaScript_humaneval-128": "function prodSigns(arr) {\n  let signProduct = 1;\n  let magnitudeSum = 0;\n  for (let num of arr) {\n    if (num === 0) {\n      signProduct = 0;\n    } else if (num < 0) {\n      signProduct *= -1;\n      magnitudeSum += Math.abs(num);\n    } else {\n      magnitudeSum += num;\n    }\n  }\n  return signProduct * magnitudeSum;\n}",
  "Go_humaneval-128": "func prodSigns(arr []int) int {\n    signProduct := 1\n    magnitudeSum := 0\n    for _, num := range arr {\n        if num == 0 {\n            signProduct = 0\n        } else if num < 0 {\n            signProduct *= -1\n            magnitudeSum += int(math.Abs(float64(num)))\n        } else {\n            magnitudeSum += num\n        }\n    }\n    return signProduct * magnitudeSum\n}",
  "PHP_humaneval-128": "function prodSigns(array $arr): int {\n    $sign_product = 1;\n    $magnitude_sum = 0;\n    foreach ($arr as $num) {\n        if ($num == 0) {\n            $sign_product = 0;\n        } elseif ($num < 0) {\n            $sign_product *= -1;\n            $magnitude_sum += abs($num);\n        } else {\n            $magnitude_sum += $num;\n        }\n    }\n    return $sign_product * $magnitude_sum;\n}",
  "Ruby_humaneval-128": "def prod_signs(arr)\n  sign_product = 1\n  magnitude_sum = 0\n  arr.each do |num|\n    if num == 0\n      sign_product = 0\n    elsif num < 0\n      sign_product *= -1\n      magnitude_sum += num.abs\n    else\n      magnitude_sum += num\n    end\n  end\n  return sign_product * magnitude_sum\nend",
  "Swift_humaneval-128": "func prodSigns(_ arr: [Int]) -> Int {\n  var signProduct = 1\n  var magnitudeSum = 0\n  for num in arr {\n    if num == 0 {\n      signProduct = 0\n    } else if num < 0 {\n      signProduct *= -1\n      magnitudeSum += abs(num)\n    } else {\n      magnitudeSum += num\n    }\n  }\n  return signProduct * magnitudeSum\n}",
  "TypeScript_humaneval-128": "function prodSigns(arr: number[]): number {\n  let signProduct: number = 1;\n  let magnitudeSum: number = 0;\n  for (let num of arr) {\n    if (num == 0) {\n      signProduct = 0;\n    } else if (num < 0) {\n      signProduct *= -1;\n      magnitudeSum += Math.abs(num);\n    } else {\n      magnitudeSum += num;\n    }\n  }\n  return signProduct * magnitudeSum;\n}",
  "Dart_humaneval-128": "int prodSigns(List<int> arr) {\n  int signProduct = 1;\n  int magnitudeSum = 0;\n  for (int num in arr) {\n    if (num == 0) {\n      signProduct = 0;\n    } else if (num < 0) {\n      signProduct *= -1;\n      magnitudeSum += num.abs();\n    } else {\n      magnitudeSum += num;\n    }\n  }\n  return signProduct * magnitudeSum;\n}",
  "Rust_humaneval-128": "fn prod_signs(arr: Vec<i32>) -> i32 {\n    let mut sign_product = 1;\n    let mut magnitude_sum = 0;\n    for num in arr {\n        if num == 0 {\n            sign_product = 0;\n        } else if num < 0 {\n            sign_product *= -1;\n            magnitude_sum += num.abs();\n        } else {\n            magnitude_sum += num;\n        }\n    }\n    sign_product * magnitude_sum\n}",
  "Scala_humaneval-128": "def prodSigns(arr: List[Int]): Int = {\n  var signProduct = 1\n  var magnitudeSum = 0\n  for (num <- arr) {\n    if (num == 0) {\n      signProduct = 0\n    } else if (num < 0) {\n      signProduct *= -1\n      magnitudeSum += num.abs\n    } else {\n      magnitudeSum += num\n    }\n  }\n  signProduct * magnitudeSum\n}",
  "Kotlin_humaneval-128": "fun prodSigns(arr: List<Int>): Int {\n  var signProduct = 1\n  var magnitudeSum = 0\n  for (num in arr) {\n    if (num == 0) {\n      signProduct = 0\n    } else if (num < 0) {\n      signProduct *= -1\n      magnitudeSum += num.absoluteValue\n    } else {\n      magnitudeSum += num\n    }\n  }\n  return signProduct * magnitudeSum\n}",
  "C++_humaneval-129": "vector<int> minPath(vector<vector<int>> grid, int k) {\n  int n = grid.size();\n  int val = n * n + 1;\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < n; j++) {\n      if (grid[i][j] == 1) {\n        vector<int> temp;\n        if (i != 0) {\n          temp.push_back(grid[i - 1][j]);\n        }\n        if (j != 0) {\n          temp.push_back(grid[i][j - 1]);\n        }\n        if (i != n - 1) {\n          temp.push_back(grid[i + 1][j]);\n        }\n        if (j != n - 1) {\n          temp.push_back(grid[i][j + 1]);\n        }\n        val = min(val, *min_element(temp.begin(), temp.end()));\n      }\n    }\n  }\n  vector<int> ans;\n  for (int i = 0; i < k; i++) {\n    if (i % 2 == 0) {\n      ans.push_back(1);\n    } else {\n      ans.push_back(val);\n    }\n  }\n  return ans;\n}",
  "Java_humaneval-129": "public static List<Integer> minPath(List<List<Integer>> grid, Integer k) {\n  int n = grid.size();\n  int val = n * n + 1;\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < n; j++) {\n      if (grid.get(i).get(j) == 1) {\n        List<Integer> temp = new ArrayList<>();\n        if (i != 0) {\n          temp.add(grid.get(i - 1).get(j));\n        }\n        if (j != 0) {\n          temp.add(grid.get(i).get(j - 1));\n        }\n        if (i != n - 1) {\n          temp.add(grid.get(i + 1).get(j));\n        }\n        if (j != n - 1) {\n          temp.add(grid.get(i).get(j + 1));\n        }\n        val = Collections.min(temp);\n      }\n    }\n  }\n  List<Integer> ans = new ArrayList<>();\n  for (int i = 0; i < k; i++) {\n    if (i % 2 == 0) {\n      ans.add(1);\n    } else {\n      ans.add(val);\n    }\n  }\n  return ans;\n}",
  "Python_humaneval-129": "def min_path(grid: List[List[int]], k: int) -> List[int]:\n    n = len(grid)\n    val = n * n + 1\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == 1:\n                temp = []\n                if i != 0:\n                    temp.append(grid[i - 1][j])\n                if j != 0:\n                    temp.append(grid[i][j - 1])\n                if i != n - 1:\n                    temp.append(grid[i + 1][j])\n                if j != n - 1:\n                    temp.append(grid[i][j + 1])\n                val = min(temp)\n    ans = []\n    for i in range(k):\n        if i % 2 == 0:\n            ans.append(1)\n        else:\n            ans.append(val)\n    return ans",
  "C#_humaneval-129": "public static List<int> MinPath(List<List<int>> grid, int k) {\n  int n = grid.Count;\n  int val = n * n + 1;\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < n; j++) {\n      if (grid[i][j] == 1) {\n        List<int> temp = new List<int>();\n        if (i != 0)\n          temp.Add(grid[i - 1][j]);\n        if (j != 0)\n          temp.Add(grid[i][j - 1]);\n        if (i != n - 1)\n          temp.Add(grid[i + 1][j]);\n        if (j != n - 1)\n          temp.Add(grid[i][j + 1]);\n        val = temp.Min();\n      }\n    }\n  }\n  List<int> ans = new List<int>();\n  for (int i = 0; i < k; i++) {\n    if (i % 2 == 0)\n      ans.Add(1);\n    else\n      ans.Add(val);\n  }\n  return ans;\n}",
  "JavaScript_humaneval-129": "function minPath(grid, k) {\n  let n = grid.length;\n  let val = n * n + 1;\n  for (let i = 0; i < n; i++) {\n    for (let j = 0; j < n; j++) {\n      if (grid[i][j] == 1) {\n        let temp = [];\n        if (i != 0) {\n          temp.push(grid[i - 1][j]);\n        }\n        if (j != 0) {\n          temp.push(grid[i][j - 1]);\n        }\n        if (i != n - 1) {\n          temp.push(grid[i + 1][j]);\n        }\n        if (j != n - 1) {\n          temp.push(grid[i][j + 1]);\n        }\n        val = Math.min(...temp);\n      }\n    }\n  }\n  let ans = [];\n  for (let i = 0; i < k; i++) {\n    if (i % 2 == 0) {\n      ans.push(1);\n    } else {\n      ans.push(val);\n    }\n  }\n  return ans;\n}",
  "Go_humaneval-129": "func minPath(grid [][]int, k int) []int {\n    n := len(grid)\n    val := n*n + 1\n    for i := 0; i < n; i++ {\n        for j := 0; j < n; j++ {\n            if grid[i][j] == 1 {\n                temp := []int{}\n                if i != 0 {\n                    temp = append(temp, grid[i-1][j])\n                }\n                if j != 0 {\n                    temp = append(temp, grid[i][j-1])\n                }\n                if i != n-1 {\n                    temp = append(temp, grid[i+1][j])\n                }\n                if j != n-1 {\n                    temp = append(temp, grid[i][j+1])\n                }\n                for _, v := range temp {\n                    if v < val {\n                        val = v\n                    }\n                }\n            }\n        }\n    }\n    ans := []int{}\n    for i := 0; i < k; i++ {\n        if i%2 == 0 {\n            ans = append(ans, 1)\n        } else {\n            ans = append(ans, val)\n        }\n    }\n    return ans\n}",
  "PHP_humaneval-129": "function minPath(array $grid, int $k): array {\n    $n = count($grid);\n    $val = $n * $n + 1;\n    for ($i = 0; $i < $n; $i++) {\n        for ($j = 0; $j < $n; $j++) {\n            if ($grid[$i][$j] == 1) {\n                $temp = [];\n                if ($i != 0) {\n                    $temp[] = $grid[$i - 1][$j];\n                }\n                if ($j != 0) {\n                    $temp[] = $grid[$i][$j - 1];\n                }\n                if ($i != $n - 1) {\n                    $temp[] = $grid[$i + 1][$j];\n                }\n                if ($j != $n - 1) {\n                    $temp[] = $grid[$i][$j + 1];\n                }\n                $val = min($temp);\n            }\n        }\n    }\n    $ans = [];\n    for ($i = 0; $i < $k; $i++) {\n        if ($i % 2 == 0) {\n            $ans[] = 1;\n        } else {\n            $ans[] = $val;\n        }\n    }\n    return $ans;\n}",
  "Ruby_humaneval-129": "def min_path(grid, k)\n  n = grid.length\n  val = n * n + 1\n  for i in 0...n\n    for j in 0...n\n      if grid[i][j] == 1\n        temp = []\n        temp << grid[i - 1][j] if i != 0\n        temp << grid[i][j - 1] if j != 0\n        temp << grid[i + 1][j] if i != n - 1\n        temp << grid[i][j + 1] if j != n - 1\n        val = temp.min\n      end\n    end\n  end\n  ans = []\n  for i in 0...k\n    if i % 2 == 0\n      ans << 1\n    else\n      ans << val\n    end\n  end\n  return ans\nend",
  "Swift_humaneval-129": "func minPath(_ grid: [[Int]], _ k: Int) -> [Int] {\n  let n = grid.count\n  var val = n * n + 1\n  for i in 0..<n {\n    for j in 0..<n {\n      if grid[i][j] == 1 {\n        var temp = [Int]()\n        if i != 0 {\n          temp.append(grid[i - 1][j])\n        }\n        if j != 0 {\n          temp.append(grid[i][j - 1])\n        }\n        if i != n - 1 {\n          temp.append(grid[i + 1][j])\n        }\n        if j != n - 1 {\n          temp.append(grid[i][j + 1])\n        }\n        val = temp.min() ?? val\n      }\n    }\n  }\n  var ans = [Int]()\n  for i in 0..<k {\n    if i % 2 == 0 {\n      ans.append(1)\n    } else {\n      ans.append(val)\n    }\n  }\n  return ans\n}",
  "TypeScript_humaneval-129": "function minPath(grid: number[][], k: number): number[] {\n  const n = grid.length;\n  let val = n * n + 1;\n  for (let i = 0; i < n; i++) {\n    for (let j = 0; j < n; j++) {\n      if (grid[i][j] === 1) {\n        const temp = [];\n        if (i !== 0) {\n          temp.push(grid[i - 1][j]);\n        }\n        if (j !== 0) {\n          temp.push(grid[i][j - 1]);\n        }\n        if (i !== n - 1) {\n          temp.push(grid[i + 1][j]);\n        }\n        if (j !== n - 1) {\n          temp.push(grid[i][j + 1]);\n        }\n        val = Math.min(...temp);\n      }\n    }\n  }\n  const ans = [];\n  for (let i = 0; i < k; i++) {\n    ans.push(i % 2 === 0 ? 1 : val);\n  }\n  return ans;\n}",
  "Dart_humaneval-129": "List<int> minPath(List<List<int>> grid, int k) {\n  int n = grid.length;\n  int val = n * n + 1;\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < n; j++) {\n      if (grid[i][j] == 1) {\n        List<int> temp = [];\n        if (i != 0) {\n          temp.add(grid[i - 1][j]);\n        }\n        if (j != 0) {\n          temp.add(grid[i][j - 1]);\n        }\n        if (i != n - 1) {\n          temp.add(grid[i + 1][j]);\n        }\n        if (j != n - 1) {\n          temp.add(grid[i][j + 1]);\n        }\n        val = temp.reduce((a, b) => a < b ? a : b);\n      }\n    }\n  }\n  List<int> ans = [];\n  for (int i = 0; i < k; i++) {\n    if (i % 2 == 0) {\n      ans.add(1);\n    } else {\n      ans.add(val);\n    }\n  }\n  return ans;\n}",
  "Rust_humaneval-129": "fn min_path(grid: Vec<Vec<i32>>, k: i32) -> Vec<i32> {\n    let n = grid.len();\n    let mut val = (n * n + 1) as i32;\n    for i in 0..n {\n        for j in 0..n {\n            if grid[i][j] == 1 {\n                let mut temp = Vec::new();\n                if i != 0 {\n                    temp.push(grid[i - 1][j]);\n                }\n                if j != 0 {\n                    temp.push(grid[i][j - 1]);\n                }\n                if i != n - 1 {\n                    temp.push(grid[i + 1][j]);\n                }\n                if j != n - 1 {\n                    temp.push(grid[i][j + 1]);\n                }\n                val = temp.iter().min().unwrap_or(&val).clone();\n            }\n        }\n    }\n    let mut ans = Vec::new();\n    for i in 0..k {\n        if i % 2 == 0 {\n            ans.push(1);\n        } else {\n            ans.push(val);\n        }\n    }\n    ans\n}",
  "Scala_humaneval-129": "def minPath(grid: List[List[Int]], k: Int): List[Int] = {\n  val n = grid.length\n  var value = n * n + 1\n  for {\n    i <- 0 until n\n    j <- 0 until n\n    if grid(i)(j) == 1\n  } {\n    val temp = List(\n      if (i != 0) grid(i - 1)(j) else value,\n      if (j != 0) grid(i)(j - 1) else value,\n      if (i != n - 1) grid(i + 1)(j) else value,\n      if (j != n - 1) grid(i)(j + 1) else value\n    )\n    value = temp.min\n  }\n  val ans = (0 until k).map(i => if (i % 2 == 0) 1 else value).toList\n  ans\n}",
  "Kotlin_humaneval-129": "fun minPath(grid: List<List<Int>>, k: Int): List<Int> {\n  val n = grid.size\n  var val_ = n * n + 1\n  for (i in 0 until n) {\n    for (j in 0 until n) {\n      if (grid[i][j] == 1) {\n        val temp = mutableListOf<Int>()\n        if (i != 0) {\n          temp.add(grid[i - 1][j])\n        }\n        if (j != 0) {\n          temp.add(grid[i][j - 1])\n        }\n        if (i != n - 1) {\n          temp.add(grid[i + 1][j])\n        }\n        if (j != n - 1) {\n          temp.add(grid[i][j + 1])\n        }\n        val_ = temp.minOrNull() ?: val_\n      }\n    }\n  }\n  val ans = mutableListOf<Int>()\n  for (i in 0 until k) {\n    if (i % 2 == 0) {\n      ans.add(1)\n    } else {\n      ans.add(val_)\n    }\n  }\n  return ans\n}",
  "C++_humaneval-130": "vector<int> tri(int n) {\n  if (n == 0) {\n    return {1};\n  }\n  vector<int> seq = {1, 3};\n  for (int i = 2; i <= n; i++) {\n    if (i % 2 == 0) {\n      seq.push_back(i / 2 + 1);\n    } else {\n      seq.push_back(seq[i - 1] + seq[i - 2] + (i + 3) / 2);\n    }\n  }\n  return seq;\n}",
  "Java_humaneval-130": "public static List<Integer> tri(Integer n) {\n  if (n == 0) {\n    List<Integer> seq = new ArrayList<>();\n    seq.add(1);\n    return seq;\n  }\n  List<Integer> seq = new ArrayList<>();\n  seq.add(1);\n  seq.add(3);\n  for (int i = 2; i <= n; i++) {\n    if (i % 2 == 0) {\n      seq.add(i / 2 + 1);\n    } else {\n      seq.add(seq.get(i - 1) + seq.get(i - 2) + (i + 3) / 2);\n    }\n  }\n  return seq;\n}",
  "Python_humaneval-130": "def tri(n: int) -> List[int]:\n    if n == 0:\n        return [1]\n    seq = [1, 3]\n    for i in range(2, n + 1):\n        if i % 2 == 0:\n            seq.append(i / 2 + 1)\n        else:\n            seq.append(seq[i - 1] + seq[i - 2] + (i + 3) / 2)\n    return seq",
  "C#_humaneval-130": "public static List<int> Tri(int n) {\n  if (n == 0) {\n    return new List<int> { 1 };\n  }\n  List<int> seq = new List<int> { 1, 3 };\n  for (int i = 2; i <= n; i++) {\n    if (i % 2 == 0) {\n      seq.Add(i / 2 + 1);\n    } else {\n      seq.Add(seq[i - 1] + seq[i - 2] + (i + 3) / 2);\n    }\n  }\n  return seq;\n}",
  "JavaScript_humaneval-130": "function tri(n) {\n  if (n === 0) {\n    return [1];\n  }\n  let seq = [1, 3];\n  for (let i = 2; i <= n; i++) {\n    if (i % 2 === 0) {\n      seq.push(i / 2 + 1);\n    } else {\n      seq.push(seq[i - 1] + seq[i - 2] + (i + 3) / 2);\n    }\n  }\n  return seq;\n}",
  "Go_humaneval-130": "func tri(n int) []int {\n    if n == 0 {\n        return []int{1}\n    }\n    seq := []int{1, 3}\n    for i := 2; i <= n; i++ {\n        if i%2 == 0 {\n            seq = append(seq, i/2+1)\n        } else {\n            seq = append(seq, seq[i-1]+seq[i-2]+(i+3)/2)\n        }\n    }\n    return seq\n}",
  "PHP_humaneval-130": "function tri(int $n): array {\n    if ($n == 0) {\n        return [1];\n    }\n    $seq = [1, 3];\n    for ($i = 2; $i <= $n; $i++) {\n        if ($i % 2 == 0) {\n            $seq[] = $i / 2 + 1;\n        } else {\n            $seq[] = $seq[$i - 1] + $seq[$i - 2] + ($i + 3) / 2;\n        }\n    }\n    return $seq;\n}",
  "Ruby_humaneval-130": "def tri(n)\n  return [1] if n == 0\n  seq = [1, 3]\n  for i in 2..n\n    if i % 2 == 0\n      seq << i / 2 + 1\n    else\n      seq << seq[i - 1] + seq[i - 2] + (i + 3) / 2\n    end\n  end\n  return seq\nend",
  "Swift_humaneval-130": "func tri(_ n: Int) -> [Int] {\n  if n == 0 {\n    return [1]\n  }\n  var seq = [1, 3]\n  for i in 2..<n + 1 {\n    if i % 2 == 0 {\n      seq.append(i / 2 + 1)\n    } else {\n      seq.append(seq[i - 1] + seq[i - 2] + (i + 3) / 2)\n    }\n  }\n  return seq\n}",
  "TypeScript_humaneval-130": "function tri(n: number): number[] {\n  if (n === 0) {\n    return [1];\n  }\n  const seq: number[] = [1, 3];\n  for (let i = 2; i <= n; i++) {\n    if (i % 2 === 0) {\n      seq.push(i / 2 + 1);\n    } else {\n      seq.push(seq[i - 1] + seq[i - 2] + (i + 3) / 2);\n    }\n  }\n  return seq;\n}",
  "Dart_humaneval-130": "List<int> tri(int n) {\n  if (n == 0) {\n    return [1];\n  }\n  List<int> seq = [1, 3];\n  for (int i = 2; i <= n; i++) {\n    if (i % 2 == 0) {\n      seq.add((i / 2).toInt() + 1);\n    } else {\n      seq.add(seq[i - 1] + seq[i - 2] + ((i + 3) / 2).toInt());\n    }\n  }\n  return seq;\n}",
  "Rust_humaneval-130": "fn tri(n: i32) -> Vec<i32> {\n    if n == 0 {\n        return vec![1];\n    }\n    let mut seq = vec![1, 3];\n    for i in 2..=n {\n        if i % 2 == 0 {\n            seq.push(i / 2 + 1);\n        } else {\n            seq.push(seq[(i - 1) as usize] + seq[(i - 2) as usize] + (i + 3) / 2);\n        }\n    }\n    seq\n}",
  "Scala_humaneval-130": "def tri(n: Int): List[Int] = {\n  if (n == 0) {\n    return List(1)\n  }\n  val seq = ListBuffer(1, 3)\n  for (i <- 2 to n) {\n    if (i % 2 == 0) {\n      seq += (i / 2 + 1)\n    } else {\n      seq += (seq(i - 1) + seq(i - 2) + (i + 3) / 2)\n    }\n  }\n  seq.toList\n}",
  "Kotlin_humaneval-130": "fun tri(n: Int): List<Int> {\n  if (n == 0) {\n    return listOf(1)\n  }\n  val seq = mutableListOf(1, 3)\n  for (i in 2..n) {\n    if (i % 2 == 0) {\n      seq.add(i / 2 + 1)\n    } else {\n      seq.add(seq[i - 1] + seq[i - 2] + (i + 3) / 2)\n    }\n  }\n  return seq\n}",
  "C++_humaneval-131": "int digits(int n) {\n  int product = 1;\n  bool has_odd_digit = false;\n  string str_n = to_string(n);\n  for (char digit : str_n) {\n    if (digit % 2 == 1) {\n      product *= digit - '0';\n      has_odd_digit = true;\n    }\n  }\n  if (has_odd_digit) {\n    return product;\n  } else {\n    return 0;\n  }\n}",
  "Java_humaneval-131": "public static Integer digits(Integer n) {\n  int product = 1;\n  boolean has_odd_digit = false;\n  for (char digit : n.toString().toCharArray()) {\n    if (digit % 2 == 1) {\n      product *= Integer.parseInt(String.valueOf(digit));\n      has_odd_digit = true;\n    }\n  }\n  if (has_odd_digit) {\n    return product;\n  } else {\n    return 0;\n  }\n}",
  "Python_humaneval-131": "def digits(n: int) -> int:\n    product = 1\n    has_odd_digit = False\n    for digit in str(n):\n        if int(digit) % 2 == 1:\n            product *= int(digit)\n            has_odd_digit = True\n    if has_odd_digit:\n        return product\n    else:\n        return 0",
  "C#_humaneval-131": "public static int Digits(int n) {\n  int product = 1;\n  bool hasOddDigit = false;\n  foreach (char digit in n.ToString()) {\n    if (int.Parse(digit.ToString()) % 2 == 1) {\n      product *= int.Parse(digit.ToString());\n      hasOddDigit = true;\n    }\n  }\n  if (hasOddDigit) {\n    return product;\n  } else {\n    return 0;\n  }\n}",
  "JavaScript_humaneval-131": "function digits(n) {\n  let product = 1;\n  let has_odd_digit = false;\n  for (let digit of String(n)) {\n    if (Number(digit) % 2 === 1) {\n      product *= Number(digit);\n      has_odd_digit = true;\n    }\n  }\n  if (has_odd_digit) {\n    return product;\n  } else {\n    return 0;\n  }\n}",
  "Go_humaneval-131": "func digits(n int) int {\n    product := 1\n    hasOddDigit := false\n    for _, digit := range strconv.Itoa(n) {\n        if int(digit-'0')%2 == 1 {\n            product *= int(digit - '0')\n            hasOddDigit = true\n        }\n    }\n    if hasOddDigit {\n        return product\n    } else {\n        return 0\n    }\n}",
  "PHP_humaneval-131": "function digits(int $n): int {\n    $product = 1;\n    $has_odd_digit = false;\n    foreach(str_split((string) $n) as $digit) {\n        if ((int) $digit % 2 === 1) {\n            $product *= (int) $digit;\n            $has_odd_digit = true;\n        }\n    }\n    if ($has_odd_digit) {\n        return $product;\n    } else {\n        return 0;\n    }\n}",
  "Ruby_humaneval-131": "def digits(n)\n  product = 1\n  has_odd_digit = false\n  n.to_s.each_char do |digit|\n    if digit.to_i.odd?\n      product *= digit.to_i\n      has_odd_digit = true\n    end\n  end\n  has_odd_digit ? product : 0\nend",
  "Swift_humaneval-131": "func digits(_ n: Int) -> Int {\n  var product = 1\n  var hasOddDigit = false\n  for digit in String(n) {\n    if let intDigit = Int(String(digit)), intDigit % 2 == 1 {\n      product *= intDigit\n      hasOddDigit = true\n    }\n  }\n  return hasOddDigit ? product : 0\n}",
  "TypeScript_humaneval-131": "function digits(n: number): number {\n  let product: number = 1;\n  let has_odd_digit: boolean = false;\n  for (let digit of n.toString()) {\n    if (parseInt(digit) % 2 == 1) {\n      product *= parseInt(digit);\n      has_odd_digit = true;\n    }\n  }\n  if (has_odd_digit) {\n    return product;\n  } else {\n    return 0;\n  }\n}",
  "Dart_humaneval-131": "int digits(int n) {\n  int product = 1;\n  bool hasOddDigit = false;\n  for (var digit in n.toString().split('')) {\n    if (int.parse(digit) % 2 == 1) {\n      product *= int.parse(digit);\n      hasOddDigit = true;\n    }\n  }\n  if (hasOddDigit) {\n    return product;\n  } else {\n    return 0;\n  }\n}",
  "Rust_humaneval-131": "fn digits(n: i32) -> i32 {\n    let mut product = 1;\n    let mut has_odd_digit = false;\n    for digit in n.to_string().chars() {\n        if digit.to_digit(10).unwrap() % 2 == 1 {\n            product *= digit.to_digit(10).unwrap() as i32;\n            has_odd_digit = true;\n        }\n    }\n    if has_odd_digit {\n        product\n    } else {\n        0\n    }\n}",
  "Scala_humaneval-131": "def digits(n: Int): Int = {\n  var product = 1\n  var hasOddDigit = false\n  for (digit <- n.toString) {\n    if (digit.toInt % 2 == 1) {\n      product *= digit.asDigit\n      hasOddDigit = true\n    }\n  }\n  if (hasOddDigit) product else 0\n}",
  "Kotlin_humaneval-131": "fun digits(n: Int): Int {\n  var product = 1\n  var hasOddDigit = false\n  for (digit in n.toString()) {\n    if (digit.toString().toInt() % 2 == 1) {\n      product *= digit.toString().toInt()\n      hasOddDigit = true\n    }\n  }\n  return if (hasOddDigit) product else 0\n}",
  "C++_humaneval-132": "bool isNested(string s) {\n  stack<char> st;\n  int depth = 0;\n  int max_depth = 0;\n  for (char bracket : s) {\n    if (bracket == '[') {\n      st.push(bracket);\n      depth++;\n      max_depth = max(depth, max_depth);\n    } else if (bracket == ']') {\n      if (!st.empty() && st.top() == '[') {\n        st.pop();\n        depth--;\n      } else {\n        return false;\n      }\n    }\n  }\n  return st.empty() && max_depth >= 2;\n}",
  "Java_humaneval-132": "public static Boolean isNested(String s) {\n  Stack<Character> stack = new Stack<>();\n  int depth = 0;\n  int maxDepth = 0;\n  for (char bracket : s.toCharArray()) {\n    if (bracket == '[') {\n      stack.push(bracket);\n      depth++;\n      maxDepth = Math.max(depth, maxDepth);\n    } else if (bracket == ']') {\n      if (!stack.isEmpty() && stack.peek() == '[') {\n        stack.pop();\n        depth--;\n      } else {\n        return false;\n      }\n    }\n  }\n  return stack.isEmpty() && maxDepth >= 2;\n}",
  "Python_humaneval-132": "def is_nested(s: str) -> bool:\n    stack = []\n    depth = 0\n    max_depth = 0\n    for bracket in s:\n        if bracket == \"[\":\n            stack.append(bracket)\n            depth += 1\n            max_depth = max(depth, max_depth)\n        elif bracket == \"]\":\n            if stack and stack[-1] == \"[\":\n                stack.pop()\n                depth -= 1\n            else:\n                return False\n    return len(stack) == 0 and max_depth >= 2",
  "C#_humaneval-132": "public static bool IsNested(string s) {\n  var stack = new Stack<char>();\n  int depth = 0;\n  int maxDepth = 0;\n  foreach (char bracket in s) {\n    if (bracket == '[') {\n      stack.Push(bracket);\n      depth++;\n      maxDepth = Math.Max(depth, maxDepth);\n    } else if (bracket == ']') {\n      if (stack.Count > 0 && stack.Peek() == '[') {\n        stack.Pop();\n        depth--;\n      } else {\n        return false;\n      }\n    }\n  }\n  return stack.Count == 0 && maxDepth >= 2;\n}",
  "JavaScript_humaneval-132": "function isNested(s) {\n  let stack = [];\n  let depth = 0;\n  let maxDepth = 0;\n  for (let i = 0; i < s.length; i++) {\n    let bracket = s[i];\n    if (bracket === \"[\") {\n      stack.push(bracket);\n      depth++;\n      maxDepth = Math.max(depth, maxDepth);\n    } else if (bracket === \"]\") {\n      if (stack.length && stack[stack.length - 1] === \"[\") {\n        stack.pop();\n        depth--;\n      } else {\n        return false;\n      }\n    }\n  }\n  return stack.length === 0 && maxDepth >= 2;\n}",
  "Go_humaneval-132": "func isNested(s string) bool {\n    stack := []string{}\n    depth := 0\n    maxDepth := 0\n    for _, bracket := range s {\n        if bracket == '[' {\n            stack = append(stack, \"[\")\n            depth++\n            if depth > maxDepth {\n                maxDepth = depth\n            }\n        } else if bracket == ']' {\n            if len(stack) > 0 && stack[len(stack)-1] == \"[\" {\n                stack = stack[:len(stack)-1]\n                depth--\n            } else {\n                return false\n            }\n        }\n    }\n    return len(stack) == 0 && maxDepth >= 2\n}",
  "PHP_humaneval-132": "function isNested(string $s): bool {\n    $stack = [];\n    $depth = 0;\n    $max_depth = 0;\n    for ($i = 0; $i < strlen($s); $i++) {\n        $bracket = $s[$i];\n        if ($bracket == \"[\") {\n            array_push($stack, $bracket);\n            $depth++;\n            $max_depth = max($depth, $max_depth);\n        } elseif ($bracket == \"]\") {\n            if (!empty($stack) && end($stack) == \"[\") {\n                array_pop($stack);\n                $depth--;\n            } else {\n                return false;\n            }\n        }\n    }\n    return empty($stack) && $max_depth >= 2;\n}",
  "Ruby_humaneval-132": "def is_nested(s)\n  stack = []\n  depth = 0\n  max_depth = 0\n  s.each_char do |bracket|\n    if bracket == \"[\"\n      stack.push(bracket)\n      depth += 1\n      max_depth = [depth, max_depth].max\n    elsif bracket == \"]\"\n      if !stack.empty? && stack.last == \"[\"\n        stack.pop\n        depth -= 1\n      else\n        return false\n      end\n    end\n  end\n  stack.empty? && max_depth >= 2\nend",
  "Swift_humaneval-132": "func isNested(_ s: String) -> Bool {\n  var stack = [Character]()\n  var depth = 0\n  var maxDepth = 0\n  for bracket in s {\n    if bracket == \"[\" {\n      stack.append(bracket)\n      depth += 1\n      maxDepth = max(depth, maxDepth)\n    } else if bracket == \"]\" {\n      if stack.last == \"[\" {\n        stack.removeLast()\n        depth -= 1\n      } else {\n        return false\n      }\n    }\n  }\n  return stack.isEmpty && maxDepth >= 2\n}",
  "TypeScript_humaneval-132": "function isNested(s: string): boolean {\n  const stack: string[] = [];\n  let depth = 0;\n  let maxDepth = 0;\n  for (const bracket of s) {\n    if (bracket === \"[\") {\n      stack.push(bracket);\n      depth++;\n      maxDepth = Math.max(depth, maxDepth);\n    } else if (bracket === \"]\") {\n      if (stack.length && stack[stack.length - 1] === \"[\") {\n        stack.pop();\n        depth--;\n      } else {\n        return false;\n      }\n    }\n  }\n  return stack.length === 0 && maxDepth >= 2;\n}",
  "Dart_humaneval-132": "bool isNested(String s) {\n  var stack = [];\n  var depth = 0;\n  var maxDepth = 0;\n  for (var bracket in s.split('')) {\n    if (bracket == \"[\") {\n      stack.add(bracket);\n      depth += 1;\n      maxDepth = depth > maxDepth ? depth : maxDepth;\n    } else if (bracket == \"]\") {\n      if (stack.isNotEmpty && stack.last == \"[\") {\n        stack.removeLast();\n        depth -= 1;\n      } else {\n        return false;\n      }\n    }\n  }\n  return stack.isEmpty && maxDepth >= 2;\n}",
  "Rust_humaneval-132": "fn is_nested(s: String) -> bool {\n    let mut stack: Vec<char> = vec![];\n    let mut depth = 0;\n    let mut max_depth = 0;\n    for bracket in s.chars() {\n        if bracket == '[' {\n            stack.push(bracket);\n            depth += 1;\n            max_depth = depth.max(max_depth);\n        } else if bracket == ']' {\n            if let Some('[') = stack.last() {\n                stack.pop();\n                depth -= 1;\n            } else {\n                return false;\n            }\n        }\n    }\n    stack.is_empty() && max_depth >= 2\n}",
  "Scala_humaneval-132": "def isNested(s: String): Boolean = {\n  var stack = List[Char]()\n  var depth = 0\n  var maxDepth = 0\n  for (bracket <- s) {\n    if (bracket == '[') {\n      stack = bracket :: stack\n      depth += 1\n      maxDepth = depth.max(maxDepth)\n    } else if (bracket == ']') {\n      if (stack.nonEmpty && stack.head == '[') {\n        stack = stack.tail\n        depth -= 1\n      } else {\n        return false\n      }\n    }\n  }\n  stack.isEmpty && maxDepth >= 2\n}",
  "Kotlin_humaneval-132": "fun isNested(s: String): Boolean {\n  val stack = mutableListOf<Char>()\n  var depth = 0\n  var maxDepth = 0\n  for (bracket in s) {\n    if (bracket == '[') {\n      stack.add(bracket)\n      depth++\n      maxDepth = maxOf(depth, maxDepth)\n    } else if (bracket == ']') {\n      if (stack.isNotEmpty() && stack.last() == '[') {\n        stack.removeAt(stack.lastIndex)\n        depth--\n      } else {\n        return false\n      }\n    }\n  }\n  return stack.isEmpty() && maxDepth >= 2\n}",
  "C++_humaneval-133": "int sumSquares(vector<double> l) {\n  int sum_of_squares = 0;\n  for (double num : l) {\n    num = ceil(num);\n    sum_of_squares += pow(num, 2);\n  }\n  return sum_of_squares;\n}",
  "Java_humaneval-133": "public static Integer sumSquares(List<Double> l) {\n  int sumOfSquares = 0;\n  for (Double num : l) {\n    num = Math.ceil(num);\n    sumOfSquares += Math.pow(num, 2);\n  }\n  return sumOfSquares;\n}",
  "Python_humaneval-133": "def sum_squares(l: List[float]) -> int:\n    sum_of_squares = 0\n    for num in l:\n        num = math.ceil(num)\n        sum_of_squares += num**2\n    return sum_of_squares",
  "C#_humaneval-133": "public static int SumSquares(List<double> l) {\n  int sum_of_squares = 0;\n  foreach (double num in l) {\n    int rounded_num = (int)Math.Ceiling(num);\n    sum_of_squares += (int)Math.Pow(rounded_num, 2);\n  }\n  return sum_of_squares;\n}",
  "JavaScript_humaneval-133": "function sumSquares(l) {\n  let sumOfSquares = 0;\n  for (let num of l) {\n    num = Math.ceil(num);\n    sumOfSquares += num ** 2;\n  }\n  return sumOfSquares;\n}",
  "Go_humaneval-133": "func sumSquares(l []float64) int {\n    sumOfSquares := 0\n    for _, num := range l {\n        num = math.Ceil(num)\n        sumOfSquares += int(num * num)\n    }\n    return sumOfSquares\n}",
  "PHP_humaneval-133": "function sumSquares(array $l): int {\n    $sum_of_squares = 0;\n    foreach ($l as $num) {\n        $num = ceil($num);\n        $sum_of_squares += $num**2;\n    }\n    return $sum_of_squares;\n}",
  "Ruby_humaneval-133": "def sum_squares(l)\n  sum_of_squares = 0\n  l.each do |num|\n    num = num.ceil\n    sum_of_squares += num**2\n  end\n  return sum_of_squares\nend",
  "Swift_humaneval-133": "func sumSquares(_ l: [Double]) -> Int {\n  var sumOfSquares = 0\n  for num in l {\n    let num = Int(ceil(num))\n    sumOfSquares += num * num\n  }\n  return sumOfSquares\n}",
  "TypeScript_humaneval-133": "function sumSquares(l: number[]): number {\n  let sumOfSquares = 0;\n  for (let num of l) {\n    num = Math.ceil(num);\n    sumOfSquares += num ** 2;\n  }\n  return sumOfSquares;\n}",
  "Dart_humaneval-133": "int sumSquares(List<double> l) {\n  int sumOfSquares = 0;\n  for (double num in l) {\n    num = num.ceilToDouble();\n    sumOfSquares += pow(num, 2).toInt();\n  }\n  return sumOfSquares;\n}",
  "Rust_humaneval-133": "fn sum_squares(l: Vec<f64>) -> i32 {\n    let mut sum_of_squares = 0;\n    for num in l {\n        let num = num.ceil() as i32;\n        sum_of_squares += num.pow(2);\n    }\n    sum_of_squares\n}",
  "Scala_humaneval-133": "def sumSquares(l: List[Double]): Int = {\n  var sumOfSquares = 0\n  for (num <- l) {\n    val ceilNum = ceil(num)\n    sumOfSquares += pow(ceilNum, 2).toInt\n  }\n  sumOfSquares\n}",
  "Kotlin_humaneval-133": "fun sumSquares(l: List<Double>): Int {\n  var sumOfSquares = 0\n  for (num in l) {\n    val ceilNum = ceil(num).toInt()\n    sumOfSquares += ceilNum * ceilNum\n  }\n  return sumOfSquares\n}",
  "C++_humaneval-134": "bool checkIfLastCharIsALetter(string txt) {\n  if (txt.length() == 0) {\n    return false;\n  } else {\n    char last_char = txt.back();\n    if (isalpha(last_char) &&\n        (txt.substr(txt.find_last_of(' ') + 1).length() == 1)) {\n      return true;\n    } else {\n      return false;\n    }\n  }\n}",
  "Java_humaneval-134": "public static Boolean checkIfLastCharIsALetter(String txt) {\n  if (txt.length() == 0) {\n    return false;\n  } else {\n    char lastChar = txt.charAt(txt.length() - 1);\n    if (Character.isLetter(lastChar) && txt.split(\" \")[txt.split(\" \").length - 1].length() == 1) {\n      return true;\n    } else {\n      return false;\n    }\n  }\n}",
  "Python_humaneval-134": "def check_if_last_char_is_a_letter(txt: str) -> bool:\n    if len(txt) == 0:\n        return False\n    else:\n        last_char = txt[-1]\n        if last_char.isalpha() and (len(txt.split()[-1]) == 1):\n            return True\n        else:\n            return False",
  "C#_humaneval-134": "public static bool CheckIfLastCharIsALetter(string txt) {\n  if (txt.Length == 0) {\n    return false;\n  } else {\n    char lastChar = txt[txt.Length - 1];\n    if (Char.IsLetter(lastChar) && (txt.Split(' ').Last().Length == 1)) {\n      return true;\n    } else {\n      return false;\n    }\n  }\n}",
  "JavaScript_humaneval-134": "function checkIfLastCharIsALetter(txt) {\n  if (txt.length === 0) {\n    return false;\n  } else {\n    const lastChar = txt.slice(-1);\n    if (lastChar.match(/[a-z]/i) && txt.split(\" \").pop().length === 1) {\n      return true;\n    } else {\n      return false;\n    }\n  }\n}",
  "Go_humaneval-134": "func checkIfLastCharIsALetter(txt string) bool {\n    if len(txt) == 0 {\n        return false\n    } else {\n        lastChar := string(txt[len(txt)-1])\n        if unicode.IsLetter([]rune(lastChar)[0]) && (len(strings.Split(txt, \" \")[len(strings.Split(txt, \" \"))-1]) == 1) {\n            return true\n        } else {\n            return false\n        }\n    }\n}",
  "PHP_humaneval-134": "function checkIfLastCharIsALetter(string $txt): bool {\n    if (strlen($txt) == 0) {\n        return false;\n    } else {\n        $last_char = substr($txt, -1);\n        if (ctype_alpha($last_char) && (strlen(end(explode(' ', $txt))) == 1)) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n}",
  "Ruby_humaneval-134": "def check_if_last_char_is_a_letter(txt)\n  if txt.length == 0\n    return false\n  else\n    last_char = txt[-1]\n    if last_char.match?(/[[:alpha:]]/) && (txt.split[-1].length == 1)\n      return true\n    else\n      return false\n    end\n  end\nend",
  "Swift_humaneval-134": "func checkIfLastCharIsALetter(_ txt: String) -> Bool {\n  if txt.isEmpty {\n    return false\n  } else {\n    let lastChar = txt.last!\n    if lastChar.isLetter && (txt.split(separator: \" \").last?.count == 1) {\n      return true\n    } else {\n      return false\n    }\n  }\n}",
  "TypeScript_humaneval-134": "function checkIfLastCharIsALetter(txt: string): boolean {\n  if (txt.length === 0) {\n    return false;\n  } else {\n    const lastChar = txt.slice(-1);\n    if (lastChar.match(/[a-z]/i) && txt.split(\" \").pop().length === 1) {\n      return true;\n    } else {\n      return false;\n    }\n  }\n}",
  "Dart_humaneval-134": "bool checkIfLastCharIsALetter(String txt) {\n  if (txt.length == 0) {\n    return false;\n  } else {\n    String lastChar = txt[txt.length - 1];\n    if (lastChar.contains(new RegExp(r'[a-zA-Z]')) &&\n        (txt.split(' ').last.length == 1)) {\n      return true;\n    } else {\n      return false;\n    }\n  }\n}",
  "Rust_humaneval-134": "fn check_if_last_char_is_a_letter(txt: String) -> bool {\n    if txt.is_empty() {\n        false\n    } else {\n        let last_char = txt.chars().last().unwrap();\n        if last_char.is_alphabetic() && txt.split_whitespace().last().unwrap().len() == 1 {\n            true\n        } else {\n            false\n        }\n    }\n}",
  "Scala_humaneval-134": "def checkIfLastCharIsALetter(txt: String): Boolean = {\n  if (txt.isEmpty) {\n    false\n  } else {\n    val lastChar = txt.last\n    if (lastChar.isLetter && (txt.split(\" \").last.length == 1)) {\n      true\n    } else {\n      false\n    }\n  }\n}",
  "Kotlin_humaneval-134": "fun checkIfLastCharIsALetter(txt: String): Boolean {\n  if (txt.isEmpty()) {\n    return false\n  } else {\n    val lastChar = txt.last()\n    if (lastChar.isLetter() && txt.split(\" \").last().length == 1) {\n      return true\n    } else {\n      return false\n    }\n  }\n}",
  "C++_humaneval-135": "int canArrange(vector<int> arr) {\n  int index = -1;\n  int i = 1;\n  while (i < arr.size()) {\n    if (arr[i] < arr[i - 1]) {\n      index = i;\n    }\n    i++;\n  }\n  return index;\n}",
  "Java_humaneval-135": "public static Integer canArrange(List<Integer> arr) {\n  Integer index = -1;\n  Integer i = 1;\n  while (i < arr.size()) {\n    if (arr.get(i) < arr.get(i - 1)) {\n      index = i;\n    }\n    i++;\n  }\n  return index;\n}",
  "Python_humaneval-135": "def can_arrange(arr: List[int]) -> int:\n    index = -1\n    i = 1\n    while i < len(arr):\n        if arr[i] < arr[i - 1]:\n            index = i\n        i += 1\n    return index",
  "C#_humaneval-135": "public static int CanArrange(List<int> arr) {\n  int index = -1;\n  int i = 1;\n  while (i < arr.Count) {\n    if (arr[i] < arr[i - 1]) {\n      index = i;\n    }\n    i++;\n  }\n  return index;\n}",
  "JavaScript_humaneval-135": "function canArrange(arr) {\n  let index = -1;\n  let i = 1;\n  while (i < arr.length) {\n    if (arr[i] < arr[i - 1]) {\n      index = i;\n    }\n    i++;\n  }\n  return index;\n}",
  "Go_humaneval-135": "func canArrange(arr []int) int {\n    index := -1\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < arr[i-1] {\n            index = i\n        }\n    }\n    return index\n}",
  "PHP_humaneval-135": "function canArrange(array $arr): int {\n    $index = -1;\n    $i = 1;\n    while ($i < count($arr)) {\n        if ($arr[$i] < $arr[$i - 1]) {\n            $index = $i;\n        }\n        $i++;\n    }\n    return $index;\n}",
  "Ruby_humaneval-135": "def can_arrange(arr)\n  index = -1\n  i = 1\n  while i < arr.length\n    index = i if arr[i] < arr[i - 1]\n    i += 1\n  end\n  return index\nend",
  "Swift_humaneval-135": "func canArrange(_ arr: [Int]) -> Int {\n  var index = -1\n  var i = 1\n  while i < arr.count {\n    if arr[i] < arr[i - 1] {\n      index = i\n    }\n    i += 1\n  }\n  return index\n}",
  "TypeScript_humaneval-135": "function canArrange(arr: number[]): number {\n  let index = -1;\n  let i = 1;\n  while (i < arr.length) {\n    if (arr[i] < arr[i - 1]) {\n      index = i;\n    }\n    i++;\n  }\n  return index;\n}",
  "Dart_humaneval-135": "int canArrange(List<int> arr) {\n  int index = -1;\n  int i = 1;\n  while (i < arr.length) {\n    if (arr[i] < arr[i - 1]) {\n      index = i;\n    }\n    i++;\n  }\n  return index;\n}",
  "Rust_humaneval-135": "fn can_arrange(arr: Vec<i32>) -> i32 {\n    let mut index = -1;\n    let mut i = 1;\n    while i < arr.len() {\n        if arr[i] < arr[i - 1] {\n            index = i as i32;\n        }\n        i += 1;\n    }\n    return index;\n}",
  "Scala_humaneval-135": "def canArrange(arr: List[Int]): Int = {\n  var index = -1\n  var i = 1\n  while (i < arr.length) {\n    if (arr(i) < arr(i - 1)) {\n      index = i\n    }\n    i += 1\n  }\n  index\n}",
  "Kotlin_humaneval-135": "fun canArrange(arr: List<Int>): Int {\n  var index = -1\n  var i = 1\n  while (i < arr.size) {\n    if (arr[i] < arr[i - 1]) {\n      index = i\n    }\n    i++\n  }\n  return index\n}",
  "C++_humaneval-136": "vector<int> largestSmallestIntegers(vector<int> l) {\n  vector<int> neg_ints;\n  vector<int> pos_ints;\n  for (int i = 0; i < l.size(); i++) {\n    if (l[i] < 0) {\n      neg_ints.push_back(l[i]);\n    } else if (l[i] > 0) {\n      pos_ints.push_back(l[i]);\n    }\n  }\n  int largest_neg = 0;\n  int smallest_pos = 0;\n  if (neg_ints.size() > 0) {\n    largest_neg = *max_element(neg_ints.begin(), neg_ints.end());\n  }\n  if (pos_ints.size() > 0) {\n    smallest_pos = *min_element(pos_ints.begin(), pos_ints.end());\n  }\n  return {largest_neg, smallest_pos};\n}",
  "Java_humaneval-136": "public static List<Integer> largestSmallestIntegers(List<Integer> l) {\n  List<Integer> negInts = new ArrayList<>();\n  List<Integer> posInts = new ArrayList<>();\n  for (int i : l) {\n    if (i < 0) {\n      negInts.add(i);\n    } else if (i > 0) {\n      posInts.add(i);\n    }\n  }\n  int largestNeg = (negInts.size() == 0) ? 0 : Collections.max(negInts);\n  int smallestPos = (posInts.size() == 0) ? 0 : Collections.min(posInts);\n  List<Integer> result = new ArrayList<>();\n  result.add(largestNeg);\n  result.add(smallestPos);\n  return result;\n}",
  "Python_humaneval-136": "def largest_smallest_integers(l: List[int]) -> List[int]:\n    neg_ints = [i for i in l if i < 0]\n    pos_ints = [i for i in l if i > 0]\n    if len(neg_ints) == 0:\n        largest_neg = 0\n    else:\n        largest_neg = max(neg_ints)\n    if len(pos_ints) == 0:\n        smallest_pos = 0\n    else:\n        smallest_pos = min(pos_ints)\n    return [largest_neg, smallest_pos]",
  "C#_humaneval-136": "public static List<int> LargestSmallestIntegers(List<int> l) {\n  List<int> negInts = l.Where(i => i < 0).ToList();\n  List<int> posInts = l.Where(i => i > 0).ToList();\n  int largestNeg = negInts.Count == 0 ? 0 : negInts.Max();\n  int smallestPos = posInts.Count == 0 ? 0 : posInts.Min();\n  return new List<int> { largestNeg, smallestPos };\n}",
  "JavaScript_humaneval-136": "function largestSmallestIntegers(l) {\n  const negInts = l.filter((i) => i < 0);\n  const posInts = l.filter((i) => i > 0);\n  const largestNeg = negInts.length === 0 ? 0 : Math.max(...negInts);\n  const smallestPos = posInts.length === 0 ? 0 : Math.min(...posInts);\n  return [largestNeg, smallestPos];\n}",
  "Go_humaneval-136": "func largestSmallestIntegers(l []int) []int {\n    negInts := []int{}\n    posInts := []int{}\n    for _, i := range l {\n        if i < 0 {\n            negInts = append(negInts, i)\n        } else if i > 0 {\n            posInts = append(posInts, i)\n        }\n    }\n    largestNeg := 0\n    if len(negInts) > 0 {\n        largestNeg = negInts[0]\n        for _, i := range negInts {\n            if i > largestNeg {\n                largestNeg = i\n            }\n        }\n    }\n    smallestPos := 0\n    if len(posInts) > 0 {\n        smallestPos = posInts[0]\n        for _, i := range posInts {\n            if i < smallestPos {\n                smallestPos = i\n            }\n        }\n    }\n    return []int{largestNeg, smallestPos}\n}",
  "PHP_humaneval-136": "function largestSmallestIntegers(array $l): array {\n    $neg_ints = array_filter($l, function($i) { return $i < 0; });\n    $pos_ints = array_filter($l, function($i) { return $i > 0; });\n    $largest_neg = count($neg_ints) == 0 ? 0 : max($neg_ints);\n    $smallest_pos = count($pos_ints) == 0 ? 0 : min($pos_ints);\n    return [$largest_neg, $smallest_pos];\n}",
  "Ruby_humaneval-136": "def largest_smallest_integers(l)\n  neg_ints = l.select { |i| i < 0 }\n  pos_ints = l.select { |i| i > 0 }\n  largest_neg = neg_ints.empty? ? 0 : neg_ints.max\n  smallest_pos = pos_ints.empty? ? 0 : pos_ints.min\n  [largest_neg, smallest_pos]\nend",
  "Swift_humaneval-136": "func largestSmallestIntegers(_ l: [Int]) -> [Int] {\n  let negInts = l.filter { $0 < 0 }\n  let posInts = l.filter { $0 > 0 }\n  let largestNeg = negInts.max() ?? 0\n  let smallestPos = posInts.min() ?? 0\n  return [largestNeg, smallestPos]\n}",
  "TypeScript_humaneval-136": "function largestSmallestIntegers(l: number[]): number[] {\n  const negInts = l.filter((i) => i < 0);\n  const posInts = l.filter((i) => i > 0);\n  const largestNeg = negInts.length === 0 ? 0 : Math.max(...negInts);\n  const smallestPos = posInts.length === 0 ? 0 : Math.min(...posInts);\n  return [largestNeg, smallestPos];\n}",
  "Dart_humaneval-136": "List<int> largestSmallestIntegers(List<int> l) {\n  List<int> negInts = l.where((i) => i < 0).toList();\n  List<int> posInts = l.where((i) => i > 0).toList();\n  int largestNeg =\n      negInts.isEmpty ? 0 : negInts.reduce((a, b) => a > b ? a : b);\n  int smallestPos =\n      posInts.isEmpty ? 0 : posInts.reduce((a, b) => a < b ? a : b);\n  return [largestNeg, smallestPos];\n}",
  "Rust_humaneval-136": "fn largest_smallest_integers(l: Vec<i32>) -> Vec<i32> {\n    let neg_ints = l.iter().filter(|&i| i < &0).cloned().collect::<Vec<i32>>();\n    let pos_ints = l.iter().filter(|&i| i > &0).cloned().collect::<Vec<i32>>();\n    let largest_neg = neg_ints.iter().max().cloned().unwrap_or(0);\n    let smallest_pos = pos_ints.iter().min().cloned().unwrap_or(0);\n    vec![largest_neg, smallest_pos]\n}",
  "Scala_humaneval-136": "def largestSmallestIntegers(l: List[Int]): List[Int] = {\n  val negInts = l.filter(_ < 0)\n  val posInts = l.filter(_ > 0)\n  val largestNeg = if (negInts.isEmpty) 0 else negInts.max\n  val smallestPos = if (posInts.isEmpty) 0 else posInts.min\n  List(largestNeg, smallestPos)\n}",
  "Kotlin_humaneval-136": "fun largestSmallestIntegers(l: List<Int>): List<Int> {\n  val negInts = l.filter { it < 0 }\n  val posInts = l.filter { it > 0 }\n  val largestNeg = if (negInts.isEmpty()) 0 else negInts.max()!!\n  val smallestPos = if (posInts.isEmpty()) 0 else posInts.min()!!\n  return listOf(largestNeg, smallestPos)\n}",
  "C++_humaneval-138": "bool isEqualToSumEven(int n) { return n % 2 == 0 && n >= 8; }",
  "Java_humaneval-138": "public static Boolean isEqualToSumEven(Integer n) {\n  return n % 2 == 0 && n >= 8;\n}",
  "Python_humaneval-138": "def is_equal_to_sum_even(n: int) -> bool:\n    return n % 2 == 0 and n >= 8",
  "C#_humaneval-138": "public static bool IsEqualToSumEven(int n) {\n  return n % 2 == 0 && n >= 8;\n}",
  "JavaScript_humaneval-138": "function isEqualToSumEven(n) {\n  return n % 2 === 0 && n >= 8;\n}",
  "Go_humaneval-138": "func isEqualToSumEven(n int) bool {\n    return n%2 == 0 && n >= 8\n}",
  "PHP_humaneval-138": "function isEqualToSumEven(int $n): bool {\n    return $n % 2 == 0 && $n >= 8;\n}",
  "Ruby_humaneval-138": "def is_equal_to_sum_even(n)\n  n % 2 == 0 && n >= 8\nend",
  "Swift_humaneval-138": "func isEqualToSumEven(_ n: Int) -> Bool {\n  return n % 2 == 0 && n >= 8\n}",
  "TypeScript_humaneval-138": "function isEqualToSumEven(n: number): boolean {\n  return n % 2 === 0 && n >= 8;\n}",
  "Dart_humaneval-138": "bool isEqualToSumEven(int n) {\n  return n % 2 == 0 && n >= 8;\n}",
  "Rust_humaneval-138": "fn is_equal_to_sum_even(n: i32) -> bool {\n    n % 2 == 0 && n >= 8\n}",
  "Scala_humaneval-138": "def isEqualToSumEven(n: Int): Boolean = {\n  n % 2 == 0 && n >= 8\n}",
  "Kotlin_humaneval-138": "fun isEqualToSumEven(n: Int): Boolean {\n  return n % 2 == 0 && n >= 8\n}",
  "C++_humaneval-139": "int specialFactorial(int n) {\n  int fact_i = 1;\n  int special_fact = 1;\n  for (int i = 1; i <= n; i++) {\n    fact_i *= i;\n    special_fact *= fact_i;\n  }\n  return special_fact;\n}",
  "Java_humaneval-139": "public static Integer specialFactorial(Integer n) {\n  int fact_i = 1;\n  int special_fact = 1;\n  for (int i = 1; i <= n; i++) {\n    fact_i *= i;\n    special_fact *= fact_i;\n  }\n  return special_fact;\n}",
  "Python_humaneval-139": "def special_factorial(n: int) -> int:\n    fact_i = 1\n    special_fact = 1\n    for i in range(1, n + 1):\n        fact_i *= i\n        special_fact *= fact_i\n    return special_fact",
  "C#_humaneval-139": "public static int SpecialFactorial(int n) {\n  int fact_i = 1;\n  int special_fact = 1;\n  for (int i = 1; i <= n; i++) {\n    fact_i *= i;\n    special_fact *= fact_i;\n  }\n  return special_fact;\n}",
  "JavaScript_humaneval-139": "function specialFactorial(n) {\n  let fact_i = 1;\n  let special_fact = 1;\n  for (let i = 1; i <= n; i++) {\n    fact_i *= i;\n    special_fact *= fact_i;\n  }\n  return special_fact;\n}",
  "Go_humaneval-139": "func specialFactorial(n int) int {\n    factI := 1\n    specialFact := 1\n    for i := 1; i <= n; i++ {\n        factI *= i\n        specialFact *= factI\n    }\n    return specialFact\n}",
  "PHP_humaneval-139": "function specialFactorial(int $n): int {\n    $fact_i = 1;\n    $special_fact = 1;\n    for ($i = 1; $i <= $n; $i++) {\n        $fact_i *= $i;\n        $special_fact *= $fact_i;\n    }\n    return $special_fact;\n}",
  "Ruby_humaneval-139": "def special_factorial(n)\n  fact_i = 1\n  special_fact = 1\n  (1..n).each do |i|\n    fact_i *= i\n    special_fact *= fact_i\n  end\n  return special_fact\nend",
  "Swift_humaneval-139": "func specialFactorial(_ n: Int) -> Int {\n  var fact_i = 1\n  var specialFact = 1\n  for i in 1...n {\n    fact_i *= i\n    specialFact *= fact_i\n  }\n  return specialFact\n}",
  "TypeScript_humaneval-139": "function specialFactorial(n: number): number {\n  let fact_i = 1;\n  let special_fact = 1;\n  for (let i = 1; i <= n; i++) {\n    fact_i *= i;\n    special_fact *= fact_i;\n  }\n  return special_fact;\n}",
  "Dart_humaneval-139": "int specialFactorial(int n) {\n  var fact_i = 1;\n  var special_fact = 1;\n  for (var i = 1; i <= n; i++) {\n    fact_i *= i;\n    special_fact *= fact_i;\n  }\n  return special_fact;\n}",
  "Rust_humaneval-139": "fn special_factorial(n: i32) -> i32 {\n    let mut fact_i = 1;\n    let mut special_fact = 1;\n    for i in 1..=n {\n        fact_i *= i;\n        special_fact *= fact_i;\n    }\n    special_fact\n}",
  "Scala_humaneval-139": "def specialFactorial(n: Int): Int = {\n  var fact_i = 1\n  var special_fact = 1\n  for (i <- 1 to n) {\n    fact_i *= i\n    special_fact *= fact_i\n  }\n  special_fact\n}",
  "Kotlin_humaneval-139": "fun specialFactorial(n: Int): Int {\n  var factI = 1\n  var specialFact = 1\n  for (i in 1..n) {\n    factI *= i\n    specialFact *= factI\n  }\n  return specialFact\n}",
  "C++_humaneval-140": "string fixSpaces(string text) {\n  string new_text = \"\";\n  int i = 0;\n  int start = 0, end = 0;\n  while (i < text.length()) {\n    if (text[i] == ' ') {\n      end += 1;\n    } else {\n      if (end - start > 2) {\n        new_text += string(\"-\") + text[i];\n      } else if (end - start > 0) {\n        new_text += string(end - start, '_') + text[i];\n      } else {\n        new_text += text[i];\n      }\n      start = i + 1;\n      end = i + 1;\n    }\n    i += 1;\n  }\n  if (end - start > 2) {\n    new_text += \"-\";\n  } else if (end - start > 0) {\n    new_text += \"_\";\n  }\n  return new_text;\n}",
  "Java_humaneval-140": "public static String fixSpaces(String text) {\n  String new_text = \"\";\n  int i = 0;\n  int start = 0, end = 0;\n  while (i < text.length()) {\n    if (text.charAt(i) == ' ') {\n      end++;\n    } else {\n      if (end - start > 2) {\n        new_text += \"-\" + text.charAt(i);\n      } else if (end - start > 0) {\n        new_text += \"_\".repeat(end - start) + text.charAt(i);\n      } else {\n        new_text += text.charAt(i);\n      }\n      start = i + 1;\n      end = i + 1;\n    }\n    i++;\n  }\n  if (end - start > 2) {\n    new_text += \"-\";\n  } else if (end - start > 0) {\n    new_text += \"_\";\n  }\n  return new_text;\n}",
  "Python_humaneval-140": "def fix_spaces(text: str) -> str:\n    new_text = \"\"\n    i = 0\n    start, end = 0, 0\n    while i < len(text):\n        if text[i] == \" \":\n            end += 1\n        else:\n            if end - start > 2:\n                new_text += \"-\" + text[i]\n            elif end - start > 0:\n                new_text += \"_\" * (end - start) + text[i]\n            else:\n                new_text += text[i]\n            start, end = i + 1, i + 1\n        i += 1\n    if end - start > 2:\n        new_text += \"-\"\n    elif end - start > 0:\n        new_text += \"_\"\n    return new_text",
  "C#_humaneval-140": "public static string FixSpaces(string text) {\n  string new_text = \"\";\n  int i = 0;\n  int start = 0, end = 0;\n  while (i < text.Length) {\n    if (text[i] == ' ') {\n      end++;\n    } else {\n      if (end - start > 2) {\n        new_text += \"-\" + text[i];\n      } else if (end - start > 0) {\n        new_text += new string('_', end - start) + text[i];\n      } else {\n        new_text += text[i];\n      }\n      start = i + 1;\n      end = i + 1;\n    }\n    i++;\n  }\n  if (end - start > 2) {\n    new_text += \"-\";\n  } else if (end - start > 0) {\n    new_text += \"_\";\n  }\n  return new_text;\n}",
  "JavaScript_humaneval-140": "function fixSpaces(text) {\n  let new_text = \"\";\n  let i = 0;\n  let start = 0,\n    end = 0;\n  while (i < text.length) {\n    if (text[i] === \" \") {\n      end += 1;\n    } else {\n      if (end - start > 2) {\n        new_text += \"-\" + text[i];\n      } else if (end - start > 0) {\n        new_text += \"_\".repeat(end - start) + text[i];\n      } else {\n        new_text += text[i];\n      }\n      start = i + 1;\n      end = i + 1;\n    }\n    i += 1;\n  }\n  if (end - start > 2) {\n    new_text += \"-\";\n  } else if (end - start > 0) {\n    new_text += \"_\";\n  }\n  return new_text;\n}",
  "Go_humaneval-140": "func fixSpaces(text string) string {\n    var new_text string\n    var start, end int\n    for i := 0; i < len(text); i++ {\n        if text[i] == ' ' {\n            end++\n        } else {\n            if end-start > 2 {\n                new_text += \"-\" + string(text[i])\n            } else if end-start > 0 {\n                new_text += strings.Repeat(\"_\", end-start) + string(text[i])\n            } else {\n                new_text += string(text[i])\n            }\n            start, end = i+1, i+1\n        }\n    }\n    if end-start > 2 {\n        new_text += \"-\"\n    } else if end-start > 0 {\n        new_text += \"_\"\n    }\n    return new_text\n}",
  "PHP_humaneval-140": "function fixSpaces(string $text): string {\n    $new_text = \"\";\n    $i = 0;\n    $start = $end = 0;\n    while ($i < strlen($text)) {\n        if ($text[$i] == \" \") {\n            $end += 1;\n        } else {\n            if ($end - $start > 2) {\n                $new_text .= \"-\" . $text[$i];\n            } elseif ($end - $start > 0) {\n                $new_text .= str_repeat(\"_\", $end - $start) . $text[$i];\n            } else {\n                $new_text .= $text[$i];\n            }\n            $start = $end = $i + 1;\n        }\n        $i += 1;\n    }\n    if ($end - $start > 2) {\n        $new_text .= \"-\";\n    } elseif ($end - $start > 0) {\n        $new_text .= \"_\";\n    }\n    return $new_text;\n}",
  "Ruby_humaneval-140": "def fix_spaces(text)\n  new_text = \"\"\n  i = 0\n  start, ending = 0, 0\n  while i < text.length\n    if text[i] == \" \"\n      ending += 1\n    else\n      if ending - start > 2\n        new_text += \"-\" + text[i]\n      elsif ending - start > 0\n        new_text += \"_\" * (ending - start) + text[i]\n      else\n        new_text += text[i]\n      end\n      start, ending = i + 1, i + 1\n    end\n    i += 1\n  end\n  if ending - start > 2\n    new_text += \"-\"\n  elsif ending - start > 0\n    new_text += \"_\"\n  end\n  new_text\nend",
  "Swift_humaneval-140": "func fixSpaces(_ text: String) -> String {\n  var new_text = \"\"\n  var i = 0\n  var start = 0\n  var end = 0\n  while i < text.count {\n    let char = text[text.index(text.startIndex, offsetBy: i)]\n    if char == \" \" {\n      end += 1\n    } else {\n      if end - start > 2 {\n        new_text += \"-\" + String(char)\n      } else if end - start > 0 {\n        new_text += String(repeating: \"_\", count: end - start) + String(char)\n      } else {\n        new_text += String(char)\n      }\n      start = i + 1\n      end = i + 1\n    }\n    i += 1\n  }\n  if end - start > 2 {\n    new_text += \"-\"\n  } else if end - start > 0 {\n    new_text += \"_\"\n  }\n  return new_text\n}",
  "TypeScript_humaneval-140": "function fixSpaces(text: string): string {\n  let new_text = \"\";\n  let i = 0;\n  let start = 0,\n    end = 0;\n  while (i < text.length) {\n    if (text[i] == \" \") {\n      end += 1;\n    } else {\n      if (end - start > 2) {\n        new_text += \"-\" + text[i];\n      } else if (end - start > 0) {\n        new_text += \"_\".repeat(end - start) + text[i];\n      } else {\n        new_text += text[i];\n      }\n      start = i + 1;\n      end = i + 1;\n    }\n    i += 1;\n  }\n  if (end - start > 2) {\n    new_text += \"-\";\n  } else if (end - start > 0) {\n    new_text += \"_\";\n  }\n  return new_text;\n}",
  "Dart_humaneval-140": "String fixSpaces(String text) {\n  String new_text = \"\";\n  int i = 0;\n  int start = 0, end = 0;\n  while (i < text.length) {\n    if (text[i] == \" \") {\n      end += 1;\n    } else {\n      if (end - start > 2) {\n        new_text += \"-\" + text[i];\n      } else if (end - start > 0) {\n        new_text += \"_\" * (end - start) + text[i];\n      } else {\n        new_text += text[i];\n      }\n      start = i + 1;\n      end = i + 1;\n    }\n    i += 1;\n  }\n  if (end - start > 2) {\n    new_text += \"-\";\n  } else if (end - start > 0) {\n    new_text += \"_\";\n  }\n  return new_text;\n}",
  "Rust_humaneval-140": "fn fix_spaces(text: String) -> String {\n    let mut new_text = String::new();\n    let mut i = 0;\n    let mut start = 0;\n    let mut end = 0;\n    while i < text.len() {\n        if text.chars().nth(i) == Some(' ') {\n            end += 1;\n        } else {\n            if end - start > 2 {\n                new_text.push('-');\n                new_text.push(text.chars().nth(i).unwrap());\n            } else if end - start > 0 {\n                new_text.push_str(&\"_\".repeat(end - start));\n                new_text.push(text.chars().nth(i).unwrap());\n            } else {\n                new_text.push(text.chars().nth(i).unwrap());\n            }\n            start = i + 1;\n            end = i + 1;\n        }\n        i += 1;\n    }\n    if end - start > 2 {\n        new_text.push('-');\n    } else if end - start > 0 {\n        new_text.push('_');\n    }\n    new_text\n}",
  "Scala_humaneval-140": "def fixSpaces(text: String): String = {\n  var new_text = \"\"\n  var i = 0\n  var start = 0\n  var end = 0\n  while (i < text.length) {\n    if (text(i) == ' ') {\n      end += 1\n    } else {\n      if (end - start > 2) {\n        new_text += \"-\" + text(i)\n      } else if (end - start > 0) {\n        new_text += \"_\" * (end - start) + text(i)\n      } else {\n        new_text += text(i)\n      }\n      start = i + 1\n      end = i + 1\n    }\n    i += 1\n  }\n  if (end - start > 2) {\n    new_text += \"-\"\n  } else if (end - start > 0) {\n    new_text += \"_\"\n  }\n  new_text\n}",
  "Kotlin_humaneval-140": "fun fixSpaces(text: String): String {\n  var new_text = \"\"\n  var i = 0\n  var start = 0\n  var end = 0\n  while (i < text.length) {\n    if (text[i] == ' ') {\n      end += 1\n    } else {\n      if (end - start > 2) {\n        new_text += \"-\" + text[i]\n      } else if (end - start > 0) {\n        new_text += \"_\".repeat(end - start) + text[i]\n      } else {\n        new_text += text[i]\n      }\n      start = i + 1\n      end = i + 1\n    }\n    i += 1\n  }\n  if (end - start > 2) {\n    new_text += \"-\"\n  } else if (end - start > 0) {\n    new_text += \"_\"\n  }\n  return new_text\n}",
  "C++_humaneval-141": "string fileNameCheck(string file_name) {\n  vector<string> suf = {\"txt\", \"exe\", \"dll\"};\n  vector<string> lst;\n  stringstream ss(file_name);\n  string token;\n  while (getline(ss, token, '.')) {\n    lst.push_back(token);\n  }\n  if (lst.size() != 2) {\n    return \"No\";\n  }\n  if (find(suf.begin(), suf.end(), lst[1]) == suf.end()) {\n    return \"No\";\n  }\n  if (lst[0].length() == 0) {\n    return \"No\";\n  }\n  if (!isalpha(lst[0][0])) {\n    return \"No\";\n  }\n  int t =\n      count_if(lst[0].begin(), lst[0].end(), [](char c) { return isdigit(c); });\n  if (t > 3) {\n    return \"No\";\n  }\n  return \"Yes\";\n}",
  "Java_humaneval-141": "public static String fileNameCheck(String fileName) {\n  String[] suf = {\"txt\", \"exe\", \"dll\"};\n  String[] lst = fileName.split(\"\\\\.\");\n  if (lst.length != 2) {\n    return \"No\";\n  }\n  if (!Arrays.asList(suf).contains(lst[1])) {\n    return \"No\";\n  }\n  if (lst[0].length() == 0) {\n    return \"No\";\n  }\n  if (!Character.isLetter(lst[0].charAt(0))) {\n    return \"No\";\n  }\n  int t = 0;\n  for (char c : lst[0].toCharArray()) {\n    if (Character.isDigit(c)) {\n      t++;\n    }\n  }\n  if (t > 3) {\n    return \"No\";\n  }\n  return \"Yes\";\n}",
  "Python_humaneval-141": "def file_name_check(file_name: str) -> str:\n    suf = [\"txt\", \"exe\", \"dll\"]\n    lst = file_name.split(sep=\".\")\n    if len(lst) != 2:\n        return \"No\"\n    if not lst[1] in suf:\n        return \"No\"\n    if len(lst[0]) == 0:\n        return \"No\"\n    if not lst[0][0].isalpha():\n        return \"No\"\n    t = len([x for x in lst[0] if x.isdigit()])\n    if t > 3:\n        return \"No\"\n    return \"Yes\"",
  "C#_humaneval-141": "public static string FileNameCheck(string fileName) {\n  string[] suf = { \"txt\", \"exe\", \"dll\" };\n  string[] lst = fileName.Split('.');\n  if (lst.Length != 2) {\n    return \"No\";\n  }\n  if (!suf.Contains(lst[1])) {\n    return \"No\";\n  }\n  if (lst[0].Length == 0) {\n    return \"No\";\n  }\n  if (!char.IsLetter(lst[0][0])) {\n    return \"No\";\n  }\n  int t = lst[0].Count(char.IsDigit);\n  if (t > 3) {\n    return \"No\";\n  }\n  return \"Yes\";\n}",
  "JavaScript_humaneval-141": "function fileNameCheck(fileName) {\n  const suf = [\"txt\", \"exe\", \"dll\"];\n  const lst = fileName.split(\".\");\n  if (lst.length !== 2) {\n    return \"No\";\n  }\n  if (!suf.includes(lst[1])) {\n    return \"No\";\n  }\n  if (lst[0].length === 0) {\n    return \"No\";\n  }\n  if (!lst[0][0].match(/[a-z]/i)) {\n    return \"No\";\n  }\n  const t = (lst[0].match(/\\d/g) || []).length;\n  if (t > 3) {\n    return \"No\";\n  }\n  return \"Yes\";\n}",
  "Go_humaneval-141": "func fileNameCheck(fileName string) string {\n    suf := []string{\"txt\", \"exe\", \"dll\"}\n    lst := strings.Split(fileName, \".\")\n    if len(lst) != 2 {\n        return \"No\"\n    }\n    if !contains(suf, lst[1]) {\n        return \"No\"\n    }\n    if len(lst[0]) == 0 {\n        return \"No\"\n    }\n    if !unicode.IsLetter(rune(lst[0][0])) {\n        return \"No\"\n    }\n    t := 0\n    for _, c := range lst[0] {\n        if unicode.IsDigit(c) {\n            t++\n        }\n    }\n    if t > 3 {\n        return \"No\"\n    }\n    return \"Yes\"\n}\nfunc contains(s []string, e string) bool {\n    for _, a := range s {\n        if a == e {\n            return true\n        }\n    }\n    return false\n}",
  "PHP_humaneval-141": "function fileNameCheck(string $fileName): string {\n    $suf = [\"txt\", \"exe\", \"dll\"];\n    $lst = explode(\".\", $fileName);\n    if (count($lst) != 2) {\n        return \"No\";\n    }\n    if (!in_array($lst[1], $suf)) {\n        return \"No\";\n    }\n    if (strlen($lst[0]) == 0) {\n        return \"No\";\n    }\n    if (!ctype_alpha($lst[0][0])) {\n        return \"No\";\n    }\n    $t = preg_match_all('/\\d/', $lst[0]);\n    if ($t > 3) {\n        return \"No\";\n    }\n    return \"Yes\";\n}",
  "Ruby_humaneval-141": "def file_name_check(file_name)\n  suf = %w[txt exe dll]\n  lst = file_name.split(\".\")\n  return \"No\" if lst.length != 2\n  return \"No\" unless suf.include?(lst[1])\n  return \"No\" if lst[0].empty?\n  return \"No\" unless lst[0][0].match?(/[a-zA-Z]/)\n  t = lst[0].count(\"0-9\")\n  return \"No\" if t > 3\n  \"Yes\"\nend",
  "Swift_humaneval-141": "func fileNameCheck(_ fileName: String) -> String {\n  let suf = [\"txt\", \"exe\", \"dll\"]\n  let lst = fileName.split(separator: \".\")\n  if lst.count != 2 {\n    return \"No\"\n  }\n  if !suf.contains(String(lst[1])) {\n    return \"No\"\n  }\n  if lst[0].isEmpty {\n    return \"No\"\n  }\n  if !lst[0].first!.isLetter {\n    return \"No\"\n  }\n  let t = lst[0].filter({ $0.isNumber }).count\n  if t > 3 {\n    return \"No\"\n  }\n  return \"Yes\"\n}",
  "TypeScript_humaneval-141": "function fileNameCheck(fileName: string): string {\n  const suf: string[] = [\"txt\", \"exe\", \"dll\"];\n  const lst: string[] = fileName.split(\".\");\n  if (lst.length !== 2) {\n    return \"No\";\n  }\n  if (!suf.includes(lst[1])) {\n    return \"No\";\n  }\n  if (lst[0].length === 0) {\n    return \"No\";\n  }\n  if (!lst[0][0].match(/[a-zA-Z]/)) {\n    return \"No\";\n  }\n  const t: number = lst[0].split(\"\").filter((x) => x.match(/\\d/)).length;\n  if (t > 3) {\n    return \"No\";\n  }\n  return \"Yes\";\n}",
  "Dart_humaneval-141": "String fileNameCheck(String fileName) {\n  List<String> suf = [\"txt\", \"exe\", \"dll\"];\n  List<String> lst = fileName.split(\".\");\n  if (lst.length != 2) {\n    return \"No\";\n  }\n  if (!suf.contains(lst[1])) {\n    return \"No\";\n  }\n  if (lst[0].isEmpty) {\n    return \"No\";\n  }\n  if (!lst[0][0].contains(RegExp('[a-zA-Z]'))) {\n    return \"No\";\n  }\n  int t = lst[0].split(\"\").where((x) => x.contains(RegExp('[0-9]'))).length;\n  if (t > 3) {\n    return \"No\";\n  }\n  return \"Yes\";\n}",
  "Rust_humaneval-141": "fn file_name_check(file_name: String) -> String {\n    let suf = vec![\"txt\", \"exe\", \"dll\"];\n    let lst: Vec<&str> = file_name.split(\".\").collect();\n    if lst.len() != 2 {\n        return \"No\".to_string();\n    }\n    if !suf.contains(&lst[1]) {\n        return \"No\".to_string();\n    }\n    if lst[0].is_empty() {\n        return \"No\".to_string();\n    }\n    if !lst[0].chars().next().unwrap().is_alphabetic() {\n        return \"No\".to_string();\n    }\n    let t = lst[0].chars().filter(|c| c.is_numeric()).count();\n    if t > 3 {\n        return \"No\".to_string();\n    }\n    \"Yes\".to_string()\n}",
  "Scala_humaneval-141": "def fileNameCheck(fileName: String): String = {\n  val suf = List(\"txt\", \"exe\", \"dll\")\n  val lst = fileName.split(\"\\\\.\")\n  if (lst.length != 2) {\n    return \"No\"\n  }\n  if (!suf.contains(lst(1))) {\n    return \"No\"\n  }\n  if (lst(0).isEmpty || !lst(0)(0).isLetter) {\n    return \"No\"\n  }\n  val t = lst(0).count(_.isDigit)\n  if (t > 3) {\n    return \"No\"\n  }\n  \"Yes\"\n}",
  "Kotlin_humaneval-141": "fun fileNameCheck(fileName: String): String {\n  val suf = listOf(\"txt\", \"exe\", \"dll\")\n  val lst = fileName.split(\".\")\n  if (lst.size != 2) {\n    return \"No\"\n  }\n  if (!suf.contains(lst[1])) {\n    return \"No\"\n  }\n  if (lst[0].isEmpty()) {\n    return \"No\"\n  }\n  if (!lst[0][0].isLetter()) {\n    return \"No\"\n  }\n  val t = lst[0].count { it.isDigit() }\n  if (t > 3) {\n    return \"No\"\n  }\n  return \"Yes\"\n}",
  "C++_humaneval-142": "int sumSquares(vector<int> l) {\n  int result = 0;\n  for (int i = 0; i < l.size(); i++) {\n    if (i % 3 == 0) {\n      result += pow(l[i], 2);\n    } else if (i % 4 == 0) {\n      result += pow(l[i], 3);\n    } else {\n      result += l[i];\n    }\n  }\n  return result;\n}",
  "Java_humaneval-142": "public static Integer sumSquares(List<Integer> l) {\n  int result = 0;\n  for (int i = 0; i < l.size(); i++) {\n    if (i % 3 == 0) {\n      result += Math.pow(l.get(i), 2);\n    } else if (i % 4 == 0) {\n      result += Math.pow(l.get(i), 3);\n    } else {\n      result += l.get(i);\n    }\n  }\n  return result;\n}",
  "Python_humaneval-142": "def sum_squares(l: List[int]) -> int:\n    result = 0\n    for i in range(len(l)):\n        if i % 3 == 0:\n            result += l[i] ** 2\n        elif i % 4 == 0:\n            result += l[i] ** 3\n        else:\n            result += l[i]\n    return result",
  "C#_humaneval-142": "public static int SumSquares(List<int> l) {\n  int result = 0;\n  for (int i = 0; i < l.Count; i++) {\n    if (i % 3 == 0) {\n      result += (int)Math.Pow(l[i], 2);\n    } else if (i % 4 == 0) {\n      result += (int)Math.Pow(l[i], 3);\n    } else {\n      result += l[i];\n    }\n  }\n  return result;\n}",
  "JavaScript_humaneval-142": "function sumSquares(l) {\n  let result = 0;\n  for (let i = 0; i < l.length; i++) {\n    if (i % 3 === 0) {\n      result += l[i] ** 2;\n    } else if (i % 4 === 0) {\n      result += l[i] ** 3;\n    } else {\n      result += l[i];\n    }\n  }\n  return result;\n}",
  "Go_humaneval-142": "func sumSquares(l []int) int {\n    result := 0\n    for i := 0; i < len(l); i++ {\n        if i%3 == 0 {\n            result += l[i] * l[i]\n        } else if i%4 == 0 {\n            result += l[i] * l[i] * l[i]\n        } else {\n            result += l[i]\n        }\n    }\n    return result\n}",
  "PHP_humaneval-142": "function sumSquares(array $l): int {\n    $result = 0;\n    for ($i = 0; $i < count($l); $i++) {\n        if ($i % 3 == 0) {\n            $result += $l[$i] ** 2;\n        } elseif ($i % 4 == 0) {\n            $result += $l[$i] ** 3;\n        } else {\n            $result += $l[$i];\n        }\n    }\n    return $result;\n}",
  "Ruby_humaneval-142": "def sum_squares(l)\n  result = 0\n  l.each_with_index do |val, i|\n    if i % 3 == 0\n      result += val**2\n    elsif i % 4 == 0\n      result += val**3\n    else\n      result += val\n    end\n  end\n  result\nend",
  "Swift_humaneval-142": "func sumSquares(_ l: [Int]) -> Int {\n  var result = 0\n  for i in 0..<l.count {\n    if i % 3 == 0 {\n      result += l[i] * l[i]\n    } else if i % 4 == 0 {\n      result += l[i] * l[i] * l[i]\n    } else {\n      result += l[i]\n    }\n  }\n  return result\n}",
  "TypeScript_humaneval-142": "function sumSquares(l: number[]): number {\n  let result = 0;\n  for (let i = 0; i < l.length; i++) {\n    if (i % 3 === 0) {\n      result += l[i] ** 2;\n    } else if (i % 4 === 0) {\n      result += l[i] ** 3;\n    } else {\n      result += l[i];\n    }\n  }\n  return result;\n}",
  "Dart_humaneval-142": "int sumSquares(List<int> l) {\n  int result = 0;\n  for (int i = 0; i < l.length; i++) {\n    if (i % 3 == 0) {\n      result += l[i] * l[i];\n    } else if (i % 4 == 0) {\n      result += l[i] * l[i] * l[i];\n    } else {\n      result += l[i];\n    }\n  }\n  return result;\n}",
  "Rust_humaneval-142": "fn sum_squares(l: Vec<i32>) -> i32 {\n    let mut result = 0;\n    for i in 0..l.len() {\n        if i % 3 == 0 {\n            result += l[i].pow(2);\n        } else if i % 4 == 0 {\n            result += l[i].pow(3);\n        } else {\n            result += l[i];\n        }\n    }\n    result\n}",
  "Scala_humaneval-142": "def sumSquares(l: List[Int]): Int = {\n  var result = 0\n  for ((elem, i) <- l.zipWithIndex) {\n    if (i % 3 == 0) {\n      result += elem * elem\n    } else if (i % 4 == 0) {\n      result += elem * elem * elem\n    } else {\n      result += elem\n    }\n  }\n  result\n}",
  "Kotlin_humaneval-142": "fun sumSquares(l: List<Int>): Int {\n  var result = 0\n  for (i in l.indices) {\n    when {\n      i % 3 == 0 -> result += l[i] * l[i]\n      i % 4 == 0 -> result += l[i] * l[i] * l[i]\n      else -> result += l[i]\n    }\n  }\n  return result\n}",
  "C++_humaneval-143": "bool isPrime(int n) {\n  if (n < 2) {\n    return false;\n  }\n  for (int i = 2; i <= sqrt(n); i++) {\n    if (n % i == 0) {\n      return false;\n    }\n  }\n  return true;\n}\nstring wordsInSentence(string sentence) {\n  vector<string> words;\n  stringstream ss(sentence);\n  string word;\n  while (ss >> word) {\n    words.push_back(word);\n  }\n  vector<string> prime_words;\n  for (auto word : words) {\n    if (is_prime(word.length())) {\n      prime_words.push_back(word);\n    }\n  }\n  string result = \"\";\n  for (auto word : prime_words) {\n    result += word + \" \";\n  }\n  return result.substr(0, result.length() - 1);\n}",
  "Java_humaneval-143": "public static boolean isPrime(int n) {\n  if (n < 2) {\n    return false;\n  }\n  for (int i = 2; i <= Math.sqrt(n); i++) {\n    if (n % i == 0) {\n      return false;\n    }\n  }\n  return true;\n}\npublic static String wordsInSentence(String sentence) {\n  String[] words = sentence.split(\" \");\n  List<String> primeWords = new ArrayList<>();\n  for (String word : words) {\n    if (isPrime(word.length())) {\n      primeWords.add(word);\n    }\n  }\n  return String.join(\" \", primeWords);\n}",
  "Python_humaneval-143": "def is_prime(n):\n    if n < 2:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\ndef words_in_sentence(sentence: str) -> str:\n    words = sentence.split()\n    prime_words = []\n    for word in words:\n        if is_prime(len(word)):\n            prime_words.append(word)\n    return \" \".join(prime_words)",
  "C#_humaneval-143": "public static bool IsPrime(int n) {\n  if (n < 2) {\n    return false;\n  }\n  for (int i = 2; i <= (int)Math.Sqrt(n); i++) {\n    if (n % i == 0) {\n      return false;\n    }\n  }\n  return true;\n}\npublic static string WordsInSentence(string sentence) {\n  string[] words = sentence.Split();\n  List<string> primeWords = new List<string>();\n  foreach (string word in words) {\n    if (IsPrime(word.Length)) {\n      primeWords.Add(word);\n    }\n  }\n  return string.Join(\" \", primeWords);\n}",
  "JavaScript_humaneval-143": "function isPrime(n) {\n  if (n < 2) {\n    return false;\n  }\n  for (let i = 2; i <= Math.sqrt(n); i++) {\n    if (n % i === 0) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction wordsInSentence(sentence) {\n  const words = sentence.split(\" \");\n  const primeWords = [];\n  for (let i = 0; i < words.length; i++) {\n    if (isPrime(words[i].length)) {\n      primeWords.push(words[i]);\n    }\n  }\n  return primeWords.join(\" \");\n}",
  "Go_humaneval-143": "func isPrime(n int) bool {\n    if n < 2 {\n        return false\n    }\n    for i := 2; i <= int(math.Sqrt(float64(n))); i++ {\n        if n%i == 0 {\n            return false\n        }\n    }\n    return true\n}\nfunc wordsInSentence(sentence string) string {\n    words := strings.Split(sentence, \" \")\n    var primeWords []string\n    for _, word := range words {\n        if isPrime(len(word)) {\n            primeWords = append(primeWords, word)\n        }\n    }\n    return strings.Join(primeWords, \" \")\n}",
  "PHP_humaneval-143": "function is_prime($n) {\n    if ($n < 2) {\n        return false;\n    }\n    for ($i = 2; $i <= sqrt($n); $i++) {\n        if ($n % $i == 0) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction wordsInSentence(string $sentence): string {\n    $words = explode(\" \", $sentence);\n    $prime_words = [];\n    foreach ($words as $word) {\n        if (is_prime(strlen($word))) {\n            $prime_words[] = $word;\n        }\n    }\n    return implode(\" \", $prime_words);\n}",
  "Ruby_humaneval-143": "def is_prime(n)\n  return false if n < 2\n  (2..Math.sqrt(n)).each { |i| return false if n % i == 0 }\n  true\nend\ndef words_in_sentence(sentence)\n  words = sentence.split\n  prime_words = []\n  words.each { |word| prime_words << word if is_prime(word.length) }\n  prime_words.join(\" \")\nend",
  "Swift_humaneval-143": "func isPrime(_ n: Int) -> Bool {\n  if n < 2 {\n    return false\n  }\n  for i in 2..<Int(1 + sqrt(Double(n))) {\n    if n % i == 0 {\n      return false\n    }\n  }\n  return true\n}\nfunc wordsInSentence(_ sentence: String) -> String {\n  let words = sentence.split(separator: \" \")\n  var primeWords = [String]()\n  for word in words {\n    if isPrime(word.count) {\n      primeWords.append(String(word))\n    }\n  }\n  return primeWords.joined(separator: \" \")\n}",
  "TypeScript_humaneval-143": "function isPrime(n: number): boolean {\n  if (n < 2) {\n    return false;\n  }\n  for (let i = 2; i <= Math.sqrt(n); i++) {\n    if (n % i === 0) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction wordsInSentence(sentence: string): string {\n  const words = sentence.split(\" \");\n  const primeWords = [];\n  for (const word of words) {\n    if (isPrime(word.length)) {\n      primeWords.push(word);\n    }\n  }\n  return primeWords.join(\" \");\n}",
  "Dart_humaneval-143": "bool isPrime(int n) {\n  if (n < 2) {\n    return false;\n  }\n  for (int i = 2; i <= sqrt(n); i++) {\n    if (n % i == 0) {\n      return false;\n    }\n  }\n  return true;\n}\nString wordsInSentence(String sentence) {\n  List<String> words = sentence.split(\" \");\n  List<String> primeWords = [];\n  for (String word in words) {\n    if (isPrime(word.length)) {\n      primeWords.add(word);\n    }\n  }\n  return primeWords.join(\" \");\n}",
  "Rust_humaneval-143": "fn is_prime(n: usize) -> bool {\n    if n < 2 {\n        return false;\n    }\n    for i in 2..=(n as f64).sqrt() as usize {\n        if n % i == 0 {\n            return false;\n        }\n    }\n    true\n}\nfn words_in_sentence(sentence: String) -> String {\n    let words: Vec<&str> = sentence.split_whitespace().collect();\n    let mut prime_words = Vec::new();\n    for word in words {\n        if is_prime(word.len()) {\n            prime_words.push(word);\n        }\n    }\n    prime_words.join(\" \")\n}",
  "Scala_humaneval-143": "def isPrime(n: Int): Boolean = {\n  if (n < 2) {\n    false\n  } else {\n    (2 to sqrt(n).toInt).forall(i => n % i != 0)\n  }\n}\ndef wordsInSentence(sentence: String): String = {\n  val words = sentence.split(\" \")\n  val primeWords = words.filter(word => isPrime(word.length))\n  primeWords.mkString(\" \")\n}",
  "Kotlin_humaneval-143": "fun isPrime(n: Int): Boolean {\n  if (n < 2) {\n    return false\n  }\n  for (i in 2..(n.toDouble().pow(0.5)).toInt()) {\n    if (n % i == 0) {\n      return false\n    }\n  }\n  return true\n}\nfun wordsInSentence(sentence: String): String {\n  val words = sentence.split(\" \")\n  val primeWords = mutableListOf<String>()\n  for (word in words) {\n    if (isPrime(word.length)) {\n      primeWords.add(word)\n    }\n  }\n  return primeWords.joinToString(\" \")\n}",
  "C++_humaneval-144": "bool simplify(string x, string n) {\n  string a, b, c, d;\n  int numerator, denom;\n  size_t pos = x.find(\"/\");\n  a = x.substr(0, pos);\n  b = x.substr(pos + 1);\n  pos = n.find(\"/\");\n  c = n.substr(0, pos);\n  d = n.substr(pos + 1);\n  numerator = stoi(a) * stoi(c);\n  denom = stoi(b) * stoi(d);\n  if (numerator / denom == numerator / (double)denom) {\n    return true;\n  }\n  return false;\n}",
  "Java_humaneval-144": "public static Boolean simplify(String x, String n) {\n  String[] parts1 = x.split(\"/\");\n  String[] parts2 = n.split(\"/\");\n  int a = Integer.parseInt(parts1[0]);\n  int b = Integer.parseInt(parts1[1]);\n  int c = Integer.parseInt(parts2[0]);\n  int d = Integer.parseInt(parts2[1]);\n  int numerator = a * c;\n  int denom = b * d;\n  if (numerator / denom == numerator / (double) denom) {\n    return true;\n  }\n  return false;\n}",
  "Python_humaneval-144": "def simplify(x: str, n: str) -> bool:\n    a, b = x.split(\"/\")\n    c, d = n.split(\"/\")\n    numerator = int(a) * int(c)\n    denom = int(b) * int(d)\n    if numerator / denom == int(numerator / denom):\n        return True\n    return False",
  "C#_humaneval-144": "public static bool Simplify(string x, string n) {\n  string[] partsX = x.Split('/');\n  string[] partsN = n.Split('/');\n  int a = int.Parse(partsX[0]);\n  int b = int.Parse(partsX[1]);\n  int c = int.Parse(partsN[0]);\n  int d = int.Parse(partsN[1]);\n  int numerator = a * c;\n  int denom = b * d;\n  if (numerator / denom == numerator / (double)denom) {\n    return true;\n  }\n  return false;\n}",
  "JavaScript_humaneval-144": "function simplify(x, n) {\n  let [a, b] = x.split(\"/\");\n  let [c, d] = n.split(\"/\");\n  let numerator = parseInt(a) * parseInt(c);\n  let denom = parseInt(b) * parseInt(d);\n  if (numerator / denom == parseInt(numerator / denom)) {\n    return true;\n  }\n  return false;\n}",
  "Go_humaneval-144": "func simplify(x string, n string) bool {\n    a := strings.Split(x, \"/\")\n    b := strings.Split(n, \"/\")\n    numerator, _ := strconv.Atoi(a[0])\n    denom, _ := strconv.Atoi(a[1])\n    c, _ := strconv.Atoi(b[0])\n    d, _ := strconv.Atoi(b[1])\n    numerator *= c\n    denom *= d\n    if float64(numerator)/float64(denom) == float64(int(numerator/denom)) {\n        return true\n    }\n    return false\n}",
  "PHP_humaneval-144": "function simplify(string $x, string $n): bool {\n    list($a, $b) = explode(\"/\", $x);\n    list($c, $d) = explode(\"/\", $n);\n    $numerator = (int)$a * (int)$c;\n    $denom = (int)$b * (int)$d;\n    if ($numerator / $denom == (int)($numerator / $denom)) {\n        return true;\n    }\n    return false;\n}",
  "Ruby_humaneval-144": "def simplify(x, n)\n  a, b = x.split(\"/\")\n  c, d = n.split(\"/\")\n  numerator = a.to_i * c.to_i\n  denom = b.to_i * d.to_i\n  return true if numerator / denom == numerator.to_f / denom\n  return false\nend",
  "Swift_humaneval-144": "func simplify(_ x: String, _ n: String) -> Bool {\n  let arr1 = x.split(separator: \"/\").map { Int($0)! }\n  let arr2 = n.split(separator: \"/\").map { Int($0)! }\n  let numerator = arr1[0] * arr2[0]\n  let denom = arr1[1] * arr2[1]\n  if Double(numerator) / Double(denom) == Double(Int(numerator / denom)) {\n    return true\n  }\n  return false\n}",
  "TypeScript_humaneval-144": "function simplify(x: string, n: string): boolean {\n  const [a, b] = x.split(\"/\");\n  const [c, d] = n.split(\"/\");\n  const numerator = parseInt(a) * parseInt(c);\n  const denom = parseInt(b) * parseInt(d);\n  if (numerator / denom === parseInt(String(numerator / denom))) {\n    return true;\n  }\n  return false;\n}",
  "Dart_humaneval-144": "bool simplify(String x, String n) {\n  var partsX = x.split(\"/\");\n  var partsN = n.split(\"/\");\n  var a = int.parse(partsX[0]);\n  var b = int.parse(partsX[1]);\n  var c = int.parse(partsN[0]);\n  var d = int.parse(partsN[1]);\n  var numerator = a * c;\n  var denom = b * d;\n  if (numerator / denom == numerator ~/ denom) {\n    return true;\n  }\n  return false;\n}",
  "Rust_humaneval-144": "fn simplify(x: String, n: String) -> bool {\n    let parts1: Vec<&str> = x.split('/').collect();\n    let parts2: Vec<&str> = n.split('/').collect();\n    let a = parts1[0].parse::<i32>().unwrap();\n    let b = parts1[1].parse::<i32>().unwrap();\n    let c = parts2[0].parse::<i32>().unwrap();\n    let d = parts2[1].parse::<i32>().unwrap();\n    let numerator = a * c;\n    let denom = b * d;\n    if numerator as f64 / denom as f64 == (numerator / denom) as f64 {\n        return true;\n    }\n    false\n}",
  "Scala_humaneval-144": "def simplify(x: String, n: String): Boolean = {\n  val Array(a, b) = x.split(\"/\")\n  val Array(c, d) = n.split(\"/\")\n  val numerator = a.toInt * c.toInt\n  val denom = b.toInt * d.toInt\n  if (numerator.toDouble / denom == numerator / denom) {\n    true\n  } else {\n    false\n  }\n}",
  "Kotlin_humaneval-144": "fun simplify(x: String, n: String): Boolean {\n  val (a, b) = x.split(\"/\")\n  val (c, d) = n.split(\"/\")\n  val numerator = a.toInt() * c.toInt()\n  val denom = b.toInt() * d.toInt()\n  return numerator % denom == 0\n}",
  "C++_humaneval-145": "int digitsSum(int n) {\n  int neg = 1;\n  if (n < 0) {\n    n = -1 * n;\n    neg = -1;\n  }\n  string str_n = to_string(n);\n  vector<int> digits;\n  for (char c : str_n) {\n    digits.push_back(c - '0');\n  }\n  digits[0] = digits[0] * neg;\n  return accumulate(digits.begin(), digits.end(), 0);\n}\nvector<int> orderByPoints(vector<int> nums) {\n  sort(nums.begin(), nums.end(),\n       [](int a, int b) { return digitsSum(a) < digitsSum(b); });\n  return nums;\n}",
  "Java_humaneval-145": "public static int digitsSum(int n) {\n  int neg = 1;\n  if (n < 0) {\n    n = -1 * n;\n    neg = -1;\n  }\n  List<Integer> digits =\n      String.valueOf(n).chars().mapToObj(c -> c - '0').collect(Collectors.toList());\n  digits.set(0, digits.get(0) * neg);\n  int sum = 0;\n  for (int digit : digits) {\n    sum += digit;\n  }\n  return sum;\n}\npublic static List<Integer> orderByPoints(List<Integer> nums) {\n  List<Integer> nums1 = new ArrayList<>(nums);\n  Collections.sort(nums1, Comparator.comparingInt(i -> digitsSum(i)));\n  return nums1;\n}",
  "Python_humaneval-145": "def digits_sum(n):\n    neg = 1\n    if n < 0:\n        n, neg = -1 * n, -1\n    n = [int(i) for i in str(n)]\n    n[0] = n[0] * neg\n    return sum(n)\ndef order_by_points(nums: List[int]) -> List[int]:\n    return sorted(nums, key=digits_sum)",
  "C#_humaneval-145": "public static int DigitsSum(int n) {\n  int neg = 1;\n  if (n < 0) {\n    n = -1 * n;\n    neg = -1;\n  }\n  List<int> digits = n.ToString().Select(c => c - '0').ToList();\n  digits[0] *= neg;\n  return digits.Sum();\n}\npublic static List<int> OrderByPoints(List<int> nums) {\n  return nums.OrderBy(n => DigitsSum(n)).ToList();\n}",
  "JavaScript_humaneval-145": "function digitsSum(n) {\n  let neg = 1;\n  if (n < 0) {\n    n = -1 * n;\n    neg = -1;\n  }\n  n = Array.from(String(n), Number);\n  n[0] = n[0] * neg;\n  return n.reduce((a, b) => a + b, 0);\n}\nfunction orderByPoints(nums) {\n  return nums.sort((a, b) => digitsSum(a) - digitsSum(b));\n}",
  "Go_humaneval-145": "func digitsSum(n int) int {\n    neg := 1\n    if n < 0 {\n        n, neg = -1*n, -1\n    }\n    digits := []int{}\n    for _, c := range strconv.Itoa(n) {\n        digits = append(digits, int(c-'0'))\n    }\n    if neg == -1 {\n        digits[0] *= -1\n    }\n    sum := 0\n    for _, digit := range digits {\n        sum += digit\n    }\n    return sum\n}\nfunc orderByPoints(nums []int) []int {\n    sort.Slice(nums, func(i, j int) bool {\n        return digitsSum(nums[i]) < digitsSum(nums[j])\n    })\n    return nums\n}",
  "PHP_humaneval-145": "function digits_sum($n) {\n    $neg = 1;\n    if ($n < 0) {\n        $n = -1 * $n;\n        $neg = -1;\n    }\n    $n = array_map('intval', str_split($n));\n    $n[0] = $n[0] * $neg;\n    return array_sum($n);\n}\nfunction orderByPoints(array $nums): array {\n    usort($nums, function($a, $b) {\n        return digits_sum($a) - digits_sum($b);\n    });\n    return $nums;\n}",
  "Ruby_humaneval-145": "def digits_sum(n)\n  neg = 1\n  n, neg = -1 * n, -1 if n < 0\n  n = n.to_s.chars.map(&:to_i)\n  n[0] = n[0] * neg\n  return n.sum\nend\ndef order_by_points(nums)\n  nums.sort_by { |n| digits_sum(n) }\nend",
  "Swift_humaneval-145": "func digitsSum(_ n: Int) -> Int {\n  var neg = 1\n  var num = n\n  if n < 0 {\n    num = -1 * n\n    neg = -1\n  }\n  var digits = String(num).compactMap { Int(String($0)) }\n  digits[0] = digits[0] * neg\n  return digits.reduce(0, +)\n}\nfunc orderByPoints(_ nums: [Int]) -> [Int] {\n  return nums.sorted { digitsSum($0) < digitsSum($1) }\n}",
  "TypeScript_humaneval-145": "function digitsSum(n: number): number {\n  let neg = 1;\n  if (n < 0) {\n    n = -1 * n;\n    neg = -1;\n  }\n  const digits = Array.from(String(n), Number);\n  digits[0] = digits[0] * neg;\n  return digits.reduce((acc, curr) => acc + curr, 0);\n}\nfunction orderByPoints(nums: number[]): number[] {\n  return nums.sort((a, b) => digitsSum(a) - digitsSum(b));\n}",
  "Dart_humaneval-145": "List<int> orderByPoints(List<int> nums) {\n  int digitsSum(int n) {\n    int neg = 1;\n    if (n < 0) {\n      n = -1 * n;\n      neg = -1;\n    }\n    List<int> nList = n.toString().split('').map(int.parse).toList();\n    nList[0] = nList[0] * neg;\n    return nList.reduce((a, b) => a + b);\n  }\n  return nums..sort((a, b) => digitsSum(a).compareTo(digitsSum(b)));\n}",
  "Rust_humaneval-145": "fn digits_sum(mut n: i32) -> i32 {\n    let mut neg = 1;\n    if n < 0 {\n        n = -1 * n;\n        neg = -1;\n    }\n    let mut digits: Vec<i32> = n\n        .to_string()\n        .chars()\n        .map(|c| c as i32 - '0' as i32)\n        .collect();\n    digits[0] *= neg;\n    digits.iter().sum()\n}\nfn order_by_points(nums: Vec<i32>) -> Vec<i32> {\n    let mut nums = nums;\n    nums.sort_by_key(|&num| digits_sum(num));\n    nums\n}",
  "Scala_humaneval-145": "def digitsSum(n: Int): Int = {\n  val neg = if (n < 0) -1 else 1\n  val digits = n.abs.toString.map(_.asDigit).toList\n  digits.headOption match {\n    case Some(d) => (d * neg) + digits.tail.sum\n    case None    => 0\n  }\n}\ndef orderByPoints(nums: List[Int]): List[Int] = {\n  nums.sortBy(digitsSum)\n}",
  "Kotlin_humaneval-145": "fun digitsSum(n: Int): Int {\n  var neg = 1\n  var num = n\n  if (num < 0) {\n    num *= -1\n    neg = -1\n  }\n  val digits = num.toString().map { it.toString().toInt() }.toMutableList()\n  digits[0] *= neg\n  return digits.sum()\n}\nfun orderByPoints(nums: List<Int>): List<Int> {\n  return nums.sortedBy { digitsSum(it) }\n}",
  "C++_humaneval-146": "int specialFilter(vector<int> nums) {\n  int count = 0;\n  for (int num : nums) {\n    if (num > 10 &&\n        string(1, to_string(num)[0]).find_first_of(\"13579\") != string::npos &&\n        string(1, to_string(num)[to_string(num).length() - 1])\n                .find_first_of(\"13579\") != string::npos) {\n      count += 1;\n    }\n  }\n  return count;\n}",
  "Java_humaneval-146": "public static Integer specialFilter(List<Integer> nums) {\n  int count = 0;\n  for (int num : nums) {\n    if (num > 10 && List.of(\"1\", \"3\", \"5\", \"7\", \"9\").contains(String.valueOf(num).substring(0, 1))\n        && List.of(\"1\", \"3\", \"5\", \"7\", \"9\")\n               .contains(String.valueOf(num).substring(String.valueOf(num).length() - 1))) {\n      count++;\n    }\n  }\n  return count;\n}",
  "Python_humaneval-146": "def special_filter(nums: List[int]) -> int:\n    count = 0\n    for num in nums:\n        if (\n            num > 10\n            and str(num)[0] in [\"1\", \"3\", \"5\", \"7\", \"9\"]\n            and str(num)[-1] in [\"1\", \"3\", \"5\", \"7\", \"9\"]\n        ):\n            count += 1\n    return count",
  "C#_humaneval-146": "public static int SpecialFilter(List<int> nums) {\n  int count = 0;\n  foreach (int num in nums) {\n    if (num > 10 && new List<char> { '1', '3', '5', '7', '9' }.Contains(num.ToString()[0]) &&\n        new List<char> { '1', '3', '5', '7', '9' }.Contains(num.ToString()[^1])) {\n      count += 1;\n    }\n  }\n  return count;\n}",
  "JavaScript_humaneval-146": "function specialFilter(nums) {\n  let count = 0;\n  for (let num of nums) {\n    if (\n      num > 10 &&\n      [\"1\", \"3\", \"5\", \"7\", \"9\"].includes(String(num)[0]) &&\n      [\"1\", \"3\", \"5\", \"7\", \"9\"].includes(String(num).slice(-1))\n    ) {\n      count += 1;\n    }\n  }\n  return count;\n}",
  "Go_humaneval-146": "func specialFilter(nums []int) int {\n    count := 0\n    for _, num := range nums {\n        num_str := strconv.Itoa(num)\n        if num > 10 && strings.ContainsAny(string(num_str[0]), \"13579\") && strings.ContainsAny(string(num_str[len(num_str)-1]), \"13579\") {\n            count++\n        }\n    }\n    return count\n}",
  "PHP_humaneval-146": "function specialFilter(array $nums): int {\n    $count = 0;\n    foreach ($nums as $num) {\n        if (\n            $num > 10\n            && in_array(substr($num, 0, 1), [\"1\", \"3\", \"5\", \"7\", \"9\"])\n            && in_array(substr($num, -1), [\"1\", \"3\", \"5\", \"7\", \"9\"])\n        ) {\n            $count++;\n        }\n    }\n    return $count;\n}",
  "Ruby_humaneval-146": "def special_filter(nums)\n  count = 0\n  nums.each do |num|\n    if num > 10 && %w[1 3 5 7 9].include?(num.to_s[0]) &&\n         %w[1 3 5 7 9].include?(num.to_s[-1])\n      count += 1\n    end\n  end\n  return count\nend",
  "Swift_humaneval-146": "func specialFilter(_ nums: [Int]) -> Int {\n  var count = 0\n  for num in nums {\n    if num > 10 && [\"1\", \"3\", \"5\", \"7\", \"9\"].contains(String(num).first!)\n      && [\"1\", \"3\", \"5\", \"7\", \"9\"].contains(String(num).last!)\n    {\n      count += 1\n    }\n  }\n  return count\n}",
  "TypeScript_humaneval-146": "function specialFilter(nums: number[]): number {\n  let count = 0;\n  for (const num of nums) {\n    if (\n      num > 10 &&\n      [\"1\", \"3\", \"5\", \"7\", \"9\"].includes(String(num)[0]) &&\n      [\"1\", \"3\", \"5\", \"7\", \"9\"].includes(String(num)[String(num).length - 1])\n    ) {\n      count++;\n    }\n  }\n  return count;\n}",
  "Dart_humaneval-146": "int specialFilter(List<int> nums) {\n  int count = 0;\n  for (int num in nums) {\n    if (num > 10 &&\n        [\"1\", \"3\", \"5\", \"7\", \"9\"].contains(num.toString()[0]) &&\n        [\"1\", \"3\", \"5\", \"7\", \"9\"]\n            .contains(num.toString()[num.toString().length - 1])) {\n      count += 1;\n    }\n  }\n  return count;\n}",
  "Rust_humaneval-146": "fn special_filter(nums: Vec<i32>) -> i32 {\n    let mut count = 0;\n    for num in nums {\n        if num > 10\n            && ['1', '3', '5', '7', '9'].contains(&num.to_string().chars().next().unwrap())\n            && ['1', '3', '5', '7', '9'].contains(&num.to_string().chars().last().unwrap())\n        {\n            count += 1;\n        }\n    }\n    count\n}",
  "Scala_humaneval-146": "def specialFilter(nums: List[Int]): Int = {\n  var count = 0\n  for (num <- nums) {\n    if (\n      num > 10 && List(\"1\", \"3\", \"5\", \"7\", \"9\").contains(\n        num.toString.head.toString\n      ) && List(\"1\", \"3\", \"5\", \"7\", \"9\").contains(num.toString.last.toString)\n    ) {\n      count += 1\n    }\n  }\n  count\n}",
  "Kotlin_humaneval-146": "fun specialFilter(nums: List<Int>): Int {\n  var count = 0\n  for (num in nums) {\n    if (num > 10 && num.toString()[0] in listOf('1', '3', '5', '7', '9') && num.toString().last() in listOf('1', '3', '5', '7', '9')) {\n      count += 1\n    }\n  }\n  return count\n}",
  "C++_humaneval-147": "int getMaxTriples(int n) {\n  int a[n];\n  for (int i = 1; i <= n; i++) {\n    a[i - 1] = i * i - i + 1;\n  }\n  int count = 0;\n  for (int i = 0; i < n - 2; i++) {\n    for (int j = i + 1; j < n - 1; j++) {\n      for (int k = j + 1; k < n; k++) {\n        if ((a[i] + a[j] + a[k]) % 3 == 0) {\n          count++;\n        }\n      }\n    }\n  }\n  return count;\n}",
  "Java_humaneval-147": "public static Integer getMaxTriples(Integer n) {\n  int[] a = new int[n];\n  int count = 0;\n  for (int i = 1; i <= n; i++) {\n    a[i - 1] = i * i - i + 1;\n  }\n  for (int i = 0; i < n - 2; i++) {\n    for (int j = i + 1; j < n - 1; j++) {\n      for (int k = j + 1; k < n; k++) {\n        if ((a[i] + a[j] + a[k]) % 3 == 0) {\n          count += 1;\n        }\n      }\n    }\n  }\n  return count;\n}",
  "Python_humaneval-147": "def get_max_triples(n: int) -> int:\n    a = [i * i - i + 1 for i in range(1, n + 1)]\n    count = 0\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                if (a[i] + a[j] + a[k]) % 3 == 0:\n                    count += 1\n    return count",
  "C#_humaneval-147": "public static int GetMaxTriples(int n) {\n  int[] a = new int[n];\n  int count = 0;\n  for (int i = 1; i <= n; i++) {\n    a[i - 1] = i * i - i + 1;\n  }\n  for (int i = 0; i < n - 2; i++) {\n    for (int j = i + 1; j < n - 1; j++) {\n      for (int k = j + 1; k < n; k++) {\n        if ((a[i] + a[j] + a[k]) % 3 == 0) {\n          count++;\n        }\n      }\n    }\n  }\n  return count;\n}",
  "JavaScript_humaneval-147": "function getMaxTriples(n) {\n  let a = [];\n  for (let i = 1; i <= n; i++) {\n    a.push(i * i - i + 1);\n  }\n  let count = 0;\n  for (let i = 0; i < n - 2; i++) {\n    for (let j = i + 1; j < n - 1; j++) {\n      for (let k = j + 1; k < n; k++) {\n        if ((a[i] + a[j] + a[k]) % 3 === 0) {\n          count++;\n        }\n      }\n    }\n  }\n  return count;\n}",
  "Go_humaneval-147": "func getMaxTriples(n int) int {\n    a := make([]int, n)\n    for i := 1; i <= n; i++ {\n        a[i-1] = i*i - i + 1\n    }\n    count := 0\n    for i := 0; i < n-2; i++ {\n        for j := i + 1; j < n-1; j++ {\n            for k := j + 1; k < n; k++ {\n                if (a[i]+a[j]+a[k])%3 == 0 {\n                    count++\n                }\n            }\n        }\n    }\n    return count\n}",
  "PHP_humaneval-147": "function getMaxTriples(int $n): int {\n    $a = [];\n    for($i=1; $i<=$n; $i++){\n        $a[] = $i * $i - $i + 1;\n    }\n    $count = 0;\n    for($i=0; $i<$n-2; $i++){\n        for($j=$i+1; $j<$n-1; $j++){\n            for($k=$j+1; $k<$n; $k++){\n                if(($a[$i] + $a[$j] + $a[$k]) % 3 == 0){\n                    $count++;\n                }\n            }\n        }\n    }\n    return $count;\n}",
  "Ruby_humaneval-147": "def get_max_triples(n)\n  a = (1..n).map { |i| i * i - i + 1 }\n  count = 0\n  (0..n - 3).each do |i|\n    (i + 1..n - 2).each do |j|\n      (j + 1..n - 1).each { |k| count += 1 if (a[i] + a[j] + a[k]) % 3 == 0 }\n    end\n  end\n  count\nend",
  "Swift_humaneval-147": "func getMaxTriples(_ n: Int) -> Int {\n  var a = [Int]()\n  for i in 1...n {\n    a.append(i * i - i + 1)\n  }\n  var count = 0\n  for i in 0..<n - 2 {\n    for j in i + 1..<n - 1 {\n      for k in j + 1..<n {\n        if (a[i] + a[j] + a[k]) % 3 == 0 {\n          count += 1\n        }\n      }\n    }\n  }\n  return count\n}",
  "TypeScript_humaneval-147": "function getMaxTriples(n: number): number {\n  const a: number[] = [];\n  for (let i = 1; i <= n; i++) {\n    a.push(i * i - i + 1);\n  }\n  let count = 0;\n  for (let i = 0; i < n - 2; i++) {\n    for (let j = i + 1; j < n - 1; j++) {\n      for (let k = j + 1; k < n; k++) {\n        if ((a[i] + a[j] + a[k]) % 3 === 0) {\n          count++;\n        }\n      }\n    }\n  }\n  return count;\n}",
  "Dart_humaneval-147": "int getMaxTriples(int n) {\n  List<int> a = [for (int i = 1; i <= n; i++) i * i - i + 1];\n  int count = 0;\n  for (int i = 0; i < n - 2; i++) {\n    for (int j = i + 1; j < n - 1; j++) {\n      for (int k = j + 1; k < n; k++) {\n        if ((a[i] + a[j] + a[k]) % 3 == 0) {\n          count++;\n        }\n      }\n    }\n  }\n  return count;\n}",
  "Rust_humaneval-147": "fn get_max_triples(n: i32) -> i32 {\n    let mut a = Vec::new();\n    for i in 1..=n {\n        a.push(i * i - i + 1);\n    }\n    let mut count = 0;\n    for i in 0..(n - 2) as usize {\n        for j in i + 1..(n - 1) as usize {\n            for k in j + 1..n as usize {\n                if (a[i] + a[j] + a[k]) % 3 == 0 {\n                    count += 1;\n                }\n            }\n        }\n    }\n    count\n}",
  "Scala_humaneval-147": "def getMaxTriples(n: Int): Int = {\n  val a = (1 to n).map(i => i * i - i + 1)\n  var count = 0\n  for (i <- 0 until n - 2) {\n    for (j <- i + 1 until n - 1) {\n      for (k <- j + 1 until n) {\n        if ((a(i) + a(j) + a(k)) % 3 == 0) {\n          count += 1\n        }\n      }\n    }\n  }\n  count\n}",
  "Kotlin_humaneval-147": "fun getMaxTriples(n: Int): Int {\n  val a = (1..n).map { it * it - it + 1 }\n  var count = 0\n  for (i in 0 until n - 2) {\n    for (j in i + 1 until n - 1) {\n      for (k in j + 1 until n) {\n        if ((a[i] + a[j] + a[k]) % 3 == 0) {\n          count += 1\n        }\n      }\n    }\n  }\n  return count\n}",
  "C++_humaneval-148": "vector<string> bf(string planet1, string planet2) {\n  vector<string> planets = {\n      \"Mercury\", \"Venus\",  \"Earth\",  \"Mars\",\n      \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\",\n  };\n  if (find(planets.begin(), planets.end(), planet1) == planets.end() ||\n      find(planets.begin(), planets.end(), planet2) == planets.end()) {\n    return {};\n  }\n  int index1 =\n      distance(planets.begin(), find(planets.begin(), planets.end(), planet1));\n  int index2 =\n      distance(planets.begin(), find(planets.begin(), planets.end(), planet2));\n  if (index1 > index2) {\n    swap(index1, index2);\n  }\n  vector<string> result;\n  for (int i = index1 + 1; i < index2; i++) {\n    result.push_back(planets[i]);\n  }\n  return result;\n}",
  "Java_humaneval-148": "public static List<String> bf(String planet1, String planet2) {\n  String[] planets = {\n      \"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"};\n  List<String> result = new ArrayList<>();\n  if (!Arrays.asList(planets).contains(planet1) || !Arrays.asList(planets).contains(planet2)) {\n    return result;\n  }\n  int index1 = Arrays.asList(planets).indexOf(planet1);\n  int index2 = Arrays.asList(planets).indexOf(planet2);\n  if (index1 > index2) {\n    int temp = index1;\n    index1 = index2;\n    index2 = temp;\n  }\n  for (int i = index1 + 1; i < index2; i++) {\n    result.add(planets[i]);\n  }\n  return result;\n}",
  "Python_humaneval-148": "def bf(planet1: str, planet2: str) -> List[str]:\n    planets = [\n        \"Mercury\",\n        \"Venus\",\n        \"Earth\",\n        \"Mars\",\n        \"Jupiter\",\n        \"Saturn\",\n        \"Uranus\",\n        \"Neptune\",\n    ]\n    if planet1 not in planets or planet2 not in planets:\n        return []\n    index1 = planets.index(planet1)\n    index2 = planets.index(planet2)\n    if index1 > index2:\n        index1, index2 = index2, index1\n    return [p for p in planets[index1 + 1 : index2]]",
  "C#_humaneval-148": "public static List<string> Bf(string planet1, string planet2) {\n  string[] planets = { \"Mercury\", \"Venus\",  \"Earth\",  \"Mars\",\n                       \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\" };\n  if (!planets.Contains(planet1) || !planets.Contains(planet2)) {\n    return new List<string>();\n  }\n  int index1 = Array.IndexOf(planets, planet1);\n  int index2 = Array.IndexOf(planets, planet2);\n  if (index1 > index2) {\n    int temp = index1;\n    index1 = index2;\n    index2 = temp;\n  }\n  return planets.Skip(index1 + 1).Take(index2 - index1 - 1).ToList();\n}",
  "JavaScript_humaneval-148": "function bf(planet1, planet2) {\n  const planets = [\n    \"Mercury\",\n    \"Venus\",\n    \"Earth\",\n    \"Mars\",\n    \"Jupiter\",\n    \"Saturn\",\n    \"Uranus\",\n    \"Neptune\",\n  ];\n  if (!planets.includes(planet1) || !planets.includes(planet2)) {\n    return [];\n  }\n  let index1 = planets.indexOf(planet1);\n  let index2 = planets.indexOf(planet2);\n  if (index1 > index2) {\n    [index1, index2] = [index2, index1];\n  }\n  return planets.slice(index1 + 1, index2);\n}",
  "Go_humaneval-148": "func bf(planet1 string, planet2 string) []string {\n    planets := []string{\n        \"Mercury\",\n        \"Venus\",\n        \"Earth\",\n        \"Mars\",\n        \"Jupiter\",\n        \"Saturn\",\n        \"Uranus\",\n        \"Neptune\",\n    }\n    if !contains(planets, planet1) || !contains(planets, planet2) {\n        return []string{}\n    }\n    index1 := indexOf(planets, planet1)\n    index2 := indexOf(planets, planet2)\n    if index1 > index2 {\n        index1, index2 = index2, index1\n    }\n    if index2-index1-1 < 0 {\n        return []string{}\n    }\n    return planets[index1+1 : index2]\n}\nfunc contains(s []string, e string) bool {\n    for _, a := range s {\n        if a == e {\n            return true\n        }\n    }\n    return false\n}\nfunc indexOf(s []string, e string) int {\n    for i, a := range s {\n        if a == e {\n            return i\n        }\n    }\n    return -1\n}",
  "PHP_humaneval-148": "function bf(string $planet1, string $planet2): array {\n    $planets = [\n        \"Mercury\",\n        \"Venus\",\n        \"Earth\",\n        \"Mars\",\n        \"Jupiter\",\n        \"Saturn\",\n        \"Uranus\",\n        \"Neptune\",\n    ];\n    if (!in_array($planet1, $planets) || !in_array($planet2, $planets)) {\n        return [];\n    }\n    $index1 = array_search($planet1, $planets);\n    $index2 = array_search($planet2, $planets);\n    if ($index1 > $index2) {\n        list($index1, $index2) = [$index2, $index1];\n    }\n if ($index2 - $index1 - 1 < 0) {\n        return [];\n    }\n    return array_slice($planets, $index1 + 1, $index2 - $index1 - 1);\n}",
  "Ruby_humaneval-148": "def bf(planet1, planet2)\n  planets = %w[Mercury Venus Earth Mars Jupiter Saturn Uranus Neptune]\n  return [] unless planets.include?(planet1) && planets.include?(planet2)\n  index1 = planets.index(planet1)\n  index2 = planets.index(planet2)\n  index1, index2 = index2, index1 if index1 > index2\n  planets[index1 + 1...index2]\nend",
  "Swift_humaneval-148": "func bf(_ planet1: String, _ planet2: String) -> [String] {\n  let planets = [\n    \"Mercury\",\n    \"Venus\",\n    \"Earth\",\n    \"Mars\",\n    \"Jupiter\",\n    \"Saturn\",\n    \"Uranus\",\n    \"Neptune\",\n  ]\n  guard planets.contains(planet1), planets.contains(planet2) else {\n    return []\n  }\n  var index1 = planets.firstIndex(of: planet1)!\n  var index2 = planets.firstIndex(of: planet2)!\n  if index1 > index2 {\n    swap(&index1, &index2)\n  }\n  if index2 - index1 - 1 < 0 {\n    return []\n  }\n  return Array(planets[index1 + 1..<index2])\n}",
  "TypeScript_humaneval-148": "function bf(planet1: string, planet2: string): string[] {\n  const planets: string[] = [\n    \"Mercury\",\n    \"Venus\",\n    \"Earth\",\n    \"Mars\",\n    \"Jupiter\",\n    \"Saturn\",\n    \"Uranus\",\n    \"Neptune\",\n  ];\n  if (!planets.includes(planet1) || !planets.includes(planet2)) {\n    return [];\n  }\n  let index1 = planets.indexOf(planet1);\n  let index2 = planets.indexOf(planet2);\n  if (index1 > index2) {\n    [index1, index2] = [index2, index1];\n  }\n  return planets.slice(index1 + 1, index2);\n}",
  "Dart_humaneval-148": "List<String> bf(String planet1, String planet2) {\n  List<String> planets = [\n    \"Mercury\",\n    \"Venus\",\n    \"Earth\",\n    \"Mars\",\n    \"Jupiter\",\n    \"Saturn\",\n    \"Uranus\",\n    \"Neptune\",\n  ];\n  if (!planets.contains(planet1) || !planets.contains(planet2)) {\n    return [];\n  }\n  int index1 = planets.indexOf(planet1);\n  int index2 = planets.indexOf(planet2);\n  if (index1 > index2) {\n    int temp = index1;\n    index1 = index2;\n    index2 = temp;\n  }\n  if (index2 - index1 - 1 < 0) {\n    return [];\n  }\n  return planets.sublist(index1 + 1, index2);\n}",
  "Rust_humaneval-148": "fn bf(planet1: String, planet2: String) -> Vec<String> {\n    let planets = vec![\n        String::from(\"Mercury\"),\n        String::from(\"Venus\"),\n        String::from(\"Earth\"),\n        String::from(\"Mars\"),\n        String::from(\"Jupiter\"),\n        String::from(\"Saturn\"),\n        String::from(\"Uranus\"),\n        String::from(\"Neptune\"),\n    ];\n    if !planets.contains(&planet1) || !planets.contains(&planet2) {\n        return vec![];\n    }\n    let index1 = planets.iter().position(|p| p == &planet1).unwrap();\n    let index2 = planets.iter().position(|p| p == &planet2).unwrap();\n    let (index1, index2) = if index1 > index2 {\n        (index2, index1)\n    } else {\n        (index1, index2)\n    };\n    if index2 as i32 - index1 as i32 - 1 < 0 {\n        return vec![];\n    }\n    planets[index1 + 1..index2].to_vec()\n}",
  "Scala_humaneval-148": "def bf(planet1: String, planet2: String): List[String] = {\n  val planets = List(\n    \"Mercury\",\n    \"Venus\",\n    \"Earth\",\n    \"Mars\",\n    \"Jupiter\",\n    \"Saturn\",\n    \"Uranus\",\n    \"Neptune\"\n  )\n  if (!planets.contains(planet1) || !planets.contains(planet2)) {\n    return List.empty[String]\n  }\n  val index1 = planets.indexOf(planet1)\n  val index2 = planets.indexOf(planet2)\n  if (index1 > index2) {\n    return planets.slice(index2 + 1, index1)\n  }\n  planets.slice(index1 + 1, index2)\n}",
  "Kotlin_humaneval-148": "fun bf(planet1: String, planet2: String): List<String> {\n  val planets = listOf(\n    \"Mercury\",\n    \"Venus\",\n    \"Earth\",\n    \"Mars\",\n    \"Jupiter\",\n    \"Saturn\",\n    \"Uranus\",\n    \"Neptune\"\n  )\n  if (planet1 !in planets || planet2 !in planets) {\n    return emptyList()\n  }\n  var index1 = planets.indexOf(planet1)\n  var index2 = planets.indexOf(planet2)\n  if (index1 > index2) {\n    index1 = index2.also { index2 = index1 }\n  }\n  if (index2 - index1 - 1 < 0) {\n    return emptyList()\n  }\n  return planets.subList(index1 + 1, index2)\n}",
  "C++_humaneval-149": "vector<string> sortedListSum(vector<string> l) {\n  vector<string> even_length_strings;\n  for (string s : l) {\n    if (s.length() % 2 == 0) {\n      even_length_strings.push_back(s);\n    }\n  }\n  sort(even_length_strings.begin(), even_length_strings.end(),\n       [](const string& a, const string& b) {\n         return a.length() < b.length() || (a.length() == b.length() && a < b);\n       });\n  return even_length_strings;\n}",
  "Java_humaneval-149": "public static List<String> sortedListSum(List<String> l) {\n  List<String> evenLengthStrings = new ArrayList<>();\n  for (String string : l) {\n    if (string.length() % 2 == 0) {\n      evenLengthStrings.add(string);\n    }\n  }\n  List<String> sortedList = new ArrayList<>(evenLengthStrings);\n  sortedList.sort(Comparator.comparing(String::length).thenComparing(Comparator.naturalOrder()));\n  return sortedList;\n}",
  "Python_humaneval-149": "def sorted_list_sum(l: List[str]) -> List[str]:\n    even_length_strings = []\n    for string in l:\n        if len(string) % 2 == 0:\n            even_length_strings.append(string)\n    sorted_list = sorted(even_length_strings, key=lambda x: (len(x), x))\n    return sorted_list",
  "C#_humaneval-149": "public static List<string> SortedListSum(List<string> l) {\n  List<string> even_length_strings = new List<string>();\n  foreach (string str in l) {\n    if (str.Length % 2 == 0) {\n      even_length_strings.Add(str);\n    }\n  }\n  List<string> sorted_list =\n      even_length_strings.OrderBy(x => x.Length).ThenBy(x => x, StringComparer.Ordinal).ToList();\n  return sorted_list;\n}",
  "JavaScript_humaneval-149": "function sortedListSum(l) {\n  const evenLengthStrings = [];\n  for (let i = 0; i < l.length; i++) {\n    if (l[i].length % 2 === 0) {\n      evenLengthStrings.push(l[i]);\n    }\n  }\n  const sortedList = evenLengthStrings.sort((a, b) => {\n    if (a.length === b.length) {\n      return a.localeCompare(b, undefined, { sensitivity: \"base\" });\n    }\n    return a.length - b.length;\n  });\n  return sortedList;\n}",
  "Go_humaneval-149": "func sortedListSum(l []string) []string {\n    evenLengthStrings := []string{}\n    for _, str := range l {\n        if len(str)%2 == 0 {\n            evenLengthStrings = append(evenLengthStrings, str)\n        }\n    }\n    sort.Slice(evenLengthStrings, func(i, j int) bool {\n        if len(evenLengthStrings[i]) == len(evenLengthStrings[j]) {\n            return evenLengthStrings[i] < evenLengthStrings[j]\n        }\n        return len(evenLengthStrings[i]) < len(evenLengthStrings[j])\n    })\n    return evenLengthStrings\n}",
  "PHP_humaneval-149": "function sortedListSum(array $l): array {\n    $even_length_strings = [];\n    foreach ($l as $string) {\n        if (strlen($string) % 2 == 0) {\n            $even_length_strings[] = $string;\n        }\n    }\n    usort($even_length_strings, function($a, $b) {\n        if (strlen($a) == strlen($b)) {\n            return strcmp($a, $b);\n        }\n        return strlen($a) - strlen($b);\n    });\n    return $even_length_strings;\n}",
  "Ruby_humaneval-149": "def sorted_list_sum(l)\n  even_length_strings = []\n  l.each { |string| even_length_strings << string if string.length % 2 == 0 }\n  sorted_list = even_length_strings.sort_by { |x| [x.length, x] }\n  return sorted_list\nend",
  "Swift_humaneval-149": "func sortedListSum(_ l: [String]) -> [String] {\n  var evenLengthStrings = [String]()\n  for string in l {\n    if string.count % 2 == 0 {\n      evenLengthStrings.append(string)\n    }\n  }\n  let sortedList = evenLengthStrings.sorted { $0.count == $1.count ? $0 < $1 : $0.count < $1.count }\n  return sortedList\n}",
  "TypeScript_humaneval-149": "function sortedListSum(l: string[]): string[] {\n  const evenLengthStrings: string[] = [];\n  for (const string of l) {\n    if (string.length % 2 === 0) {\n      evenLengthStrings.push(string);\n    }\n  }\n  const sortedList: string[] = evenLengthStrings.sort((a, b) => {\n    if (a.length === b.length) {\n      return a.localeCompare(b, undefined, { sensitivity: \"base\" });\n    }\n    return a.length - b.length;\n  });\n  return sortedList;\n}",
  "Dart_humaneval-149": "List<String> sortedListSum(List<String> l) {\n  List<String> evenLengthStrings = [];\n  for (String string in l) {\n    if (string.length % 2 == 0) {\n      evenLengthStrings.add(string);\n    }\n  }\n  List<String> sortedList = evenLengthStrings\n    ..sort(\n        (a, b) => a.length != b.length ? a.length - b.length : a.compareTo(b));\n  return sortedList;\n}",
  "Rust_humaneval-149": "fn sorted_list_sum(l: Vec<String>) -> Vec<String> {\n    let mut even_length_strings = Vec::new();\n    for string in l {\n        if string.len() % 2 == 0 {\n            even_length_strings.push(string);\n        }\n    }\n    even_length_strings.sort_by(|a, b| a.len().cmp(&b.len()).then(a.cmp(b)));\n    even_length_strings\n}",
  "Scala_humaneval-149": "def sortedListSum(l: List[String]): List[String] = {\n  val evenLengthStrings = l.filter(_.length % 2 == 0)\n  val sortedList = evenLengthStrings.sortBy(x => (x.length, x))\n  sortedList\n}",
  "Kotlin_humaneval-149": "fun sortedListSum(l: List<String>): List<String> {\n  val evenLengthStrings = mutableListOf<String>()\n  for (string in l) {\n    if (string.length % 2 == 0) {\n      evenLengthStrings.add(string)\n    }\n  }\n  val sortedList = evenLengthStrings.sortedWith(compareBy({ it.length }, { it }))\n  return sortedList\n}",
  "C++_humaneval-150": "int xOrY(int n, int x, int y) {\n  if (n < 2) {\n    return y;\n  }\n  for (int i = 2; i <= sqrt(n); i++) {\n    if (n % i == 0) {\n      return y;\n    }\n  }\n  return x;\n}",
  "Java_humaneval-150": "public static Integer xOrY(Integer n, Integer x, Integer y) {\n  if (n < 2) {\n    return y;\n  }\n  for (int i = 2; i <= Math.sqrt(n); i++) {\n    if (n % i == 0) {\n      return y;\n    }\n  }\n  return x;\n}",
  "Python_humaneval-150": "def x_or_y(n: int, x: int, y: int) -> int:\n    if n < 2:\n        return y\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return y\n    return x",
  "C#_humaneval-150": "public static int XOrY(int n, int x, int y) {\n  if (n < 2) {\n    return y;\n  }\n  for (int i = 2; i <= (int)Math.Sqrt(n); i++) {\n    if (n % i == 0) {\n      return y;\n    }\n  }\n  return x;\n}",
  "JavaScript_humaneval-150": "function xOrY(n, x, y) {\n  if (n < 2) {\n    return y;\n  }\n  for (let i = 2; i <= Math.sqrt(n); i++) {\n    if (n % i === 0) {\n      return y;\n    }\n  }\n  return x;\n}",
  "Go_humaneval-150": "func xOrY(n int, x int, y int) int {\n    if n < 2 {\n        return y\n    }\n    for i := 2; i <= int(math.Sqrt(float64(n))); i++ {\n        if n%i == 0 {\n            return y\n        }\n    }\n    return x\n}",
  "PHP_humaneval-150": "function xOrY(int $n, int $x, int $y): int {\n    if ($n < 2) {\n        return $y;\n    }\n    for ($i = 2; $i <= sqrt($n); $i++) {\n        if ($n % $i == 0) {\n            return $y;\n        }\n    }\n    return $x;\n}",
  "Ruby_humaneval-150": "def x_or_y(n, x, y)\n  return y if n < 2\n  (2..Integer.sqrt(n)).each { |i| return y if n % i == 0 }\n  x\nend",
  "Swift_humaneval-150": "func xOrY(_ n: Int, _ x: Int, _ y: Int) -> Int {\n  if n < 2 {\n    return y\n  }\n  for i in 2..<Int(1 + sqrt(Double(n))) {\n    if n % i == 0 {\n      return y\n    }\n  }\n  return x\n}",
  "TypeScript_humaneval-150": "function xOrY(n: number, x: number, y: number): number {\n  if (n < 2) {\n    return y;\n  }\n  for (let i = 2; i <= Math.sqrt(n); i++) {\n    if (n % i === 0) {\n      return y;\n    }\n  }\n  return x;\n}",
  "Dart_humaneval-150": "int xOrY(int n, int x, int y) {\n  if (n < 2) {\n    return y;\n  }\n  for (int i = 2; i <= sqrt(n); i++) {\n    if (n % i == 0) {\n      return y;\n    }\n  }\n  return x;\n}",
  "Rust_humaneval-150": "fn x_or_y(n: i32, x: i32, y: i32) -> i32 {\n    if n < 2 {\n        return y;\n    }\n    for i in 2..=(n as f32).sqrt() as i32 {\n        if n % i == 0 {\n            return y;\n        }\n    }\n    x\n}",
  "Scala_humaneval-150": "def xOrY(n: Int, x: Int, y: Int): Int = {\n  if (n < 2) {\n    y\n  } else {\n    for (i <- 2 to sqrt(n).toInt) {\n      if (n % i == 0) {\n        return y\n      }\n    }\n    x\n  }\n}",
  "Kotlin_humaneval-150": "fun xOrY(n: Int, x: Int, y: Int): Int {\n  if (n < 2) {\n    return y\n  }\n  for (i in 2..(n.toDouble().pow(0.5)).toInt()) {\n    if (n % i == 0) {\n      return y\n    }\n  }\n  return x\n}",
  "C++_humaneval-151": "int doubleTheDifference(vector<double> l) {\n  int sum_of_squares = 0;\n  for (double num : l) {\n    if (num >= 0 && fmod(num, 2) != 0 && num == (int)num) {\n      sum_of_squares += pow(num, 2);\n    }\n  }\n  return sum_of_squares;\n}",
  "Java_humaneval-151": "public static Integer doubleTheDifference(List<Double> l) {\n  int sumOfSquares = 0;\n  for (Double num : l) {\n    if (num >= 0 && num % 2 != 0 && num == num.intValue()) {\n      sumOfSquares += Math.pow(num, 2);\n    }\n  }\n  return sumOfSquares;\n}",
  "Python_humaneval-151": "def double_the_difference(l: List[float]) -> int:\n    sum_of_squares = 0\n    for num in l:\n        if num >= 0 and num % 2 != 0 and num == int(num):\n            sum_of_squares += num**2\n    return sum_of_squares",
  "C#_humaneval-151": "public static int DoubleTheDifference(List<double> l) {\n  int sumOfSquares = 0;\n  foreach (double num in l) {\n    if (num >= 0 && num % 2 != 0 && num == (int)num) {\n      sumOfSquares += (int)Math.Pow(num, 2);\n    }\n  }\n  return sumOfSquares;\n}",
  "JavaScript_humaneval-151": "function doubleTheDifference(l) {\n  let sumOfSquares = 0;\n  for (let num of l) {\n    if (num >= 0 && num % 2 !== 0 && num === parseInt(num)) {\n      sumOfSquares += num ** 2;\n    }\n  }\n  return sumOfSquares;\n}",
  "Go_humaneval-151": "func doubleTheDifference(l []float64) int {\n    sumOfSquares := 0\n    for _, num := range l {\n        if num >= 0 && math.Mod(num, 2) != 0 && num == math.Trunc(num) {\n            sumOfSquares += int(math.Pow(num, 2))\n        }\n    }\n    return sumOfSquares\n}",
  "PHP_humaneval-151": "function doubleTheDifference(array $l): int {\n    $sum_of_squares = 0;\n    foreach ($l as $num) {\n        if ($num >= 0 && $num % 2 != 0 && $num == (int)$num) {\n            $sum_of_squares += $num**2;\n        }\n    }\n    return $sum_of_squares;\n}",
  "Ruby_humaneval-151": "def double_the_difference(l)\n  sum_of_squares = 0\n  l.each do |num|\n    sum_of_squares += num**2 if num >= 0 && num % 2 != 0 && num == num.to_i\n  end\n  return sum_of_squares\nend",
  "Swift_humaneval-151": "func doubleTheDifference(_ l: [Double]) -> Int {\n  var sumOfSquares = 0\n  for num in l {\n    if num >= 0 && num.truncatingRemainder(dividingBy: 2) != 0 && num == Double(Int(num)) {\n      sumOfSquares += Int(num * num)\n    }\n  }\n  return sumOfSquares\n}",
  "TypeScript_humaneval-151": "function doubleTheDifference(l: number[]): number {\n  let sumOfSquares = 0;\n  for (const num of l) {\n    if (num >= 0 && num % 2 !== 0 && num === Math.floor(num)) {\n      sumOfSquares += num ** 2;\n    }\n  }\n  return sumOfSquares;\n}",
  "Dart_humaneval-151": "int doubleTheDifference(List<double> l) {\n  int sumOfSquares = 0;\n  l.forEach((num) {\n    if (num >= 0 && num % 2 != 0 && num == num.floor()) {\n      sumOfSquares += pow(num, 2).toInt();\n    }\n  });\n  return sumOfSquares;\n}",
  "Rust_humaneval-151": "fn double_the_difference(l: Vec<f64>) -> i32 {\n    let mut sum_of_squares = 0;\n    for num in l {\n        if num >= 0.0 && num % 2.0 != 0.0 && num == num.floor() {\n            sum_of_squares += (num * num) as i32;\n        }\n    }\n    return sum_of_squares;\n}",
  "Scala_humaneval-151": "def doubleTheDifference(l: List[Double]): Int = {\n  var sumOfSquares = 0\n  for (num <- l) {\n    if (num >= 0 && num % 2 != 0 && num == num.toInt) {\n      sumOfSquares += math.pow(num, 2).toInt\n    }\n  }\n  return sumOfSquares\n}",
  "Kotlin_humaneval-151": "fun doubleTheDifference(l: List<Double>): Int {\n  var sumOfSquares = 0\n  for (num in l) {\n    if (num >= 0 && num % 2 != 0.0 && num == num.toInt().toDouble()) {\n      sumOfSquares += num.toInt() * num.toInt()\n    }\n  }\n  return sumOfSquares\n}",
  "C++_humaneval-152": "vector<int> compare(vector<int> game, vector<int> guess) {\n  vector<int> result;\n  for (int i = 0; i < game.size(); i++) {\n    result.push_back(abs(game[i] - guess[i]));\n  }\n  return result;\n}",
  "Java_humaneval-152": "public static List<Integer> compare(List<Integer> game, List<Integer> guess) {\n  List<Integer> result = new ArrayList<>();\n  for (int i = 0; i < game.size(); i++) {\n    result.add(Math.abs(game.get(i) - guess.get(i)));\n  }\n  return result;\n}",
  "Python_humaneval-152": "def compare(game: List[int], guess: List[int]) -> List[int]:\n    return [abs(x - y) for x, y in zip(game, guess)]",
  "C#_humaneval-152": "public static List<int> Compare(List<int> game, List<int> guess) {\n  return game.Zip(guess, (x, y) => Math.Abs(x - y)).ToList();\n}",
  "JavaScript_humaneval-152": "function compare(game, guess) {\n  return game.map((x, i) => Math.abs(x - guess[i]));\n}",
  "Go_humaneval-152": "func compare(game []int, guess []int) []int {\n    result := make([]int, len(game))\n    for i, val := range game {\n        result[i] = abs(val - guess[i])\n    }\n    return result\n}\nfunc abs(x int) int {\n    if x < 0 {\n        return -x\n    }\n    return x\n}",
  "PHP_humaneval-152": "function compare(array $game, array $guess): array {\n    return array_map(function($x, $y) {\n        return abs($x - $y);\n    }, $game, $guess);\n}",
  "Ruby_humaneval-152": "def compare(game, guess)\n  game.zip(guess).map { |x, y| (x - y).abs }\nend",
  "Swift_humaneval-152": "func compare(_ game: [Int], _ guess: [Int]) -> [Int] {\n  return zip(game, guess).map { abs($0 - $1) }\n}",
  "TypeScript_humaneval-152": "function compare(game: number[], guess: number[]): number[] {\n  return game.map((x, i) => Math.abs(x - guess[i]));\n}",
  "Dart_humaneval-152": "List<int> compare(List<int> game, List<int> guess) {\n  return List.generate(game.length, (i) => (game[i] - guess[i]).abs());\n}",
  "Rust_humaneval-152": "fn compare(game: Vec<i32>, guess: Vec<i32>) -> Vec<i32> {\n    game.iter()\n        .zip(guess.iter())\n        .map(|(&x, &y)| (x - y).abs())\n        .collect()\n}",
  "Scala_humaneval-152": "def compare(game: List[Int], guess: List[Int]): List[Int] = {\n  game.zip(guess).map { case (x, y) => abs(x - y) }\n}",
  "Kotlin_humaneval-152": "fun compare(game: List<Int>, guess: List<Int>): List<Int> {\n  return game.zip(guess) { a, b -> Math.abs(a - b) }\n}",
  "C++_humaneval-153": "string strongestExtension(string class_name, vector<string> extensions) {\n  int max_strength = INT_MIN;\n  string strongest_extension = \"\";\n  for (string extension : extensions) {\n    int cap = count_if(extension.begin(), extension.end(),\n                       [](char c) { return isupper(c); });\n    int sm = count_if(extension.begin(), extension.end(),\n                      [](char c) { return islower(c); });\n    int strength = cap - sm;\n    if (strength > max_strength) {\n      max_strength = strength;\n      strongest_extension = extension;\n    }\n  }\n  return class_name + \".\" + strongest_extension;\n}",
  "Java_humaneval-153": "public static String strongestExtension(String className, List<String> extensions) {\n  int maxStrength = Integer.MIN_VALUE;\n  String strongestExtension = \"\";\n  for (String extension : extensions) {\n    int cap = 0, sm = 0;\n    for (char c : extension.toCharArray()) {\n      if (Character.isUpperCase(c)) {\n        cap++;\n      } else if (Character.isLowerCase(c)) {\n        sm++;\n      }\n    }\n    int strength = cap - sm;\n    if (strength > maxStrength) {\n      maxStrength = strength;\n      strongestExtension = extension;\n    }\n  }\n  return className + \".\" + strongestExtension;\n}",
  "Python_humaneval-153": "def strongest_extension(class_name: str, extensions: List[str]) -> str:\n    max_strength = float(\"-inf\")\n    strongest_extension = \"\"\n    for extension in extensions:\n        cap = sum(1 for c in extension if c.isupper())\n        sm = sum(1 for c in extension if c.islower())\n        strength = cap - sm\n        if strength > max_strength:\n            max_strength = strength\n            strongest_extension = extension\n    return f\"{class_name}.{strongest_extension}\"",
  "C#_humaneval-153": "public static string StrongestExtension(string className, List<string> extensions) {\n  int max_strength = int.MinValue;\n  string strongest_extension = \"\";\n  foreach (string extension in extensions) {\n    int cap = extension.Count(c => char.IsUpper(c));\n    int sm = extension.Count(c => char.IsLower(c));\n    int strength = cap - sm;\n    if (strength > max_strength) {\n      max_strength = strength;\n      strongest_extension = extension;\n    }\n  }\n  return $\"{className}.{strongest_extension}\";\n}",
  "JavaScript_humaneval-153": "function strongestExtension(className, extensions) {\n  let maxStrength = Number.NEGATIVE_INFINITY;\n  let strongestExtension = \"\";\n  for (let i = 0; i < extensions.length; i++) {\n    const extension = extensions[i];\n    const cap = (extension.match(/[A-Z]/g) || []).length;\n    const sm = (extension.match(/[a-z]/g) || []).length;\n    const strength = cap - sm;\n    if (strength > maxStrength) {\n      maxStrength = strength;\n      strongestExtension = extension;\n    }\n  }\n  return `${className}.${strongestExtension}`;\n}",
  "Go_humaneval-153": "func strongestExtension(className string, extensions []string) string {\n    maxStrength := math.Inf(-1)\n    strongestExtension := \"\"\n    for _, extension := range extensions {\n        cap := 0\n        sm := 0\n        for _, c := range extension {\n            if unicode.IsUpper(c) {\n                cap++\n            } else if unicode.IsLower(c) {\n                sm++\n            }\n        }\n        strength := float64(cap - sm)\n        if strength > maxStrength {\n            maxStrength = strength\n            strongestExtension = extension\n        }\n    }\n    return fmt.Sprintf(\"%s.%s\", className, strongestExtension)\n}",
  "PHP_humaneval-153": "function strongestExtension(string $className, array $extensions): string {\n    $max_strength = -INF;\n    $strongest_extension = \"\";\n    foreach ($extensions as $extension) {\n        $cap = preg_match_all('/[A-Z]/', $extension);\n        $sm = preg_match_all('/[a-z]/', $extension);\n        $strength = $cap - $sm;\n        if ($strength > $max_strength) {\n            $max_strength = $strength;\n            $strongest_extension = $extension;\n        }\n    }\n    return \"$className.$strongest_extension\";\n}",
  "Ruby_humaneval-153": "def strongest_extension(class_name, extensions)\n  max_strength = -Float::INFINITY\n  strongest_extension = \"\"\n  extensions.each do |extension|\n    cap = extension.chars.count { |c| c =~ /[A-Z]/ }\n    sm = extension.chars.count { |c| c =~ /[a-z]/ }\n    strength = cap - sm\n    if strength > max_strength\n      max_strength = strength\n      strongest_extension = extension\n    end\n  end\n  return \"#{class_name}.#{strongest_extension}\"\nend",
  "Swift_humaneval-153": "func strongestExtension(_ className: String, _ extensions: [String]) -> String {\n  var maxStrength = Int.min\n  var strongestExtension = \"\"\n  for ext in extensions {\n    let cap = ext.filter { $0.isUppercase }.count\n    let sm = ext.filter { $0.isLowercase }.count\n    let strength = cap - sm\n    if strength > maxStrength {\n      maxStrength = strength\n      strongestExtension = ext\n    }\n  }\n  return \"\\(className).\\(strongestExtension)\"\n}",
  "TypeScript_humaneval-153": "function strongestExtension(className: string, extensions: string[]): string {\n  let maxStrength = Number.NEGATIVE_INFINITY;\n  let strongestExtension = \"\";\n  for (const extension of extensions) {\n    const cap = extension.split(\"\").filter((c) => c.toUpperCase() === c).length;\n    const sm = extension.split(\"\").filter((c) => c.toLowerCase() === c).length;\n    const strength = cap - sm;\n    if (strength > maxStrength) {\n      maxStrength = strength;\n      strongestExtension = extension;\n    }\n  }\n  return `${className}.${strongestExtension}`;\n}",
  "Dart_humaneval-153": "String strongestExtension(String className, List<String> extensions) {\n  var maxStrength = double.negativeInfinity;\n  var strongestExtension = \"\";\n  for (var extension in extensions) {\n    var cap = extension.split('').where((c) => c.toUpperCase() == c).length;\n    var sm = extension.split('').where((c) => c.toLowerCase() == c).length;\n    var strength = cap - sm;\n    if (strength > maxStrength) {\n      maxStrength = strength.toDouble();\n      strongestExtension = extension;\n    }\n  }\n  return \"$className.$strongestExtension\";\n}",
  "Rust_humaneval-153": "fn strongest_extension(class_name: String, extensions: Vec<String>) -> String {\n    let mut max_strength = std::f32::NEG_INFINITY;\n    let mut strongest_extension = String::new();\n    for extension in extensions {\n        let cap = extension.chars().filter(|c| c.is_uppercase()).count() as f32;\n        let sm = extension.chars().filter(|c| c.is_lowercase()).count() as f32;\n        let strength = cap - sm;\n        if strength > max_strength {\n            max_strength = strength;\n            strongest_extension = extension;\n        }\n    }\n    format!(\"{}.{}\", class_name, strongest_extension)\n}",
  "Scala_humaneval-153": "def strongestExtension(className: String, extensions: List[String]): String = {\n  var maxStrength = Double.NegativeInfinity\n  var strongestExtension = \"\"\n  for (extension <- extensions) {\n    val cap = extension.count(_.isUpper)\n    val sm = extension.count(_.isLower)\n    val strength = cap - sm\n    if (strength > maxStrength) {\n      maxStrength = strength\n      strongestExtension = extension\n    }\n  }\n  s\"$className.$strongestExtension\"\n}",
  "Kotlin_humaneval-153": "fun strongestExtension(className: String, extensions: List<String>): String {\n  var maxStrength = Int.MIN_VALUE\n  var strongestExtension = \"\"\n  for (extension in extensions) {\n    val cap = extension.count { it.isUpperCase() }\n    val sm = extension.count { it.isLowerCase() }\n    val strength = cap - sm\n    if (strength > maxStrength) {\n      maxStrength = strength\n      strongestExtension = extension\n    }\n  }\n  return \"$className.$strongestExtension\"\n}",
  "C++_humaneval-154": "bool cycpatternCheck(string a, string b) {\n  if (a.length() < b.length()) {\n    return false;\n  }\n  for (int i = 0; i < b.length(); i++) {\n    if (a.find(b.substr(i) + b.substr(0, i)) != string::npos) {\n      return true;\n    }\n  }\n  return false;\n}",
  "Java_humaneval-154": "public static Boolean cycpatternCheck(String a, String b) {\n  if (a.length() < b.length()) {\n    return false;\n  }\n  for (int i = 0; i < b.length(); i++) {\n    if (a.contains(b.substring(i) + b.substring(0, i))) {\n      return true;\n    }\n  }\n  return false;\n}",
  "Python_humaneval-154": "def cycpattern_check(a: str, b: str) -> bool:\n    if len(a) < len(b):\n        return False\n    for i in range(len(b)):\n        if b[i:] + b[:i] in a:\n            return True\n    return False",
  "C#_humaneval-154": "public static bool CycpatternCheck(string a, string b) {\n  if (a.Length < b.Length) {\n    return false;\n  }\n  for (int i = 0; i < b.Length; i++) {\n    if (a.Contains(b.Substring(i) + b.Substring(0, i))) {\n      return true;\n    }\n  }\n  return false;\n}",
  "JavaScript_humaneval-154": "function cycpatternCheck(a, b) {\n  if (a.length < b.length) {\n    return false;\n  }\n  for (let i = 0; i < b.length; i++) {\n    if (a.includes(b.slice(i) + b.slice(0, i))) {\n      return true;\n    }\n  }\n  return false;\n}",
  "Go_humaneval-154": "func cycpatternCheck(a string, b string) bool {\n    if len(a) < len(b) {\n        return false\n    }\n    for i := 0; i < len(b); i++ {\n        if strings.Contains(a, b[i:]+b[:i]) {\n            return true\n        }\n    }\n    return false\n}",
  "PHP_humaneval-154": "function cycpatternCheck(string $a, string $b): bool {\n    if (strlen($a) < strlen($b)) {\n        return false;\n    }\n    for ($i = 0; $i < strlen($b); $i++) {\n        if (strpos($a, substr($b, $i) . substr($b, 0, $i)) !== false) {\n            return true;\n        }\n    }\n    return false;\n}",
  "Ruby_humaneval-154": "def cycpattern_check(a, b)\n  return false if a.length < b.length\n  (0...b.length).each { |i| return true if a.include?(b[i..-1] + b[0...i]) }\n  false\nend",
  "Swift_humaneval-154": "func cycpatternCheck(_ a: String, _ b: String) -> Bool {\n  if a.count < b.count {\n    return false\n  }\n  for i in 0..<b.count {\n    let index = b.index(b.startIndex, offsetBy: i)\n    let rotatedString = b[index...] + b[..<index]\n    if a.contains(rotatedString) {\n      return true\n    }\n  }\n  return false\n}",
  "TypeScript_humaneval-154": "function cycpatternCheck(a: string, b: string): boolean {\n  if (a.length < b.length) {\n    return false;\n  }\n  for (let i = 0; i < b.length; i++) {\n    if (a.includes(b.slice(i) + b.slice(0, i))) {\n      return true;\n    }\n  }\n  return false;\n}",
  "Dart_humaneval-154": "bool cycpatternCheck(String a, String b) {\n  if (a.length < b.length) {\n    return false;\n  }\n  for (int i = 0; i < b.length; i++) {\n    if (a.contains(b.substring(i) + b.substring(0, i))) {\n      return true;\n    }\n  }\n  return false;\n}",
  "Rust_humaneval-154": "fn cycpattern_check(a: String, b: String) -> bool {\n    if a.len() < b.len() {\n        return false;\n    }\n    for i in 0..b.len() {\n        let rotated_b = format!(\"{}{}\", &b[i..], &b[..i]);\n        if a.contains(&rotated_b) {\n            return true;\n        }\n    }\n    false\n}",
  "Scala_humaneval-154": "def cycpatternCheck(a: String, b: String): Boolean = {\n  if (a.length < b.length) {\n    return false\n  }\n  for (i <- 0 until b.length) {\n    if (a.contains(b.substring(i) + b.substring(0, i))) {\n      return true\n    }\n  }\n  false\n}",
  "Kotlin_humaneval-154": "fun cycpatternCheck(a: String, b: String): Boolean {\n  if (a.length < b.length) {\n    return false\n  }\n  for (i in b.indices) {\n    if (b.substring(i) + b.substring(0, i) in a) {\n      return true\n    }\n  }\n  return false\n}",
  "C++_humaneval-155": "vector<int> evenOddCount(int num) {\n  int even_count = 0;\n  int odd_count = 0;\n  string num_str = to_string(abs(num));\n  for (char digit : num_str) {\n    if (digit % 2 == 0) {\n      even_count += 1;\n    } else {\n      odd_count += 1;\n    }\n  }\n  return {even_count, odd_count};\n}",
  "Java_humaneval-155": "public static List<Integer> evenOddCount(Integer num) {\n  int even_count = 0;\n  int odd_count = 0;\n  String strNum = Integer.toString(Math.abs(num));\n  for (int i = 0; i < strNum.length(); i++) {\n    int digit = Integer.parseInt(strNum.substring(i, i + 1));\n    if (digit % 2 == 0) {\n      even_count += 1;\n    } else {\n      odd_count += 1;\n    }\n  }\n  List<Integer> result = new ArrayList<>();\n  result.add(even_count);\n  result.add(odd_count);\n  return result;\n}",
  "Python_humaneval-155": "def even_odd_count(num: int) -> List[int]:\n    even_count = 0\n    odd_count = 0\n    for digit in str(abs(num)):\n        if int(digit) % 2 == 0:\n            even_count += 1\n        else:\n            odd_count += 1\n    return [even_count, odd_count]",
  "C#_humaneval-155": "public static List<int> EvenOddCount(int num) {\n  int even_count = 0;\n  int odd_count = 0;\n  foreach (char digit in Math.Abs(num).ToString()) {\n    if (int.Parse(digit.ToString()) % 2 == 0) {\n      even_count++;\n    } else {\n      odd_count++;\n    }\n  }\n  return new List<int> { even_count, odd_count };\n}",
  "JavaScript_humaneval-155": "function evenOddCount(num) {\n  let evenCount = 0;\n  let oddCount = 0;\n  num = Math.abs(num).toString();\n  for (let i = 0; i < num.length; i++) {\n    if (parseInt(num[i]) % 2 === 0) {\n      evenCount++;\n    } else {\n      oddCount++;\n    }\n  }\n  return [evenCount, oddCount];\n}",
  "Go_humaneval-155": "func evenOddCount(num int) []int {\n    evenCount := 0\n    oddCount := 0\n    for _, digit := range strconv.Itoa(int(math.Abs(float64(num)))) {\n        if int(digit-'0')%2 == 0 {\n            evenCount++\n        } else {\n            oddCount++\n        }\n    }\n    return []int{evenCount, oddCount}\n}",
  "PHP_humaneval-155": "function evenOddCount(int $num): array {\n    $even_count = 0;\n    $odd_count = 0;\n    foreach (str_split(abs($num)) as $digit) {\n        if (intval($digit) % 2 == 0) {\n            $even_count++;\n        } else {\n            $odd_count++;\n        }\n    }\n    return [$even_count, $odd_count];\n}",
  "Ruby_humaneval-155": "def even_odd_count(num)\n  even_count = 0\n  odd_count = 0\n  num.abs.to_s.each_char do |digit|\n    if digit.to_i % 2 == 0\n      even_count += 1\n    else\n      odd_count += 1\n    end\n  end\n  [even_count, odd_count]\nend",
  "Swift_humaneval-155": "func evenOddCount(_ num: Int) -> [Int] {\n  var evenCount = 0\n  var oddCount = 0\n  for digit in String(abs(num)) {\n    if let digitInt = Int(String(digit)),\n      digitInt % 2 == 0\n    {\n      evenCount += 1\n    } else {\n      oddCount += 1\n    }\n  }\n  return [evenCount, oddCount]\n}",
  "TypeScript_humaneval-155": "function evenOddCount(num: number): number[] {\n  let evenCount = 0;\n  let oddCount = 0;\n  for (const digit of Math.abs(num).toString()) {\n    if (parseInt(digit) % 2 === 0) {\n      evenCount++;\n    } else {\n      oddCount++;\n    }\n  }\n  return [evenCount, oddCount];\n}",
  "Dart_humaneval-155": "List<int> evenOddCount(int num) {\n  var evenCount = 0;\n  var oddCount = 0;\n  num.abs().toString().split('').forEach((digit) {\n    if (int.parse(digit) % 2 == 0) {\n      evenCount++;\n    } else {\n      oddCount++;\n    }\n  });\n  return [evenCount, oddCount];\n}",
  "Rust_humaneval-155": "fn even_odd_count(num: i32) -> Vec<i32> {\n    let mut even_count = 0;\n    let mut odd_count = 0;\n    for digit in num.abs().to_string().chars() {\n        if digit.to_digit(10).unwrap() % 2 == 0 {\n            even_count += 1;\n        } else {\n            odd_count += 1;\n        }\n    }\n    vec![even_count, odd_count]\n}",
  "Scala_humaneval-155": "def evenOddCount(num: Int): List[Int] = {\n  var evenCount = 0\n  var oddCount = 0\n  for (digit <- num.abs.toString) {\n    if (digit.toInt % 2 == 0) {\n      evenCount += 1\n    } else {\n      oddCount += 1\n    }\n  }\n  List(evenCount, oddCount)\n}",
  "Kotlin_humaneval-155": "fun evenOddCount(num: Int): List<Int> {\n  var evenCount = 0\n  var oddCount = 0\n  for (digit in num.absoluteValue.toString()) {\n    if (digit.toInt() % 2 == 0) {\n      evenCount++\n    } else {\n      oddCount++\n    }\n  }\n  return listOf(evenCount, oddCount)\n}",
  "C++_humaneval-156": "string intToMiniRoman(int number) {\n  pair<int, string> roman_numerals[] = {\n      {1000, \"m\"}, {900, \"cm\"}, {500, \"d\"}, {400, \"cd\"}, {100, \"c\"},\n      {90, \"xc\"},  {50, \"l\"},   {40, \"xl\"}, {10, \"x\"},   {9, \"ix\"},\n      {5, \"v\"},    {4, \"iv\"},   {1, \"i\"}};\n  string result = \"\";\n  for (auto [value, numeral] : roman_numerals) {\n    while (number >= value) {\n      result += numeral;\n      number -= value;\n    }\n  }\n  return result;\n}",
  "Java_humaneval-156": "public static String intToMiniRoman(Integer number) {\n  int[] values = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n  String[] symbols = {\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"};\n  StringBuilder result = new StringBuilder();\n  for (int i = 0; i < values.length; i++) {\n    while (number >= values[i]) {\n      result.append(symbols[i]);\n      number -= values[i];\n    }\n  }\n  return result.toString();\n}",
  "Python_humaneval-156": "def int_to_mini_roman(number: int) -> str:\n    roman_numerals = [\n        (1000, \"m\"),\n        (900, \"cm\"),\n        (500, \"d\"),\n        (400, \"cd\"),\n        (100, \"c\"),\n        (90, \"xc\"),\n        (50, \"l\"),\n        (40, \"xl\"),\n        (10, \"x\"),\n        (9, \"ix\"),\n        (5, \"v\"),\n        (4, \"iv\"),\n        (1, \"i\"),\n    ]\n    result = \"\"\n    for value, numeral in roman_numerals:\n        while number >= value:\n            result += numeral\n            number -= value\n    return result",
  "C#_humaneval-156": "public static string IntToMiniRoman(int number) {\n  var romanNumerals = new(int, string)[] {\n    (1000, \"m\"), (900, \"cm\"), (500, \"d\"), (400, \"cd\"), (100, \"c\"), (90, \"xc\"), (50, \"l\"),\n    (40, \"xl\"),  (10, \"x\"),   (9, \"ix\"),  (5, \"v\"),    (4, \"iv\"),  (1, \"i\"),\n  };\n  var result = \"\";\n  foreach (var (value, numeral) in romanNumerals) {\n    while (number >= value) {\n      result += numeral;\n      number -= value;\n    }\n  }\n  return result;\n}",
  "JavaScript_humaneval-156": "function intToMiniRoman(number) {\n  const romanNumerals = [\n    [1000, \"m\"],\n    [900, \"cm\"],\n    [500, \"d\"],\n    [400, \"cd\"],\n    [100, \"c\"],\n    [90, \"xc\"],\n    [50, \"l\"],\n    [40, \"xl\"],\n    [10, \"x\"],\n    [9, \"ix\"],\n    [5, \"v\"],\n    [4, \"iv\"],\n    [1, \"i\"],\n  ];\n  let result = \"\";\n  for (let [value, numeral] of romanNumerals) {\n    while (number >= value) {\n      result += numeral;\n      number -= value;\n    }\n  }\n  return result;\n}",
  "Go_humaneval-156": "func intToMiniRoman(number int) string {\n    romanNumerals := []struct {\n        value   int\n        numeral string\n    }{\n        {1000, \"m\"},\n        {900, \"cm\"},\n        {500, \"d\"},\n        {400, \"cd\"},\n        {100, \"c\"},\n        {90, \"xc\"},\n        {50, \"l\"},\n        {40, \"xl\"},\n        {10, \"x\"},\n        {9, \"ix\"},\n        {5, \"v\"},\n        {4, \"iv\"},\n        {1, \"i\"},\n    }\n    result := \"\"\n    for _, r := range romanNumerals {\n        for number >= r.value {\n            result += r.numeral\n            number -= r.value\n        }\n    }\n    return result\n}",
  "PHP_humaneval-156": "function intToMiniRoman(int $number): string {\n    $romanNumerals = [\n        [1000, \"m\"],\n        [900, \"cm\"],\n        [500, \"d\"],\n        [400, \"cd\"],\n        [100, \"c\"],\n        [90, \"xc\"],\n        [50, \"l\"],\n        [40, \"xl\"],\n        [10, \"x\"],\n        [9, \"ix\"],\n        [5, \"v\"],\n        [4, \"iv\"],\n        [1, \"i\"],\n    ];\n    $result = \"\";\n    foreach ($romanNumerals as list($value, $numeral)) {\n        while ($number >= $value) {\n            $result .= $numeral;\n            $number -= $value;\n        }\n    }\n    return $result;\n}",
  "Ruby_humaneval-156": "def int_to_mini_roman(number)\n  roman_numerals = [\n    [1000, \"m\"],\n    [900, \"cm\"],\n    [500, \"d\"],\n    [400, \"cd\"],\n    [100, \"c\"],\n    [90, \"xc\"],\n    [50, \"l\"],\n    [40, \"xl\"],\n    [10, \"x\"],\n    [9, \"ix\"],\n    [5, \"v\"],\n    [4, \"iv\"],\n    [1, \"i\"]\n  ]\n  result = \"\"\n  roman_numerals.each do |value, numeral|\n    while number >= value\n      result += numeral\n      number -= value\n    end\n  end\n  result\nend",
  "Swift_humaneval-156": "func intToMiniRoman(_ number: Int) -> String {\n  let romanNumerals = [\n    (1000, \"m\"),\n    (900, \"cm\"),\n    (500, \"d\"),\n    (400, \"cd\"),\n    (100, \"c\"),\n    (90, \"xc\"),\n    (50, \"l\"),\n    (40, \"xl\"),\n    (10, \"x\"),\n    (9, \"ix\"),\n    (5, \"v\"),\n    (4, \"iv\"),\n    (1, \"i\"),\n  ]\n  var result = \"\"\n  var num = number\n  for (value, numeral) in romanNumerals {\n    while num >= value {\n      result += numeral\n      num -= value\n    }\n  }\n  return result\n}",
  "TypeScript_humaneval-156": "function intToMiniRoman(number: number): string {\n  const romanNumerals: [number, string][] = [\n    [1000, \"m\"],\n    [900, \"cm\"],\n    [500, \"d\"],\n    [400, \"cd\"],\n    [100, \"c\"],\n    [90, \"xc\"],\n    [50, \"l\"],\n    [40, \"xl\"],\n    [10, \"x\"],\n    [9, \"ix\"],\n    [5, \"v\"],\n    [4, \"iv\"],\n    [1, \"i\"],\n  ];\n  let result = \"\";\n  for (const [value, numeral] of romanNumerals) {\n    while (number >= value) {\n      result += numeral;\n      number -= value;\n    }\n  }\n  return result;\n}",
  "Dart_humaneval-156": "String intToMiniRoman(int number) {\n  final romanNumerals = [\n    [1000, \"m\"],\n    [900, \"cm\"],\n    [500, \"d\"],\n    [400, \"cd\"],\n    [100, \"c\"],\n    [90, \"xc\"],\n    [50, \"l\"],\n    [40, \"xl\"],\n    [10, \"x\"],\n    [9, \"ix\"],\n    [5, \"v\"],\n    [4, \"iv\"],\n    [1, \"i\"],\n  ];\n  var result = \"\";\n  for (final pair in romanNumerals) {\n    final value = pair[0] as int;\n    final numeral = pair[1] as String;\n    while (number >= value) {\n      result += numeral;\n      number -= value;\n    }\n  }\n  return result;\n}",
  "Rust_humaneval-156": "fn int_to_mini_roman(number: i32) -> String {\n    let roman_numerals = vec![\n        (1000, \"m\"),\n        (900, \"cm\"),\n        (500, \"d\"),\n        (400, \"cd\"),\n        (100, \"c\"),\n        (90, \"xc\"),\n        (50, \"l\"),\n        (40, \"xl\"),\n        (10, \"x\"),\n        (9, \"ix\"),\n        (5, \"v\"),\n        (4, \"iv\"),\n        (1, \"i\"),\n    ];\n    let mut result = String::new();\n    let mut n = number;\n    for (value, numeral) in roman_numerals {\n        while n >= value {\n            result.push_str(numeral);\n            n -= value;\n        }\n    }\n    result\n}",
  "Scala_humaneval-156": "def intToMiniRoman(number: Int): String = {\n  val romanNumerals = List(\n    (1000, \"m\"),\n    (900, \"cm\"),\n    (500, \"d\"),\n    (400, \"cd\"),\n    (100, \"c\"),\n    (90, \"xc\"),\n    (50, \"l\"),\n    (40, \"xl\"),\n    (10, \"x\"),\n    (9, \"ix\"),\n    (5, \"v\"),\n    (4, \"iv\"),\n    (1, \"i\")\n  )\n  var result = \"\"\n  var num = number\n  for ((value, numeral) <- romanNumerals) {\n    while (num >= value) {\n      result += numeral\n      num -= value\n    }\n  }\n  result\n}",
  "Kotlin_humaneval-156": "fun intToMiniRoman(number: Int): String {\n  val romanNumerals = listOf(\n    1000 to \"m\",\n    900 to \"cm\",\n    500 to \"d\",\n    400 to \"cd\",\n    100 to \"c\",\n    90 to \"xc\",\n    50 to \"l\",\n    40 to \"xl\",\n    10 to \"x\",\n    9 to \"ix\",\n    5 to \"v\",\n    4 to \"iv\",\n    1 to \"i\"\n  )\n  var result = \"\"\n  var n = number\n  for ((value, numeral) in romanNumerals) {\n    while (n >= value) {\n      result += numeral\n      n -= value\n    }\n  }\n  return result\n}",
  "C++_humaneval-157": "bool rightAngleTriangle(int a, int b, int c) {\n  int sides[] = {a, b, c};\n  sort(sides, sides + 3);\n  if (sides[0] * sides[0] + sides[1] * sides[1] == sides[2] * sides[2]) {\n    return true;\n  } else {\n    return false;\n  }\n}",
  "Java_humaneval-157": "public static Boolean rightAngleTriangle(Integer a, Integer b, Integer c) {\n  List<Integer> sides = Arrays.asList(a, b, c);\n  Collections.sort(sides);\n  if (sides.get(0) * sides.get(0) + sides.get(1) * sides.get(1) == sides.get(2) * sides.get(2)) {\n    return true;\n  } else {\n    return false;\n  }\n}",
  "Python_humaneval-157": "def right_angle_triangle(a: int, b: int, c: int) -> bool:\n    sides = [a, b, c]\n    sides.sort()\n    if sides[0] ** 2 + sides[1] ** 2 == sides[2] ** 2:\n        return True\n    else:\n        return False",
  "C#_humaneval-157": "public static bool RightAngleTriangle(int a, int b, int c) {\n  int[] sides = { a, b, c };\n  Array.Sort(sides);\n  if (sides[0] * sides[0] + sides[1] * sides[1] == sides[2] * sides[2]) {\n    return true;\n  } else {\n    return false;\n  }\n}",
  "JavaScript_humaneval-157": "function rightAngleTriangle(a, b, c) {\n  const sides = [a, b, c];\n  sides.sort((a, b) => a - b);\n  if (sides[0] ** 2 + sides[1] ** 2 === sides[2] ** 2) {\n    return true;\n  } else {\n    return false;\n  }\n}",
  "Go_humaneval-157": "func rightAngleTriangle(a int, b int, c int) bool {\n    sides := []int{a, b, c}\n    sort.Ints(sides)\n    if sides[0]*sides[0]+sides[1]*sides[1] == sides[2]*sides[2] {\n        return true\n    } else {\n        return false\n    }\n}",
  "PHP_humaneval-157": "function rightAngleTriangle(int $a, int $b, int $c): bool {\n    $sides = [$a, $b, $c];\n    sort($sides);\n    if ($sides[0] ** 2 + $sides[1] ** 2 == $sides[2] ** 2) {\n        return true;\n    } else {\n        return false;\n    }\n}",
  "Ruby_humaneval-157": "def right_angle_triangle(a, b, c)\n  sides = [a, b, c]\n  sides.sort!\n  if sides[0]**2 + sides[1]**2 == sides[2]**2\n    return true\n  else\n    return false\n  end\nend",
  "Swift_humaneval-157": "func rightAngleTriangle(_ a: Int, _ b: Int, _ c: Int) -> Bool {\n  var sides = [a, b, c]\n  sides.sort()\n  if sides[0] * sides[0] + sides[1] * sides[1] == sides[2] * sides[2] {\n    return true\n  } else {\n    return false\n  }\n}",
  "TypeScript_humaneval-157": "function rightAngleTriangle(a: number, b: number, c: number): boolean {\n  const sides: number[] = [a, b, c];\n  sides.sort((a, b) => a - b);\n  if (sides[0] ** 2 + sides[1] ** 2 === sides[2] ** 2) {\n    return true;\n  } else {\n    return false;\n  }\n}",
  "Dart_humaneval-157": "bool rightAngleTriangle(int a, int b, int c) {\n  List<int> sides = [a, b, c];\n  sides.sort();\n  if (sides[0] * sides[0] + sides[1] * sides[1] == sides[2] * sides[2]) {\n    return true;\n  } else {\n    return false;\n  }\n}",
  "Rust_humaneval-157": "fn right_angle_triangle(a: i32, b: i32, c: i32) -> bool {\n    let mut sides = [a, b, c];\n    sides.sort();\n    if sides[0].pow(2) + sides[1].pow(2) == sides[2].pow(2) {\n        true\n    } else {\n        false\n    }\n}",
  "Scala_humaneval-157": "def rightAngleTriangle(a: Int, b: Int, c: Int): Boolean = {\n  val sides = List(a, b, c).sorted\n  if (sides(0) * sides(0) + sides(1) * sides(1) == sides(2) * sides(2)) {\n    true\n  } else {\n    false\n  }\n}",
  "Kotlin_humaneval-157": "fun rightAngleTriangle(a: Int, b: Int, c: Int): Boolean {\n  val sides = listOf(a, b, c).sorted()\n  return sides[0] * sides[0] + sides[1] * sides[1] == sides[2] * sides[2]\n}",
  "C++_humaneval-158": "string findMax(vector<string> words) {\n  int max_unique_chars = 0;\n  string max_word = \"\";\n  for (string word : words) {\n    unordered_set<char> char_set;\n    for (char c : word) {\n      char_set.insert(c);\n    }\n    int unique_chars = char_set.size();\n    if (unique_chars > max_unique_chars) {\n      max_unique_chars = unique_chars;\n      max_word = word;\n    } else if (unique_chars == max_unique_chars) {\n      max_word = min(max_word, word);\n    }\n  }\n  return max_word;\n}",
  "Java_humaneval-158": "public static String findMax(List<String> words) {\n  int maxUniqueChars = 0;\n  String maxWord = \"\";\n  for (String word : words) {\n    int uniqueChars = (int) word.chars().distinct().count();\n    if (uniqueChars > maxUniqueChars) {\n      maxUniqueChars = uniqueChars;\n      maxWord = word;\n    } else if (uniqueChars == maxUniqueChars) {\n      maxWord = maxWord.compareTo(word) < 0 ? maxWord : word;\n    }\n  }\n  return maxWord;\n}",
  "Python_humaneval-158": "def find_max(words: List[str]) -> str:\n    max_unique_chars = 0\n    max_word = \"\"\n    for word in words:\n        unique_chars = len(set(word))\n        if unique_chars > max_unique_chars:\n            max_unique_chars = unique_chars\n            max_word = word\n        elif unique_chars == max_unique_chars:\n            max_word = min(max_word, word)\n    return max_word",
  "C#_humaneval-158": "public static string FindMax(List<string> words) {\n  int maxUniqueChars = 0;\n  string maxWord = \"\";\n  foreach (string word in words) {\n    int uniqueChars = word.Distinct().Count();\n    if (uniqueChars > maxUniqueChars) {\n      maxUniqueChars = uniqueChars;\n      maxWord = word;\n    } else if (uniqueChars == maxUniqueChars) {\n      maxWord = string.Compare(maxWord, word) < 0 ? maxWord : word;\n    }\n  }\n  return maxWord;\n}",
  "JavaScript_humaneval-158": "function findMax(words) {\n  let maxUniqueChars = 0;\n  let maxWord = \"\";\n  for (let word of words) {\n    const uniqueChars = new Set(word).size;\n    if (uniqueChars > maxUniqueChars) {\n      maxUniqueChars = uniqueChars;\n      maxWord = word;\n    } else if (uniqueChars === maxUniqueChars) {\n      maxWord = maxWord < word ? maxWord : word;\n    }\n  }\n  return maxWord;\n}",
  "Go_humaneval-158": "func findMax(words []string) string {\n    maxUniqueChars := 0\n    var maxWord string\n    for _, word := range words {\n        uniqueChars := len(uniqueChars(word))\n        if uniqueChars > maxUniqueChars {\n            maxUniqueChars = uniqueChars\n            maxWord = word\n        } else if uniqueChars == maxUniqueChars {\n            if maxWord == \"\" {\n                maxWord = word\n            } else if word < maxWord {\n                maxWord = word\n            }\n        }\n    }\n    return maxWord\n}\nfunc uniqueChars(s string) map[rune]bool {\n    chars := make(map[rune]bool)\n    for _, r := range s {\n        chars[r] = true\n    }\n    return chars\n}",
  "PHP_humaneval-158": "function findMax(array $words): string {\n    $max_unique_chars = 0;\n    $max_word = \"\";\n    foreach ($words as $word) {\n        $unique_chars = count(array_unique(str_split($word)));\n        if ($unique_chars > $max_unique_chars) {\n            $max_unique_chars = $unique_chars;\n            $max_word = $word;\n        } elseif ($unique_chars == $max_unique_chars) {\n            $max_word = min($max_word, $word);\n        }\n    }\n    return $max_word;\n}",
  "Ruby_humaneval-158": "def find_max(words)\n  max_unique_chars = 0\n  max_word = \"\"\n  words.each do |word|\n    unique_chars = word.chars.uniq.size\n    if unique_chars > max_unique_chars\n      max_unique_chars = unique_chars\n      max_word = word\n    elsif unique_chars == max_unique_chars\n      max_word = [max_word, word].min\n    end\n  end\n  max_word\nend",
  "Swift_humaneval-158": "func findMax(_ words: [String]) -> String {\n  var maxUniqueChars = 0\n  var maxWord = \"\"\n  for word in words {\n    let uniqueChars = Set(word).count\n    if uniqueChars > maxUniqueChars {\n      maxUniqueChars = uniqueChars\n      maxWord = word\n    } else if uniqueChars == maxUniqueChars {\n      maxWord = min(maxWord, word)\n    }\n  }\n  return maxWord\n}",
  "TypeScript_humaneval-158": "function findMax(words: string[]): string {\n  let maxUniqueChars = 0;\n  let maxWord = \"\";\n  for (const word of words) {\n    const uniqueChars = new Set(word).size;\n    if (uniqueChars > maxUniqueChars) {\n      maxUniqueChars = uniqueChars;\n      maxWord = word;\n    } else if (uniqueChars === maxUniqueChars) {\n      maxWord = [maxWord, word].sort()[0];\n    }\n  }\n  return maxWord;\n}",
  "Dart_humaneval-158": "String findMax(List<String> words) {\n  int maxUniqueChars = 0;\n  String maxWord = \"\";\n  for (String word in words) {\n    int uniqueChars = word.split('').toSet().length;\n    if (uniqueChars > maxUniqueChars) {\n      maxUniqueChars = uniqueChars;\n      maxWord = word;\n    } else if (uniqueChars == maxUniqueChars) {\n      maxWord = [maxWord, word].reduce((a, b) => a.compareTo(b) < 0 ? a : b);\n    }\n  }\n  return maxWord;\n}",
  "Rust_humaneval-158": "fn find_max(words: Vec<String>) -> String {\n    let mut max_unique_chars = 0;\n    let mut max_word = String::new();\n    for word in words {\n        let unique_chars = word.chars().collect::<HashSet<_>>().len();\n        if unique_chars > max_unique_chars {\n            max_unique_chars = unique_chars;\n            max_word = word;\n        } else if unique_chars == max_unique_chars {\n            max_word = std::cmp::min(max_word, word);\n        }\n    }\n    max_word\n}",
  "Scala_humaneval-158": "def findMax(words: List[String]): String = {\n  var maxUniqueChars = 0\n  var maxWord = \"\"\n  for (word <- words) {\n    val uniqueChars = word.toSet.size\n    if (uniqueChars > maxUniqueChars) {\n      maxUniqueChars = uniqueChars\n      maxWord = word\n    } else if (uniqueChars == maxUniqueChars) {\n      maxWord = Seq(maxWord, word).min\n    }\n  }\n  maxWord\n}",
  "Kotlin_humaneval-158": "fun findMax(words: List<String>): String {\n  var maxUniqueChars = 0\n  var maxWord = \"\"\n  for (word in words) {\n    val uniqueChars = word.toSet().size\n    if (uniqueChars > maxUniqueChars) {\n      maxUniqueChars = uniqueChars\n      maxWord = word\n    } else if (uniqueChars == maxUniqueChars) {\n      maxWord = minOf(maxWord, word)\n    }\n  }\n  return maxWord\n}",
  "C++_humaneval-159": "vector<int> eat(int number, int need, int remaining) {\n  if (need <= remaining) {\n    return {number + need, remaining - need};\n  } else {\n    return {number + remaining, 0};\n  }\n}",
  "Java_humaneval-159": "public static List<Integer> eat(Integer number, Integer need, Integer remaining) {\n  List<Integer> result = new ArrayList<Integer>();\n  if (need <= remaining) {\n    result.add(number + need);\n    result.add(remaining - need);\n  } else {\n    result.add(number + remaining);\n    result.add(0);\n  }\n  return result;\n}",
  "Python_humaneval-159": "def eat(number: int, need: int, remaining: int) -> List[int]:\n    if need <= remaining:\n        return [number + need, remaining - need]\n    else:\n        return [number + remaining, 0]",
  "C#_humaneval-159": "public static List<int> Eat(int number, int need, int remaining) {\n  if (need <= remaining) {\n    return new List<int> { number + need, remaining - need };\n  } else {\n    return new List<int> { number + remaining, 0 };\n  }\n}",
  "JavaScript_humaneval-159": "function eat(number, need, remaining) {\n  if (need <= remaining) {\n    return [number + need, remaining - need];\n  } else {\n    return [number + remaining, 0];\n  }\n}",
  "Go_humaneval-159": "func eat(number int, need int, remaining int) []int {\n    if need <= remaining {\n        return []int{number + need, remaining - need}\n    } else {\n        return []int{number + remaining, 0}\n    }\n}",
  "PHP_humaneval-159": "function eat(int $number, int $need, int $remaining): array {\n    if ($need <= $remaining) {\n        return [$number + $need, $remaining - $need];\n    } else {\n        return [$number + $remaining, 0];\n    }\n}",
  "Ruby_humaneval-159": "def eat(number, need, remaining)\n  if need <= remaining\n    return number + need, remaining - need\n  else\n    return number + remaining, 0\n  end\nend",
  "Swift_humaneval-159": "func eat(_ number: Int, _ need: Int, _ remaining: Int) -> [Int] {\n  if need <= remaining {\n    return [number + need, remaining - need]\n  } else {\n    return [number + remaining, 0]\n  }\n}",
  "TypeScript_humaneval-159": "function eat(number: number, need: number, remaining: number): number[] {\n  if (need <= remaining) {\n    return [number + need, remaining - need];\n  } else {\n    return [number + remaining, 0];\n  }\n}",
  "Dart_humaneval-159": "List<int> eat(int number, int need, int remaining) {\n  if (need <= remaining) {\n    return [number + need, remaining - need];\n  } else {\n    return [number + remaining, 0];\n  }\n}",
  "Rust_humaneval-159": "fn eat(number: i32, need: i32, remaining: i32) -> Vec<i32> {\n    if need <= remaining {\n        vec![number + need, remaining - need]\n    } else {\n        vec![number + remaining, 0]\n    }\n}",
  "Scala_humaneval-159": "def eat(number: Int, need: Int, remaining: Int): List[Int] = {\n  if (need <= remaining) {\n    List(number + need, remaining - need)\n  } else {\n    List(number + remaining, 0)\n  }\n}",
  "Kotlin_humaneval-159": "fun eat(number: Int, need: Int, remaining: Int): List<Int> {\n  return if (need <= remaining) {\n    listOf(number + need, remaining - need)\n  } else {\n    listOf(number + remaining, 0)\n  }\n}",
  "C++_humaneval-160": "int doAlgebra(vector<string> operators, vector<int> operands) {\n  vector<string> ops = operators;\n  vector<int> nums = operands;\n  int i = ops.size() - 1;\n  while (i >= 0) {\n    if (ops[i] == \"**\") {\n      nums[i] = pow(nums[i], nums[i + 1]);\n      nums.erase(nums.begin() + i + 1);\n      ops.erase(ops.begin() + i);\n    }\n    i--;\n  }\n  i = 0;\n  while (i < ops.size()) {\n    if (ops[i] == \"*\") {\n      nums[i] = nums[i] * nums[i + 1];\n      nums.erase(nums.begin() + i + 1);\n      ops.erase(ops.begin() + i);\n      i--;\n    } else if (ops[i] == \"/\") {\n      nums[i] = nums[i] / nums[i + 1];\n      nums.erase(nums.begin() + i + 1);\n      ops.erase(ops.begin() + i);\n      i--;\n    }\n    i++;\n  }\n  i = 0;\n  while (i < ops.size()) {\n    if (ops[i] == \"+\") {\n      nums[i] = nums[i] + nums[i + 1];\n      nums.erase(nums.begin() + i + 1);\n      ops.erase(ops.begin() + i);\n      i--;\n    } else if (ops[i] == \"-\") {\n      nums[i] = nums[i] - nums[i + 1];\n      nums.erase(nums.begin() + i + 1);\n      ops.erase(ops.begin() + i);\n      i--;\n    }\n    i++;\n  }\n  return nums[0];\n}",
  "Java_humaneval-160": "public static Integer doAlgebra(List<String> operators, List<Integer> operands) {\n  List<String> ops = new ArrayList<>(operators);\n  List<Integer> nums = new ArrayList<>(operands);\n  int i = ops.size() - 1;\n  while (i >= 0) {\n    if (ops.get(i).equals(\"**\")) {\n      nums.set(i, (int) Math.pow(nums.get(i), nums.get(i + 1)));\n      nums.remove(i + 1);\n      ops.remove(i);\n    }\n    i--;\n  }\n  i = 0;\n  while (i < ops.size()) {\n    if (ops.get(i).equals(\"*\")) {\n      nums.set(i, nums.get(i) * nums.get(i + 1));\n      nums.remove(i + 1);\n      ops.remove(i);\n      i--;\n    } else if (ops.get(i).equals(\"/\")) {\n      nums.set(i, nums.get(i) / nums.get(i + 1));\n      nums.remove(i + 1);\n      ops.remove(i);\n      i--;\n    }\n    i++;\n  }\n  i = 0;\n  while (i < ops.size()) {\n    if (ops.get(i).equals(\"+\")) {\n      nums.set(i, nums.get(i) + nums.get(i + 1));\n      nums.remove(i + 1);\n      ops.remove(i);\n      i--;\n    } else if (ops.get(i).equals(\"-\")) {\n      nums.set(i, nums.get(i) - nums.get(i + 1));\n      nums.remove(i + 1);\n      ops.remove(i);\n      i--;\n    }\n    i++;\n  }\n  return nums.get(0);\n}",
  "Python_humaneval-160": "def do_algebra(operators: List[str], operands: List[int]) -> int:\n    ops = operators.copy()\n    nums = operands.copy()\n    i = len(ops) - 1\n    while i >= 0:\n        if ops[i] == \"**\":\n            nums[i] = nums[i] ** nums[i + 1]\n            nums.pop(i + 1)\n            ops.pop(i)\n        i -= 1\n    i = 0\n    while i < len(ops):\n        if ops[i] == \"*\":\n            nums[i] = nums[i] * nums[i + 1]\n            nums.pop(i + 1)\n            ops.pop(i)\n            i -= 1\n        elif ops[i] == \"/\":\n            nums[i] = nums[i] // nums[i + 1]\n            nums.pop(i + 1)\n            ops.pop(i)\n            i -= 1\n        i += 1\n    i = 0\n    while i < len(ops):\n        if ops[i] == \"+\":\n            nums[i] = nums[i] + nums[i + 1]\n            nums.pop(i + 1)\n            ops.pop(i)\n            i -= 1\n        elif ops[i] == \"-\":\n            nums[i] = nums[i] - nums[i + 1]\n            nums.pop(i + 1)\n            ops.pop(i)\n            i -= 1\n        i += 1\n    return nums[0]",
  "C#_humaneval-160": "public static int DoAlgebra(List<string> operators, List<int> operands) {\n  List<string> ops = new List<string>(operators);\n  List<int> nums = new List<int>(operands);\n  int i = ops.Count - 1;\n  while (i >= 0) {\n    if (ops[i] == \"**\") {\n      nums[i] = (int)Math.Pow(nums[i], nums[i + 1]);\n      nums.RemoveAt(i + 1);\n      ops.RemoveAt(i);\n    }\n    i--;\n  }\n  i = 0;\n  while (i < ops.Count) {\n    if (ops[i] == \"*\") {\n      nums[i] = nums[i] * nums[i + 1];\n      nums.RemoveAt(i + 1);\n      ops.RemoveAt(i);\n      i--;\n    } else if (ops[i] == \"/\") {\n      nums[i] = nums[i] / nums[i + 1];\n      nums.RemoveAt(i + 1);\n      ops.RemoveAt(i);\n      i--;\n    }\n    i++;\n  }\n  i = 0;\n  while (i < ops.Count) {\n    if (ops[i] == \"+\") {\n      nums[i] = nums[i] + nums[i + 1];\n      nums.RemoveAt(i + 1);\n      ops.RemoveAt(i);\n      i--;\n    } else if (ops[i] == \"-\") {\n      nums[i] = nums[i] - nums[i + 1];\n      nums.RemoveAt(i + 1);\n      ops.RemoveAt(i);\n      i--;\n    }\n    i++;\n  }\n  return nums[0];\n}",
  "JavaScript_humaneval-160": "function doAlgebra(operators, operands) {\n  let ops = [...operators];\n  let nums = [...operands];\n  let i = ops.length - 1;\n  while (i >= 0) {\n    if (ops[i] === \"**\") {\n      nums[i] = Math.pow(nums[i], nums[i + 1]);\n      nums.splice(i + 1, 1);\n      ops.splice(i, 1);\n    }\n    i--;\n  }\n  i = 0;\n  while (i < ops.length) {\n    if (ops[i] === \"*\") {\n      nums[i] = nums[i] * nums[i + 1];\n      nums.splice(i + 1, 1);\n      ops.splice(i, 1);\n      i--;\n    } else if (ops[i] === \"/\") {\n      nums[i] = Math.floor(nums[i] / nums[i + 1]);\n      nums.splice(i + 1, 1);\n      ops.splice(i, 1);\n      i--;\n    }\n    i++;\n  }\n  i = 0;\n  while (i < ops.length) {\n    if (ops[i] === \"+\") {\n      nums[i] = nums[i] + nums[i + 1];\n      nums.splice(i + 1, 1);\n      ops.splice(i, 1);\n      i--;\n    } else if (ops[i] === \"-\") {\n      nums[i] = nums[i] - nums[i + 1];\n      nums.splice(i + 1, 1);\n      ops.splice(i, 1);\n      i--;\n    }\n    i++;\n  }\n  return nums[0];\n}",
  "Go_humaneval-160": "func doAlgebra(operators []string, operands []int) int {\n    ops := make([]string, len(operators))\n    copy(ops, operators)\n    nums := make([]int, len(operands))\n    copy(nums, operands)\n    i := len(ops) - 1\n    for i >= 0 {\n        if ops[i] == \"**\" {\n            nums[i] = int(math.Pow(float64(nums[i]), float64(nums[i+1])))\n            nums = append(nums[:i+1], nums[i+2:]...)\n            ops = append(ops[:i], ops[i+1:]...)\n        }\n        i--\n    }\n    i = 0\n    for i < len(ops) {\n        if ops[i] == \"*\" {\n            nums[i] = nums[i] * nums[i+1]\n            nums = append(nums[:i+1], nums[i+2:]...)\n            ops = append(ops[:i], ops[i+1:]...)\n            i--\n        } else if ops[i] == \"/\" {\n            nums[i] = nums[i] / nums[i+1]\n            nums = append(nums[:i+1], nums[i+2:]...)\n            ops = append(ops[:i], ops[i+1:]...)\n            i--\n        }\n        i++\n    }\n    i = 0\n    for i < len(ops) {\n        if ops[i] == \"+\" {\n            nums[i] = nums[i] + nums[i+1]\n            nums = append(nums[:i+1], nums[i+2:]...)\n            ops = append(ops[:i], ops[i+1:]...)\n            i--\n        } else if ops[i] == \"-\" {\n            nums[i] = nums[i] - nums[i+1]\n            nums = append(nums[:i+1], nums[i+2:]...)\n            ops = append(ops[:i], ops[i+1:]...)\n            i--\n        }\n        i++\n    }\n    return nums[0]\n}",
  "PHP_humaneval-160": "function doAlgebra(array $operators, array $operands): int {\n    $ops = $operators;\n    $nums = $operands;\n    $i = count($ops) - 1;\n    while ($i >= 0) {\n        if ($ops[$i] == \"**\") {\n            $nums[$i] = pow($nums[$i], $nums[$i + 1]);\n            array_splice($nums, $i + 1, 1);\n            array_splice($ops, $i, 1);\n        }\n        $i--;\n    }\n    $i = 0;\n    while ($i < count($ops)) {\n        if ($ops[$i] == \"*\") {\n            $nums[$i] = $nums[$i] * $nums[$i + 1];\n            array_splice($nums, $i + 1, 1);\n            array_splice($ops, $i, 1);\n            $i--;\n        } elseif ($ops[$i] == \"/\") {\n            $nums[$i] = intdiv($nums[$i], $nums[$i + 1]);\n            array_splice($nums, $i + 1, 1);\n            array_splice($ops, $i, 1);\n            $i--;\n        }\n        $i++;\n    }\n    $i = 0;\n    while ($i < count($ops)) {\n        if ($ops[$i] == \"+\") {\n            $nums[$i] = $nums[$i] + $nums[$i + 1];\n            array_splice($nums, $i + 1, 1);\n            array_splice($ops, $i, 1);\n            $i--;\n        } elseif ($ops[$i] == \"-\") {\n            $nums[$i] = $nums[$i] - $nums[$i + 1];\n            array_splice($nums, $i + 1, 1);\n            array_splice($ops, $i, 1);\n            $i--;\n        }\n        $i++;\n    }\n    return $nums[0];\n}",
  "Ruby_humaneval-160": "def do_algebra(operators, operands)\n  ops = operators.dup\n  nums = operands.dup\n  i = ops.length - 1\n  while i >= 0\n    if ops[i] == \"**\"\n      nums[i] = nums[i]**nums[i + 1]\n      nums.delete_at(i + 1)\n      ops.delete_at(i)\n    end\n    i -= 1\n  end\n  i = 0\n  while i < ops.length\n    if ops[i] == \"*\"\n      nums[i] = nums[i] * nums[i + 1]\n      nums.delete_at(i + 1)\n      ops.delete_at(i)\n      i -= 1\n    elsif ops[i] == \"/\"\n      nums[i] = nums[i] / nums[i + 1]\n      nums.delete_at(i + 1)\n      ops.delete_at(i)\n      i -= 1\n    end\n    i += 1\n  end\n  i = 0\n  while i < ops.length\n    if ops[i] == \"+\"\n      nums[i] = nums[i] + nums[i + 1]\n      nums.delete_at(i + 1)\n      ops.delete_at(i)\n      i -= 1\n    elsif ops[i] == \"-\"\n      nums[i] = nums[i] - nums[i + 1]\n      nums.delete_at(i + 1)\n      ops.delete_at(i)\n      i -= 1\n    end\n    i += 1\n  end\n  return nums[0]\nend",
  "Swift_humaneval-160": "func doAlgebra(_ operators: [String], _ operands: [Int]) -> Int {\n  var ops = `operators`\n  var nums = operands\n  var i = ops.count - 1\n  while i >= 0 {\n    if ops[i] == \"**\" {\n      nums[i] = Int(pow(Double(nums[i]), Double(nums[i + 1])))\n      nums.remove(at: i + 1)\n      ops.remove(at: i)\n    }\n    i -= 1\n  }\n  i = 0\n  while i < ops.count {\n    if ops[i] == \"*\" {\n      nums[i] = nums[i] * nums[i + 1]\n      nums.remove(at: i + 1)\n      ops.remove(at: i)\n      i -= 1\n    } else if ops[i] == \"/\" {\n      nums[i] = nums[i] / nums[i + 1]\n      nums.remove(at: i + 1)\n      ops.remove(at: i)\n      i -= 1\n    }\n    i += 1\n  }\n  i = 0\n  while i < ops.count {\n    if ops[i] == \"+\" {\n      nums[i] = nums[i] + nums[i + 1]\n      nums.remove(at: i + 1)\n      ops.remove(at: i)\n      i -= 1\n    } else if ops[i] == \"-\" {\n      nums[i] = nums[i] - nums[i + 1]\n      nums.remove(at: i + 1)\n      ops.remove(at: i)\n      i -= 1\n    }\n    i += 1\n  }\n  return nums[0]\n}",
  "TypeScript_humaneval-160": "function doAlgebra(operators: string[], operands: number[]): number {\n  const ops = [...operators];\n  const nums = [...operands];\n  let i = ops.length - 1;\n  while (i >= 0) {\n    if (ops[i] === \"**\") {\n      nums[i] = nums[i] ** nums[i + 1];\n      nums.splice(i + 1, 1);\n      ops.splice(i, 1);\n    }\n    i--;\n  }\n  i = 0;\n  while (i < ops.length) {\n    if (ops[i] === \"*\") {\n      nums[i] = nums[i] * nums[i + 1];\n      nums.splice(i + 1, 1);\n      ops.splice(i, 1);\n      i--;\n    } else if (ops[i] === \"/\") {\n      nums[i] = Math.floor(nums[i] / nums[i + 1]);\n      nums.splice(i + 1, 1);\n      ops.splice(i, 1);\n      i--;\n    }\n    i++;\n  }\n  i = 0;\n  while (i < ops.length) {\n    if (ops[i] === \"+\") {\n      nums[i] = nums[i] + nums[i + 1];\n      nums.splice(i + 1, 1);\n      ops.splice(i, 1);\n      i--;\n    } else if (ops[i] === \"-\") {\n      nums[i] = nums[i] - nums[i + 1];\n      nums.splice(i + 1, 1);\n      ops.splice(i, 1);\n      i--;\n    }\n    i++;\n  }\n  return nums[0];\n}",
  "Dart_humaneval-160": "int doAlgebra(List<String> operators, List<int> operands) {\n  List<String> ops = List.from(operators);\n  List<int> nums = List.from(operands);\n  int i = ops.length - 1;\n  while (i >= 0) {\n    if (ops[i] == \"**\") {\n      nums[i] = pow(nums[i], nums[i + 1]).toInt();\n      nums.removeAt(i + 1);\n      ops.removeAt(i);\n    }\n    i -= 1;\n  }\n  i = 0;\n  while (i < ops.length) {\n    if (ops[i] == \"*\") {\n      nums[i] = nums[i] * nums[i + 1];\n      nums.removeAt(i + 1);\n      ops.removeAt(i);\n      i -= 1;\n    } else if (ops[i] == \"/\") {\n      nums[i] = nums[i] ~/ nums[i + 1];\n      nums.removeAt(i + 1);\n      ops.removeAt(i);\n      i -= 1;\n    }\n    i += 1;\n  }\n  i = 0;\n  while (i < ops.length) {\n    if (ops[i] == \"+\") {\n      nums[i] = nums[i] + nums[i + 1];\n      nums.removeAt(i + 1);\n      ops.removeAt(i);\n      i -= 1;\n    } else if (ops[i] == \"-\") {\n      nums[i] = nums[i] - nums[i + 1];\n      nums.removeAt(i + 1);\n      ops.removeAt(i);\n      i -= 1;\n    }\n    i += 1;\n  }\n  return nums[0];\n}",
  "Rust_humaneval-160": "fn do_algebra(operators: Vec<String>, operands: Vec<i32>) -> i32 {\n    let mut ops = operators.clone();\n    let mut nums = operands.clone();\n    let mut i = ops.len();\n    while i > 0 {\n        if ops[i - 1] == \"**\" {\n            nums[i - 1] = (nums[i - 1] as f64).powf(nums[i] as f64) as i32;\n            nums.remove(i);\n            ops.remove(i - 1);\n        }\n        i -= 1;\n    }\n    i = 1;\n    while i <= ops.len() {\n        if ops[i - 1] == \"*\" {\n            nums[i - 1] = nums[i - 1] * nums[i];\n            nums.remove(i);\n            ops.remove(i - 1);\n            i -= 1;\n        } else if ops[i - 1] == \"/\" {\n            nums[i - 1] = nums[i - 1] / nums[i];\n            nums.remove(i);\n            ops.remove(i - 1);\n            i -= 1;\n        }\n        i += 1;\n    }\n    i = 1;\n    while i <= ops.len() {\n        if ops[i - 1] == \"+\" {\n            nums[i - 1] = nums[i - 1] + nums[i];\n            nums.remove(i);\n            ops.remove(i - 1);\n            i -= 1;\n        } else if ops[i - 1] == \"-\" {\n            nums[i - 1] = nums[i - 1] - nums[i];\n            nums.remove(i);\n            ops.remove(i - 1);\n            i -= 1;\n        }\n        i += 1;\n    }\n    nums[0]\n}",
  "Scala_humaneval-160": "def doAlgebra(operators: List[String], operands: List[Int]): Int = {\n  var ops = operators\n  var nums = operands\n  var i = ops.length - 1\n  while (i >= 0) {\n    if (ops(i) == \"**\") {\n      nums = nums.updated(i, pow(nums(i), nums(i + 1)).toInt)\n      nums = nums.take(i + 1) ++ nums.drop(i + 2)\n      ops = ops.take(i) ++ ops.drop(i + 1)\n    }\n    i -= 1\n  }\n  i = 0\n  while (i < ops.length) {\n    if (ops(i) == \"*\") {\n      nums = nums.updated(i, nums(i) * nums(i + 1))\n      nums = nums.take(i + 1) ++ nums.drop(i + 2)\n      ops = ops.take(i) ++ ops.drop(i + 1)\n      i -= 1\n    } else if (ops(i) == \"/\") {\n      nums = nums.updated(i, nums(i) / nums(i + 1))\n      nums = nums.take(i + 1) ++ nums.drop(i + 2)\n      ops = ops.take(i) ++ ops.drop(i + 1)\n      i -= 1\n    }\n    i += 1\n  }\n  i = 0\n  while (i < ops.length) {\n    if (ops(i) == \"+\") {\n      nums = nums.updated(i, nums(i) + nums(i + 1))\n      nums = nums.take(i + 1) ++ nums.drop(i + 2)\n      ops = ops.take(i) ++ ops.drop(i + 1)\n      i -= 1\n    } else if (ops(i) == \"-\") {\n      nums = nums.updated(i, nums(i) - nums(i + 1))\n      nums = nums.take(i + 1) ++ nums.drop(i + 2)\n      ops = ops.take(i) ++ ops.drop(i + 1)\n      i -= 1\n    }\n    i += 1\n  }\n  nums(0)\n}",
  "Kotlin_humaneval-160": "fun doAlgebra(operators: List<String>, operands: List<Int>): Int {\n  val ops = operators.toMutableList()\n  val nums = operands.toMutableList()\n  var i = ops.size - 1\n  while (i >= 0) {\n    if (ops[i] == \"**\") {\n      nums[i] = nums[i].toDouble().pow(nums[i + 1].toDouble()).toInt()\n      nums.removeAt(i + 1)\n      ops.removeAt(i)\n    }\n    i--\n  }\n  i = 0\n  while (i < ops.size) {\n    if (ops[i] == \"*\") {\n      nums[i] = nums[i] * nums[i + 1]\n      nums.removeAt(i + 1)\n      ops.removeAt(i)\n      i--\n    } else if (ops[i] == \"/\") {\n      nums[i] = nums[i] / nums[i + 1]\n      nums.removeAt(i + 1)\n      ops.removeAt(i)\n      i--\n    }\n    i++\n  }\n  i = 0\n  while (i < ops.size) {\n    if (ops[i] == \"+\") {\n      nums[i] = nums[i] + nums[i + 1]\n      nums.removeAt(i + 1)\n      ops.removeAt(i)\n      i--\n    } else if (ops[i] == \"-\") {\n      nums[i] = nums[i] - nums[i + 1]\n      nums.removeAt(i + 1)\n      ops.removeAt(i)\n      i--\n    }\n    i++\n  }\n  return nums[0]\n}",
  "C++_humaneval-161": "string solve(string s) {\n  int letters = 0;\n  for (char& c : s) {\n    if (isalpha(c)) {\n      letters++;\n    }\n  }\n  if (letters == 0) {\n    return string(s.rbegin(), s.rend());\n  } else {\n    string result = \"\";\n    for (char& c : s) {\n      if (isalpha(c)) {\n        if (islower(c)) {\n          result += toupper(c);\n        } else {\n          result += tolower(c);\n        }\n      } else {\n        result += c;\n      }\n    }\n    return result;\n  }\n}",
  "Java_humaneval-161": "public static String solve(String s) {\n  int letters = 0;\n  for (char c : s.toCharArray()) {\n    if (Character.isLetter(c)) {\n      letters++;\n    }\n  }\n  if (letters == 0) {\n    return new StringBuilder(s).reverse().toString();\n  } else {\n    StringBuilder result = new StringBuilder();\n    for (char c : s.toCharArray()) {\n      if (Character.isLetter(c)) {\n        if (Character.isLowerCase(c)) {\n          result.append(Character.toUpperCase(c));\n        } else {\n          result.append(Character.toLowerCase(c));\n        }\n      } else {\n        result.append(c);\n      }\n    }\n    return result.toString();\n  }\n}",
  "Python_humaneval-161": "def solve(s: str) -> str:\n    letters = 0\n    for char in s:\n        if char.isalpha():\n            letters += 1\n    if letters == 0:\n        return s[::-1]\n    else:\n        result = \"\"\n        for char in s:\n            if char.isalpha():\n                if char.islower():\n                    result += char.upper()\n                else:\n                    result += char.lower()\n            else:\n                result += char\n        return result",
  "C#_humaneval-161": "public static string Solve(string s) {\n  int letters = 0;\n  foreach (char c in s) {\n    if (Char.IsLetter(c)) {\n      letters++;\n    }\n  }\n  if (letters == 0) {\n    return new string(s.Reverse().ToArray());\n  } else {\n    string result = \"\";\n    foreach (char c in s) {\n      if (Char.IsLetter(c)) {\n        if (Char.IsLower(c)) {\n          result += Char.ToUpper(c);\n        } else {\n          result += Char.ToLower(c);\n        }\n      } else {\n        result += c;\n      }\n    }\n    return result;\n  }\n}",
  "JavaScript_humaneval-161": "function solve(s) {\n  let letters = 0;\n  for (let i = 0; i < s.length; i++) {\n    if (s[i].match(/[a-z]/i)) {\n      letters++;\n    }\n  }\n  if (letters === 0) {\n    return s.split(\"\").reverse().join(\"\");\n  } else {\n    let result = \"\";\n    for (let i = 0; i < s.length; i++) {\n      if (s[i].match(/[a-z]/i)) {\n        if (s[i] === s[i].toLowerCase()) {\n          result += s[i].toUpperCase();\n        } else {\n          result += s[i].toLowerCase();\n        }\n      } else {\n        result += s[i];\n      }\n    }\n    return result;\n  }\n}",
  "Go_humaneval-161": "func solve(s string) string {\n    letters := 0\n    for _, char := range s {\n        if unicode.IsLetter(char) {\n            letters++\n        }\n    }\n    if letters == 0 {\n        runes := []rune(s)\n        for i, j := 0, len(runes)-1; i < j; i, j = i+1, j-1 {\n            runes[i], runes[j] = runes[j], runes[i]\n        }\n        return string(runes)\n    } else {\n        result := \"\"\n        for _, char := range s {\n            if unicode.IsLetter(char) {\n                if unicode.IsLower(char) {\n                    result += string(unicode.ToUpper(char))\n                } else {\n                    result += string(unicode.ToLower(char))\n                }\n            } else {\n                result += string(char)\n            }\n        }\n        return result\n    }\n}",
  "PHP_humaneval-161": "function solve(string $s): string {\n    $letters = 0;\n    for ($i = 0; $i < strlen($s); $i++) {\n        if (ctype_alpha($s[$i])) {\n            $letters++;\n        }\n    }\n    if ($letters == 0) {\n        return strrev($s);\n    } else {\n        $result = \"\";\n        for ($i = 0; $i < strlen($s); $i++) {\n            if (ctype_alpha($s[$i])) {\n                if (ctype_lower($s[$i])) {\n                    $result .= strtoupper($s[$i]);\n                } else {\n                    $result .= strtolower($s[$i]);\n                }\n            } else {\n                $result .= $s[$i];\n            }\n        }\n        return $result;\n    }\n}",
  "Ruby_humaneval-161": "def solve(s)\n  letters = 0\n  s.each_char { |char| letters += 1 if char.match?(/[[:alpha:]]/) }\n  if letters.zero?\n    return s.reverse\n  else\n    result = \"\"\n    s.each_char do |char|\n      if char.match?(/[[:alpha:]]/)\n        result += char.downcase == char ? char.upcase : char.downcase\n      else\n        result += char\n      end\n    end\n    return result\n  end\nend",
  "Swift_humaneval-161": "func solve(_ s: String) -> String {\n  var letters = 0\n  for char in s {\n    if char.isLetter {\n      letters += 1\n    }\n  }\n  if letters == 0 {\n    return String(s.reversed())\n  } else {\n    var result = \"\"\n    for char in s {\n      if char.isLetter {\n        if char.isLowercase {\n          result += char.uppercased()\n        } else {\n          result += char.lowercased()\n        }\n      } else {\n        result += String(char)\n      }\n    }\n    return result\n  }\n}",
  "TypeScript_humaneval-161": "function solve(s: string): string {\n  let letters: number = 0;\n  for (let char of s) {\n    if (char.match(/[a-z]/i)) {\n      letters++;\n    }\n  }\n  if (letters === 0) {\n    return s.split(\"\").reverse().join(\"\");\n  } else {\n    let result: string = \"\";\n    for (let char of s) {\n      if (char.match(/[a-z]/i)) {\n        if (char === char.toLowerCase()) {\n          result += char.toUpperCase();\n        } else {\n          result += char.toLowerCase();\n        }\n      } else {\n        result += char;\n      }\n    }\n    return result;\n  }\n}",
  "Dart_humaneval-161": "String solve(String s) {\n  int letters = 0;\n  for (var char in s.runes) {\n    if (String.fromCharCode(char).contains(RegExp('[a-zA-Z]'))) {\n      letters += 1;\n    }\n  }\n  if (letters == 0) {\n    return s.split('').reversed.join();\n  } else {\n    String result = \"\";\n    for (var char in s.runes) {\n      if (String.fromCharCode(char).contains(RegExp('[a-zA-Z]'))) {\n        if (String.fromCharCode(char).contains(RegExp('[a-z]'))) {\n          result += String.fromCharCode(char).toUpperCase();\n        } else {\n          result += String.fromCharCode(char).toLowerCase();\n        }\n      } else {\n        result += String.fromCharCode(char);\n      }\n    }\n    return result;\n  }\n}",
  "Rust_humaneval-161": "fn solve(s: String) -> String {\n    let mut letters = 0;\n    for char in s.chars() {\n        if char.is_alphabetic() {\n            letters += 1;\n        }\n    }\n    if letters == 0 {\n        return s.chars().rev().collect();\n    } else {\n        let mut result = String::new();\n        for char in s.chars() {\n            if char.is_alphabetic() {\n                if char.is_lowercase() {\n                    result.push(char.to_ascii_uppercase());\n                } else {\n                    result.push(char.to_ascii_lowercase());\n                }\n            } else {\n                result.push(char);\n            }\n        }\n        return result;\n    }\n}",
  "Scala_humaneval-161": "def solve(s: String): String = {\n  var letters = 0\n  for (char <- s) {\n    if (char.isLetter) {\n      letters += 1\n    }\n  }\n  if (letters == 0) {\n    s.reverse\n  } else {\n    var result = \"\"\n    for (char <- s) {\n      if (char.isLetter) {\n        if (char.isLower) {\n          result += char.toUpper\n        } else {\n          result += char.toLower\n        }\n      } else {\n        result += char\n      }\n    }\n    result\n  }\n}",
  "Kotlin_humaneval-161": "fun solve(s: String): String {\n  var letters = 0\n  for (char in s) {\n    if (char.isLetter()) {\n      letters++\n    }\n  }\n  if (letters == 0) {\n    return s.reversed()\n  } else {\n    var result = \"\"\n    for (char in s) {\n      if (char.isLetter()) {\n        if (char.isLowerCase()) {\n          result += char.toUpperCase()\n        } else {\n          result += char.toLowerCase()\n        }\n      } else {\n        result += char\n      }\n    }\n    return result\n  }\n}",
  "C++_humaneval-163": "vector<int> generateIntegers(int a, int b) {\n  int lower = max(2, min(a, b));\n  int upper = min(8, max(a, b));\n  vector<int> result;\n  for (int i = lower; i <= upper; i++) {\n    if (i % 2 == 0) {\n      result.push_back(i);\n    }\n  }\n  return result;\n}",
  "Java_humaneval-163": "public static List<Integer> generateIntegers(Integer a, Integer b) {\n  int lower = Math.max(2, Math.min(a, b));\n  int upper = Math.min(8, Math.max(a, b));\n  List<Integer> result = new ArrayList<>();\n  for (int i = lower; i <= upper; i++) {\n    if (i % 2 == 0) {\n      result.add(i);\n    }\n  }\n  return result;\n}",
  "Python_humaneval-163": "def generate_integers(a: int, b: int) -> List[int]:\n    lower = max(2, min(a, b))\n    upper = min(8, max(a, b))\n    return [i for i in range(lower, upper + 1) if i % 2 == 0]",
  "C#_humaneval-163": "public static List<int> GenerateIntegers(int a, int b) {\n  int lower = Math.Max(2, Math.Min(a, b));\n  int upper = Math.Min(8, Math.Max(a, b));\n  List<int> result = new List<int>();\n  for (int i = lower; i <= upper; i++) {\n    if (i % 2 == 0) {\n      result.Add(i);\n    }\n  }\n  return result;\n}",
  "JavaScript_humaneval-163": "function generateIntegers(a, b) {\n  let lower = Math.max(2, Math.min(a, b));\n  let upper = Math.min(8, Math.max(a, b));\n  return Array.from({ length: upper - lower + 1 }, (_, i) => i + lower).filter(\n    (i) => i % 2 === 0,\n  );\n}",
  "Go_humaneval-163": "func generateIntegers(a int, b int) []int {\n    lower := 2\n    if a < b {\n        lower = max(lower, a)\n    } else {\n        lower = max(lower, b)\n    }\n    upper := 8\n    if a > b {\n        upper = min(upper, a)\n    } else {\n        upper = min(upper, b)\n    }\n    var result []int\n    for i := lower; i <= upper; i++ {\n        if i%2 == 0 {\n            result = append(result, i)\n        }\n    }\n    return result\n}\nfunc max(a int, b int) int {\n    if a > b {\n        return a\n    }\n    return b\n}\nfunc min(a int, b int) int {\n    if a < b {\n        return a\n    }\n    return b\n}",
  "PHP_humaneval-163": "function generateIntegers(int $a, int $b): array {\n    $lower = max(2, min($a, $b));\n    $upper = min(8, max($a, $b));\n    $result = array();\n    for ($i = $lower; $i <= $upper; $i++) {\n        if ($i % 2 == 0) {\n            $result[] = $i;\n        }\n    }\n    return $result;\n}",
  "Ruby_humaneval-163": "def generate_integers(a, b)\n  lower = [2, [a, b].min].max\n  upper = [8, [a, b].max].min\n  (lower..upper).select(&:even?)\nend",
  "Swift_humaneval-163": "func generateIntegers(_ a: Int, _ b: Int) -> [Int] {\n  let lower = max(2, min(a, b))\n  let upper = min(8, max(a, b))\n  if lower >= upper {\n    return []\n  }\n  return Array(lower...upper).filter { $0 % 2 == 0 }\n}",
  "TypeScript_humaneval-163": "function generateIntegers(a: number, b: number): number[] {\n  const lower = Math.max(2, Math.min(a, b));\n  const upper = Math.min(8, Math.max(a, b));\n  return Array.from({ length: upper - lower + 1 }, (_, i) => i + lower).filter(\n    (i) => i % 2 === 0,\n  );\n}",
  "Dart_humaneval-163": "List<int> generateIntegers(int a, int b) {\n  int lower = max(min(a, b), 2);\n  int upper = min(max(a, b), 8);\n  List<int> result = [];\n  for (int i = lower; i <= upper; i++) {\n    if (i % 2 == 0) {\n      result.add(i);\n    }\n  }\n  return result;\n}",
  "Rust_humaneval-163": "fn generate_integers(a: i32, b: i32) -> Vec<i32> {\n    let lower = a.min(b).max(2);\n    let upper = a.max(b).min(8);\n    (lower..=upper).filter(|i| i % 2 == 0).collect()\n}",
  "Scala_humaneval-163": "def generateIntegers(a: Int, b: Int): List[Int] = {\n  val lower = max(2, min(a, b))\n  val upper = min(8, max(a, b))\n  (lower to upper).filter(_ % 2 == 0).toList\n}",
  "Kotlin_humaneval-163": "fun generateIntegers(a: Int, b: Int): List<Int> {\n  val lower = maxOf(2, minOf(a, b))\n  val upper = minOf(8, maxOf(a, b))\n  return (lower..upper step 2).toList()\n}"
}