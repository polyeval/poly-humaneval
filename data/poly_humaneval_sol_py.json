{
    "HumanEval/0": "def has_close_elements(numbers: List[float], threshold: float) -> bool:\n    for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            if abs(numbers[i] - numbers[j]) < threshold:\n                return True\n    return False",
    "HumanEval/1": "def separate_paren_groups(paren_string: str) -> List[str]:\n    groups = []\n    stack = []\n    current_group = \"\"\n    for char in paren_string.replace(\" \", \"\"):\n        if char == \"(\":\n            stack.append(char)\n            current_group += char\n        elif char == \")\":\n            stack.pop()\n            current_group += char\n            if not stack:\n                groups.append(current_group)\n                current_group = \"\"\n    return groups",
    "HumanEval/2": "def truncate_number(num: float) -> float:\n    return num - int(num)",
    "HumanEval/3": "def below_zero(operations: List[int]) -> bool:\n    balance = 0\n    for operation in operations:\n        balance += operation\n        if balance < 0:\n            return True\n    return False",
    "HumanEval/4": "def mean_absolute_deviation(numbers: List[float]) -> float:\n    mean = sum(numbers) / len(numbers)\n    return sum(abs(x - mean) for x in numbers) / len(numbers)",
    "HumanEval/5": "def intersperse(numbers: List[int], delimiter: int) -> List[int]:\n    result = []\n    for i in range(len(numbers)):\n        if i != 0:\n            result.append(delimiter)\n        result.append(numbers[i])\n    return result",
    "HumanEval/6": "def parse_nested_parens(paren_string: str) -> List[int]:\n    result = []\n    for group in paren_string.split():\n        max_depth = 0\n        depth = 0\n        for char in group:\n            if char == \"(\":\n                depth += 1\n                max_depth = max(max_depth, depth)\n            elif char == \")\":\n                depth -= 1\n        result.append(max_depth)\n    return result",
    "HumanEval/7": "def filter_by_substring(strs: List[str], substring: str) -> List[str]:\n    return [s for s in strs if substring in s]",
    "HumanEval/8": "def sum_product(numbers: List[int]) -> List[int]:\n    if not numbers:\n        return [0, 1]\n    else:\n        product = 1\n        for num in numbers:\n            product *= num\n        return [sum(numbers), product]",
    "HumanEval/9": "def rolling_max(numbers: List[int]) -> List[int]:\n    max_so_far = float(\"-inf\")\n    rolling_max_list = []\n    for num in numbers:\n        max_so_far = max(max_so_far, num)\n        rolling_max_list.append(max_so_far)\n    return rolling_max_list",
    "HumanEval/10": "def is_palindrome(s: str) -> bool:\n    return s == s[::-1]\n\ndef make_palindrome(s: str) -> str:\n    if is_palindrome(s):\n        return s\n    for i in range(len(s)):\n        if is_palindrome(s[i:]):\n            return s + s[:i][::-1]",
    "HumanEval/11": "def string_xor(a: str, b: str) -> str:\n    result = \"\"\n    for i in range(len(a)):\n        if a[i] == b[i]:\n            result += \"0\"\n        else:\n            result += \"1\"\n    return result",
    "HumanEval/12": "def longest(strs: List[str]) -> Optional[str]:\n    if not strs:\n        return None\n    longest_string = strs[0]\n    for string in strs:\n        if len(string) > len(longest_string):\n            longest_string = string\n    return longest_string",
    "HumanEval/13": "def greatest_common_divisor(a: int, b: int) -> int:\n    if b == 0:\n        return a\n    else:\n        return greatest_common_divisor(b, a % b)",
    "HumanEval/14": "def all_prefixes(s: str) -> List[str]:\n    prefixes = []\n    for i in range(len(s)):\n        prefixes.append(s[: i + 1])\n    return prefixes",
    "HumanEval/15": "def string_sequence(n: int) -> str:\n    return \" \".join([str(i) for i in range(n + 1)])",
    "HumanEval/16": "def count_distinct_characters(s: str) -> int:\n    s = s.lower()\n    distinct_chars = set(s)\n    return len(distinct_chars)",
    "HumanEval/17": "def parse_music(music_string: str) -> List[int]:\n    durations = {\"o\": 4, \"o|\": 2, \".|\": 1}\n    notes = music_string.split()\n    return [durations[note] for note in notes]",
    "HumanEval/18": "def how_many_times(s: str, substring: str) -> int:\n    count = 0\n    if len(substring) == 0:\n        return 0\n    for i in range(len(s) - len(substring) + 1):\n        if s[i : i + len(substring)] == substring:\n            count += 1\n    return count",
    "HumanEval/19": "def sort_numbers(numbers: str) -> str:\n    num_dict = {\n        \"zero\": 0,\n        \"one\": 1,\n        \"two\": 2,\n        \"three\": 3,\n        \"four\": 4,\n        \"five\": 5,\n        \"six\": 6,\n        \"seven\": 7,\n        \"eight\": 8,\n        \"nine\": 9,\n    }\n    num_list = numbers.split()\n    num_list.sort(key=lambda x: num_dict[x])\n    return \" \".join(num_list)",
    "HumanEval/20": "def find_closest_elements(numbers: List[float]) -> List[float]:\n    sorted_numbers = sorted(numbers)\n    min_diff = float(\"inf\")\n    closest_pair = []\n    for i in range(len(sorted_numbers) - 1):\n        diff = sorted_numbers[i + 1] - sorted_numbers[i]\n        if diff < min_diff:\n            min_diff = diff\n            closest_pair = [sorted_numbers[i], sorted_numbers[i + 1]]\n    return closest_pair",
    "HumanEval/21": "def rescale_to_unit(numbers: List[float]) -> List[float]:\n    min_num = min(numbers)\n    max_num = max(numbers)\n    if min_num == max_num:\n        return [0.0] * len(numbers)\n    else:\n        return [(num - min_num) / (max_num - min_num) for num in numbers]",
    "HumanEval/22": "def filter_integers(values: List[Any]) -> List[int]:\n    return [x for x in values if isinstance(x, int)]",
    "HumanEval/23": "def str_length(s: str) -> int:\n    return len(s)",
    "HumanEval/24": "def largest_divisor(n: int) -> int:\n    for i in range(n - 1, 0, -1):\n        if n % i == 0:\n            return i\n    return 1",
    "HumanEval/25": "def factorize(n: int) -> List[int]:\n    factors = []\n    divisor = 2\n    while divisor <= n:\n        if n % divisor == 0:\n            factors.append(divisor)\n            n //= divisor\n        else:\n            divisor += 1\n    return factors",
    "HumanEval/26": "def remove_duplicates(numbers: List[int]) -> List[int]:\n    frequency = {}\n    for num in numbers:\n        if num in frequency:\n            frequency[num] += 1\n        else:\n            frequency[num] = 1\n    result = [num for num in numbers if frequency[num] == 1]\n    return result",
    "HumanEval/27": "def flip_case(s: str) -> str:\n    flipped = \"\"\n    for char in s:\n        if char.islower():\n            flipped += char.upper()\n        elif char.isupper():\n            flipped += char.lower()\n        else:\n            flipped += char\n    return flipped",
    "HumanEval/28": "def concatenate(strs: List[str]) -> str:\n    return \"\".join(strs)",
    "HumanEval/29": "def filter_by_prefix(strs: List[str], prefix_str: str) -> List[str]:\n    return [s for s in strs if s.startswith(prefix_str)]",
    "HumanEval/30": "def get_positive(l: List[int]) -> List[int]:\n    return [num for num in l if num > 0]",
    "HumanEval/31": "def is_prime(n: int) -> bool:\n    if n < 2:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True",
    "HumanEval/32": "def poly(xs: List[int], x: float) -> float:\n    return sum([coeff * math.pow(x, i) for i, coeff in enumerate(xs)])\n\ndef find_zero(xs: List[int]) -> float:\n    x1, x2 = 1.0, -1.0\n    while poly(xs, x1) * poly(xs, x2) > 0:\n        x1 *= 2\n        x2 *= 2\n    while abs(x1 - x2) > 1e-10:\n        mid = (x1 + x2) / 2\n        if poly(xs, mid) == 0:\n            return mid\n        elif poly(xs, mid) * poly(xs, x1) < 0:\n            x2 = mid\n        else:\n            x1 = mid\n    return (x1 + x2) / 2",
    "HumanEval/33": "def sort_third(l: List[int]) -> List[int]:\n    divisible_by_three = []\n    not_divisible_by_three = []\n    for i in range(len(l)):\n        if i % 3 == 0:\n            divisible_by_three.append(l[i])\n        else:\n            not_divisible_by_three.append(l[i])\n    divisible_by_three.sort()\n    result = []\n    j = 0\n    k = 0\n    for i in range(len(l)):\n        if i % 3 == 0:\n            result.append(divisible_by_three[j])\n            j += 1\n        else:\n            result.append(not_divisible_by_three[k])\n            k += 1\n    return result",
    "HumanEval/34": "def list_unique(l: List[int]) -> List[int]:\n    return sorted(list(set(l)))",
    "HumanEval/35": "def max_element(l: List[int]) -> int:\n    if not l:\n        return 0\n    return max(l)",
    "HumanEval/36": "def fizz_buzz(n: int) -> int:\n    count = 0\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count(\"7\")\n    return count",
    "HumanEval/37": "def sort_even(l: List[int]) -> List[int]:\n    even_indices = [i for i in range(len(l)) if i % 2 == 0]\n    even_values = [l[i] for i in even_indices]\n    even_values.sort()\n    result = l.copy()\n    for i in even_indices:\n        result[i] = even_values.pop(0)\n    return result",
    "HumanEval/38": "def encode_cyclic(s: str) -> str:\n    encoded_groups = []\n    for i in range(0, len(s), 3):\n        group = s[i : i + 3]\n        if len(group) == 3:\n            rotated_group = group[1:] + group[0]\n            encoded_groups.append(rotated_group)\n        else:\n            encoded_groups.append(group)\n    return \"\".join(encoded_groups)\n\ndef decode_cyclic(s: str) -> str:\n    return encode_cyclic(encode_cyclic(s))",
    "HumanEval/39": "def is_prime(p: int) -> bool:\n    if p < 2:\n        return False\n    for k in range(2, int(math.sqrt(p)) + 1):\n        if p % k == 0:\n            return False\n    return True\n\ndef prime_fib(n: int) -> int:\n    f = [0, 1]\n    while True:\n        f.append(f[-1] + f[-2])\n        if is_prime(f[-1]):\n            n -= 1\n        if n == 0:\n            return f[-1]",
    "HumanEval/40": "def triples_sum_to_zero(l: List[int]) -> bool:\n    if len(l) < 3:\n        return False\n    sl = sorted(l)\n    for i in range(len(sl) - 2):\n        left = i + 1\n        right = len(sl) - 1\n        while left < right:\n            total = sl[i] + sl[left] + sl[right]\n            if total == 0:\n                return True\n            elif total < 0:\n                left += 1\n            else:\n                right -= 1\n    return False",
    "HumanEval/41": "def car_race_collision(n: int) -> int:\n    return n * n",
    "HumanEval/42": "def incr_list(l: List[int]) -> List[int]:\n    return [i + 1 for i in l]",
    "HumanEval/43": "def pairs_sum_to_zero(l: List[int]) -> bool:\n    seen = set()\n    for num in l:\n        if -num in seen:\n            return True\n        seen.add(num)\n    return False",
    "HumanEval/44": "def change_base(x: int, bas: int) -> str:\n    if x == 0:\n        return \"0\"\n    digits = []\n    while x > 0:\n        digits.append(str(x % bas))\n        x //= bas\n    return \"\".join(digits[::-1])",
    "HumanEval/45": "def triangle_area(a: int, h: int) -> float:\n    return a * h / 2",
    "HumanEval/46": "def fib4(n: int) -> int:\n    if n == 0 or n == 1:\n        return 0\n    elif n == 2:\n        return 2\n    else:\n        a, b, c, d = 0, 0, 2, 0\n        for i in range(3, n):\n            e = a + b + c + d\n            a, b, c, d = b, c, d, e\n        return d",
    "HumanEval/47": "def median(l: List[float]) -> float:\n    sorted_list = sorted(l)\n    length = len(sorted_list)\n    if length % 2 == 0:\n        return (sorted_list[length // 2 - 1] + sorted_list[length // 2]) / 2\n    else:\n        return sorted_list[length // 2]",
    "HumanEval/48": "def is_palindrome(txt: str) -> bool:\n    return txt == txt[::-1]",
    "HumanEval/49": "def modp(n: int, p: int) -> int:\n    if n == 0:\n        return 1\n    elif n % 2 == 0:\n        return modp(n // 2, p) ** 2 % p\n    else:\n        return 2 * modp(n - 1, p) % p",
    "HumanEval/50": "def encode_shift(s: str) -> str:\n    encoded_chars = []\n    for ch in s:\n        if \"a\" <= ch <= \"z\":\n            encoded_char = chr(((ord(ch) - ord(\"a\") + 5) % 26) + ord(\"a\"))\n        else:\n            encoded_char = ch\n        encoded_chars.append(encoded_char)\n    return \"\".join(encoded_chars)\n\ndef decode_shift(s: str) -> str:\n    decoded_chars = []\n    for ch in s:\n        if \"a\" <= ch <= \"z\":\n            decoded_char = chr(((ord(ch) - ord(\"a\") - 5) % 26) + ord(\"a\"))\n        else:\n            decoded_char = ch\n        decoded_chars.append(decoded_char)\n    return \"\".join(decoded_chars)",
    "HumanEval/51": "def remove_vowels(txt: str) -> str:\n    vowels = \"aeiouAEIOU\"\n    return \"\".join([char for char in txt if char not in vowels])",
    "HumanEval/52": "def below_threshold(l: List[int], t: int) -> bool:\n    for num in l:\n        if num >= t:\n            return False\n    return True",
    "HumanEval/53": "def add(x: int, y: int) -> int:\n    return x + y",
    "HumanEval/54": "def same_chars(s0: str, s1: str) -> bool:\n    set0 = set(s0)\n    set1 = set(s1)\n    return set0 == set1",
    "HumanEval/55": "def fib(n: int) -> int:\n    if n <= 1:\n        return n\n    else:\n        return fib(n - 1) + fib(n - 2)",
    "HumanEval/56": "def correct_bracketing(brackets: str) -> bool:\n    stack = []\n    for bracket in brackets:\n        if bracket == \"<\":\n            stack.append(bracket)\n        elif bracket == \">\":\n            if not stack:\n                return False\n            stack.pop()\n    return not stack",
    "HumanEval/57": "def monotonic(l: List[int]) -> bool:\n    increasing = decreasing = True\n    for i in range(len(l) - 1):\n        if l[i] > l[i + 1]:\n            increasing = False\n        elif l[i] < l[i + 1]:\n            decreasing = False\n    return increasing or decreasing",
    "HumanEval/58": "def common(l1: List[int], l2: List[int]) -> List[int]:\n    common_elements = list(set(l1) & set(l2))\n    return sorted(common_elements)",
    "HumanEval/59": "def largest_prime_factor(n: int) -> int:\n    i = 2\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n    return n",
    "HumanEval/60": "def sum_to_n(n: int) -> int:\n    return sum(range(n + 1))",
    "HumanEval/61": "def correct_bracketing(brackets: str) -> bool:\n    depth = 0\n    for bracket in brackets:\n        if bracket == \"(\":\n            depth += 1\n        elif bracket == \")\":\n            depth -= 1\n        if depth < 0:\n            return False\n    return depth == 0",
    "HumanEval/62": "def derivative(xs: List[int]) -> List[int]:\n    return [xs[i] * i for i in range(1, len(xs))]",
    "HumanEval/63": "def fibfib(n: int) -> int:\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 0\n    elif n == 2:\n        return 1\n    else:\n        a, b, c = 0, 0, 1\n        for i in range(2, n):\n            a, b, c = b, c, a + b + c\n        return c",
    "HumanEval/64": "def vowels_count(s: str) -> int:\n    vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"]\n    count = 0\n    for i in range(len(s)):\n        if s[i].lower() in vowels:\n            count += 1\n        elif i == len(s) - 1 and s[i].lower() == \"y\":\n            count += 1\n    return count",
    "HumanEval/65": "def circular_shift(x: int, shift: int) -> str:\n    x_str = str(x)\n    n = len(x_str)\n    if shift > n:\n        return x_str[::-1]\n    else:\n        shifted_str = x_str[-shift:] + x_str[:-shift]\n        return shifted_str",
    "HumanEval/66": "def digit_sum(s: str) -> int:\n    sum = 0\n    for c in s:\n        if c.isupper():\n            sum += ord(c)\n    return sum",
    "HumanEval/67": "def fruit_distribution(s: str, n: int) -> int:\n    words = s.split()\n    num_apples = 0\n    num_oranges = 0\n    for word in words:\n        if word == \"apples\":\n            num_apples = int(words[words.index(word) - 1])\n        elif word == \"oranges\":\n            num_oranges = int(words[words.index(word) - 1])\n    num_mangoes = n - num_apples - num_oranges\n    return num_mangoes",
    "HumanEval/68": "def pluck(arr: List[int]) -> List[int]:\n    even_values = []\n    for i, val in enumerate(arr):\n        if val % 2 == 0:\n            even_values.append((val, i))\n    if not even_values:\n        return []\n    else:\n        smallest_even_value = min(even_values, key=lambda x: (x[0], x[1]))\n        return [smallest_even_value[0], smallest_even_value[1]]",
    "HumanEval/69": "def search(lst: List[int]) -> int:\n    max_val = -1\n    for val in set(lst):\n        if val > 0 and lst.count(val) >= val:\n            max_val = max(max_val, val)\n    return max_val",
    "HumanEval/70": "def strange_sort_list(lst: List[int]) -> List[int]:\n    sorted_lst = []\n    lst0 = sorted(lst)\n    while lst0:\n        sorted_lst.append(lst0.pop(0))\n        if lst0:\n            sorted_lst.append(lst0.pop(-1))\n    return sorted_lst",
    "HumanEval/71": "def triangle_area(a: int, b: int, c: int) -> float:\n    if a + b > c and a + c > b and b + c > a:\n        s = (a + b + c) / 2\n        area = (s * (s - a) * (s - b) * (s - c)) ** 0.5\n        return area\n    else:\n        return -1.0",
    "HumanEval/72": "def will_it_fly(q: List[int], w: int) -> bool:\n    n = len(q)\n    is_palindromic = all(q[i] == q[n - i - 1] for i in range(n))\n    if is_palindromic and sum(q) <= w:\n        return True\n    else:\n        return False",
    "HumanEval/73": "def smallest_change(arr: List[int]) -> int:\n    n = len(arr)\n    changes_needed = 0\n    for i in range(n // 2):\n        if arr[i] != arr[n - i - 1]:\n            changes_needed += 1\n    return changes_needed",
    "HumanEval/74": "def total_match(lst1: List[str], lst2: List[str]) -> List[str]:\n    total_chars_lst1 = sum(len(s) for s in lst1)\n    total_chars_lst2 = sum(len(s) for s in lst2)\n    if total_chars_lst1 <= total_chars_lst2:\n        return lst1\n    else:\n        return lst2",
    "HumanEval/75": "def is_prime(num: int) -> bool:\n    if num < 2:\n        return False\n    for i in range(2, int(num**0.5) + 1):\n        if num % i == 0:\n            return False\n    return True\n\ndef is_multiply_prime(a: int) -> bool:\n    if a < 2:\n        return False\n    prime_factors = []\n    for i in range(2, a + 1):\n        if is_prime(i):\n            while a % i == 0:\n                prime_factors.append(i)\n                a //= i\n    return len(prime_factors) == 3",
    "HumanEval/76": "def is_simple_power(x: int, n: int) -> bool:\n    if x == 1:\n        return True\n    elif n == 1:\n        return False\n    i = 1\n    while i <= x:\n        if i == x:\n            return True\n        i *= n\n    return False",
    "HumanEval/77": "def is_cube(a: int) -> bool:\n    if a == 0:\n        return True\n    elif a < 0:\n        a = -a\n    cube_root = a ** (1 / 3)\n    return int(cube_root + 0.5) ** 3 == a",
    "HumanEval/78": "def hex_key(num: str) -> int:\n    primes = [\"2\", \"3\", \"5\", \"7\", \"B\", \"D\"]\n    count = 0\n    for digit in num:\n        if digit in primes:\n            count += 1\n    return count",
    "HumanEval/79": "def decimal_to_binary(dec: int) -> str:\n    binary = bin(dec)[2:]\n    return f\"db{binary}db\"",
    "HumanEval/80": "def is_happy(s: str) -> bool:\n    if len(s) < 3:\n        return False\n    for i in range(len(s) - 2):\n        if s[i] == s[i + 1] or s[i] == s[i + 2] or s[i + 1] == s[i + 2]:\n            return False\n    return True",
    "HumanEval/81": "def numerical_letter_grade(grades: List[float]) -> List[str]:\n    letter_grades = []\n    for grade in grades:\n        if grade == 4.0:\n            letter_grades.append(\"A+\")\n        elif grade > 3.7:\n            letter_grades.append(\"A\")\n        elif grade > 3.3:\n            letter_grades.append(\"A-\")\n        elif grade > 3.0:\n            letter_grades.append(\"B+\")\n        elif grade > 2.7:\n            letter_grades.append(\"B\")\n        elif grade > 2.3:\n            letter_grades.append(\"B-\")\n        elif grade > 2.0:\n            letter_grades.append(\"C+\")\n        elif grade > 1.7:\n            letter_grades.append(\"C\")\n        elif grade > 1.3:\n            letter_grades.append(\"C-\")\n        elif grade > 1.0:\n            letter_grades.append(\"D+\")\n        elif grade > 0.7:\n            letter_grades.append(\"D\")\n        elif grade > 0.0:\n            letter_grades.append(\"D-\")\n        else:\n            letter_grades.append(\"E\")\n    return letter_grades",
    "HumanEval/82": "def prime_length(s: str) -> bool:\n    length = len(s)\n    if length < 2:\n        return False\n    for i in range(2, int(math.sqrt(length)) + 1):\n        if length % i == 0:\n            return False\n    return True",
    "HumanEval/83": "def starts_one_ends(n: int) -> int:\n    if n == 1:\n        return 1\n    return 2 * 9 * (10 ** (n - 2))",
    "HumanEval/84": "def solve(n: int) -> str:\n    digits = list(str(n))\n    binary_sum = bin(sum(int(d) for d in digits))\n    return binary_sum[2:]",
    "HumanEval/85": "def add(lst: List[int]) -> int:\n    total = 0\n    for i in range(1, len(lst), 2):\n        if lst[i] % 2 == 0:\n            total += lst[i]\n    return total",
    "HumanEval/86": "def anti_shuffle(s: str) -> str:\n    words = s.split()\n    ordered_words = []\n    for word in words:\n        ordered_word = \"\".join(sorted(word))\n        ordered_words.append(ordered_word)\n    return \" \".join(ordered_words)",
    "HumanEval/87": "def get_row(lst: List[List[int]], x: int) -> List[List[int]]:\n    coordinates = []\n    for i in range(len(lst)):\n        for j in range(len(lst[i])):\n            if lst[i][j] == x:\n                coordinates.append([i, j])\n    coordinates.sort(key=lambda x: x[1], reverse=True)\n    coordinates.sort(key=lambda x: x[0])\n    return coordinates",
    "HumanEval/88": "def sort_array(arr: List[int]) -> List[int]:\n    sorted_arr = arr.copy()\n    if len(sorted_arr) <= 1:\n        return sorted_arr\n    if (sorted_arr[0] + sorted_arr[-1]) % 2 == 0:\n        sorted_arr.sort(reverse=True)\n    else:\n        sorted_arr.sort()\n    return sorted_arr",
    "HumanEval/89": "def encrypt(s: str) -> str:\n    result = \"\"\n    for char in s:\n        if char.isalpha():\n            shifted = ord(char) + 4\n            if shifted > ord(\"z\"):\n                shifted -= 26\n            result += chr(shifted)\n        else:\n            result += char\n    return result",
    "HumanEval/90": "def next_smallest(lst: List[int]) -> Optional[int]:\n    if len(lst) < 2:\n        return None\n    else:\n        unique_lst = list(set(lst))\n        if len(unique_lst) < 2:\n            return None\n        else:\n            unique_lst.sort()\n            return unique_lst[1]",
    "HumanEval/91": "def is_bored(s: str) -> int:\n    sentences = re.split(r\"[.!?]\", s)\n    count = 0\n    for sentence in sentences:\n        words = sentence.strip().split()\n        if words and words[0] == \"I\":\n            count += 1\n    return count",
    "HumanEval/92": "def any_int(x: Any, y: Any, z: Any) -> bool:\n    if isinstance(x, int) and isinstance(y, int) and isinstance(z, int):\n        if (x + y == z) or (x + z == y) or (y + z == x):\n            return True\n        return False\n    return False",
    "HumanEval/93": "def encode(message: str) -> str:\n    vowels = \"aeiouAEIOU\"\n    encoded_message = \"\"\n    for letter in message:\n        if letter.isalpha():\n            if letter in vowels:\n                letter = chr(ord(letter) + 2)\n            if letter.islower():\n                encoded_message += letter.upper()\n            else:\n                encoded_message += letter.lower()\n        else:\n            encoded_message += letter\n    return encoded_message",
    "HumanEval/94": "def is_prime(n: int) -> bool:\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef skjkasdkd(lst: List[int]) -> int:\n    largest_prime = -1\n    for num in lst:\n        if is_prime(num):\n            if largest_prime is -1 or num > largest_prime:\n                largest_prime = num\n    if largest_prime is -1:\n        return 0\n    return sum(int(digit) for digit in str(largest_prime))",
    "HumanEval/95": "def check_dict_case(d: Dict[str, str]) -> bool:\n    if not d:\n        return False\n    lower_case = False\n    upper_case = False\n    for key in d.keys():\n        if key.islower():\n            lower_case = True\n        elif key.isupper():\n            upper_case = True\n        else:\n            return False\n    return lower_case != upper_case",
    "HumanEval/96": "def count_up_to(n: int) -> List[int]:\n    primes = []\n    for num in range(2, n):\n        if all(num % p != 0 for p in primes):\n            primes.append(num)\n    return primes",
    "HumanEval/97": "def multiply(a: int, b: int) -> int:\n    a_units = abs(a) % 10\n    b_units = abs(b) % 10\n    return a_units * b_units",
    "HumanEval/98": "def count_upper(s: str) -> int:\n    vowels = [\"A\", \"E\", \"I\", \"O\", \"U\"]\n    count = 0\n    for i in range(0, len(s), 2):\n        if s[i] in vowels and s[i].isupper():\n            count += 1\n    return count",
    "HumanEval/99": "def closest_integer(value: str) -> int:\n    num = float(value)\n    if num >= 0:\n        return int(num + 0.5)\n    else:\n        return int(num - 0.5)",
    "HumanEval/100": "def make_a_pile(n: int) -> List[int]:\n    return [n + 2 * i for i in range(n)]",
    "HumanEval/101": "def words_string(s: str) -> List[str]:\n    words = s.split(\",\")\n    words = [word.split(\" \") for word in words]\n    words = [word for sublist in words for word in sublist if len(word) > 0]\n    return words",
    "HumanEval/102": "def choose_num(x: int, y: int) -> int:\n    max_even = -1\n    for i in range(x, y + 1):\n        if i % 2 == 0 and i > max_even:\n            max_even = i\n    return max_even",
    "HumanEval/103": "def rounded_avg(n: int, m: int) -> Optional[str]:\n    if n > m:\n        return None\n    avg = sum(range(n, m + 1)) / (m - n + 1)\n    return bin(round(avg))[2:]",
    "HumanEval/104": "def unique_digits(x: List[int]) -> List[int]:\n    result = []\n    for num in x:\n        if all(int(digit) % 2 != 0 for digit in str(num)):\n            result.append(num)\n    return sorted(result)",
    "HumanEval/105": "def by_length(arr: List[int]) -> List[str]:\n    digit_names = [\n        \"\",\n        \"One\",\n        \"Two\",\n        \"Three\",\n        \"Four\",\n        \"Five\",\n        \"Six\",\n        \"Seven\",\n        \"Eight\",\n        \"Nine\",\n    ]\n    sorted_arr = sorted([x for x in arr if 1 <= x <= 9])\n    sorted_arr.reverse()\n    return [digit_names[x] for x in sorted_arr]",
    "HumanEval/106": "def f(n: int) -> List[int]:\n    result = []\n    for i in range(1, n + 1):\n        if i % 2 == 0:\n            fact = 1\n            for j in range(1, i + 1):\n                fact *= j\n            result.append(fact)\n        else:\n            s = 0\n            for j in range(1, i + 1):\n                s += j\n            result.append(s)\n    return result",
    "HumanEval/107": "def even_odd_palindrome(n: int) -> List[int]:\n    even_count = 0\n    odd_count = 0\n    for i in range(1, n + 1):\n        if str(i) == str(i)[::-1]:\n            if i % 2 == 0:\n                even_count += 1\n            else:\n                odd_count += 1\n    return [even_count, odd_count]",
    "HumanEval/108": "def digits_sum(n: int) -> int:\n    neg = 1\n    if n < 0:\n        n, neg = -1 * n, -1\n    n = [int(i) for i in str(n)]\n    n[0] = n[0] * neg\n    return sum(n)\n\ndef count_nums(arr: List[int]) -> int:\n    digit_sums = [digits_sum(i) for i in arr]\n    positive_sums = [i for i in digit_sums if i > 0]\n    return len(positive_sums)",
    "HumanEval/109": "def move_one_ball(arr: List[int]) -> bool:\n    if len(arr) == 0:\n        return True\n    my_arr = []\n    min_value = min(arr)\n    min_index = arr.index(min_value)\n    my_arr = arr[min_index:] + arr[0:min_index]\n    sorted_array = sorted(arr)\n    for i in range(len(arr)):\n        if my_arr[i] != sorted_array[i]:\n            return False\n    return True",
    "HumanEval/110": "def exchange(lst1: List[int], lst2: List[int]) -> str:\n    if all(num % 2 == 0 for num in lst1):\n        return \"YES\"\n    odd_nums = [num for num in lst1 if num % 2 != 0]\n    even_nums = [num for num in lst2 if num % 2 == 0]\n    if len(even_nums) >= len(odd_nums):\n        return \"YES\"\n    else:\n        return \"NO\"",
    "HumanEval/111": "def histogram(test: str) -> Dict[str, int]:\n    letters = test.split()\n    counts = {}\n    max_count = 0\n    for letter in letters:\n        if letter in counts:\n            counts[letter] += 1\n        else:\n            counts[letter] = 1\n        if counts[letter] > max_count:\n            max_count = counts[letter]\n    result = {}\n    for letter, count in counts.items():\n        if count == max_count:\n            result[letter] = count\n    return result",
    "HumanEval/112": "def reverse_delete(s: str, c: str) -> List[str]:\n    for char in c:\n        s = s.replace(char, \"\")\n    is_palindrome = s == s[::-1]\n    return [s, \"yes\" if is_palindrome else \"no\"]",
    "HumanEval/113": "def odd_count(lst: List[str]) -> List[str]:\n    res = []\n    for s in lst:\n        n = sum(int(d) % 2 == 1 for d in s)\n        result_str = f\"the number of odd elements in the string i of the input.\"\n        result_str = result_str.replace(\"i\", str(n))\n        res.append(result_str)\n    return res",
    "HumanEval/114": "def min_sub_array_sum(nums: List[int]) -> int:\n    min_sum = float(\"inf\")\n    current_sum = 0\n    for num in nums:\n        current_sum += num\n        current_sum = min(current_sum, 0)\n        min_sum = min(min_sum, current_sum)\n    if min_sum == 0:\n        min_sum = min(i for i in nums)\n    return min_sum",
    "HumanEval/115": "def max_fill(grid: List[List[int]], capacity: int) -> int:\n    return sum([math.ceil(sum(arr) / capacity) for arr in grid])",
    "HumanEval/116": "def sort_array(arr: List[int]) -> List[int]:\n    return sorted(arr, key=lambda x: (bin(x).count(\"1\"), x))",
    "HumanEval/117": "def select_words(s: str, n: int) -> List[str]:\n    words = s.split()\n    result = []\n    for word in words:\n        consonants = 0\n        for letter in word:\n            if letter.lower() not in \"aeiou\" and letter.isalpha():\n                consonants += 1\n        if consonants == n:\n            result.append(word)\n    return result",
    "HumanEval/118": "def get_closest_vowel(word: str) -> str:\n    vowels = set([\"a\", \"e\", \"i\", \"o\", \"u\"])\n    word = word.lower()\n    for i in range(len(word) - 2, 0, -1):\n        if (\n            word[i] in vowels\n            and word[i - 1] not in vowels\n            and word[i + 1] not in vowels\n        ):\n            return word[i].upper() if word[i].isupper() else word[i]\n    return \"\"",
    "HumanEval/119": "def check(s: str) -> bool:\n    val = 0\n    for i in s:\n        if i == \"(\":\n            val = val + 1\n        else:\n            val = val - 1\n        if val < 0:\n            return False\n    return True if val == 0 else False\n\ndef match_parens(lst: List[str]) -> str:\n    s1 = lst[0] + lst[1]\n    s2 = lst[1] + lst[0]\n    return \"Yes\" if check(s1) or check(s2) else \"No\"",
    "HumanEval/120": "def maximum(arr: List[int], k: int) -> List[int]:\n    if k == 0:\n        return []\n    sorted_arr = sorted(arr)\n    ans = sorted_arr[-k:]\n    return ans",
    "HumanEval/121": "def solution(lst: List[int]) -> int:\n    sum = 0\n    for i in range(0, len(lst), 2):\n        if lst[i] % 2 != 0:\n            sum += lst[i]\n    return sum",
    "HumanEval/122": "def add_elements(arr: List[int], k: int) -> int:\n    total = 0\n    for i in range(k):\n        if len(str(arr[i])) <= 2:\n            total += arr[i]\n    return total",
    "HumanEval/123": "def get_odd_collatz(n: int) -> List[int]:\n    collatz_seq = [n]\n    while n != 1:\n        if n % 2 == 0:\n            n = n // 2\n        else:\n            n = 3 * n + 1\n        collatz_seq.append(n)\n    odd_numbers = [num for num in collatz_seq if num % 2 == 1]\n    return sorted(odd_numbers)",
    "HumanEval/124": "def valid_date(date: str) -> bool:\n    if date.count(\"-\") != 2:\n        return False\n    month, day, year = date.split(\"-\")\n    month, day, year = int(month), int(day), int(year)\n    if month < 1 or month > 12:\n        return False\n    if month in [1, 3, 5, 7, 8, 10, 12] and day < 1 or day > 31:\n        return False\n    if month in [4, 6, 9, 11] and day < 1 or day > 30:\n        return False\n    if month == 2 and day < 1 or day > 29:\n        return False\n    return True",
    "HumanEval/125": "def split_words(date: str) -> List[str]:\n    if \" \" in date:\n        return date.split()\n    elif \",\" in date:\n        return date.split(\",\")\n    else:\n        count = 0\n        for char in date:\n            if char.islower() and ord(char) % 2 == 0:\n                count += 1\n        return [str(count)]",
    "HumanEval/126": "def is_sorted(lst: List[int]) -> bool:\n    for i in range(len(lst) - 1):\n        if lst[i] > lst[i + 1]:\n            return False\n    for i in lst:\n        if lst.count(i) > 2:\n            return False\n    return True",
    "HumanEval/127": "def intersection(interval1: List[int], interval2: List[int]) -> str:\n    start1, end1 = interval1\n    start2, end2 = interval2\n    intersection_start = max(start1, start2)\n    intersection_end = min(end1, end2)\n    if intersection_start > intersection_end:\n        return \"NO\"\n    intersection_length = intersection_end - intersection_start\n    if intersection_length <= 1:\n        return \"NO\"\n    for i in range(2, int(intersection_length**0.5) + 1):\n        if intersection_length % i == 0:\n            return \"NO\"\n    return \"YES\"",
    "HumanEval/128": "def prod_signs(arr: List[int]) -> Optional[int]:\n    if not arr:\n        return None\n    sign_product = 1\n    magnitude_sum = 0\n    for num in arr:\n        if num == 0:\n            sign_product = 0\n        elif num < 0:\n            sign_product *= -1\n            magnitude_sum += abs(num)\n        else:\n            magnitude_sum += num\n    return sign_product * magnitude_sum",
    "HumanEval/129": "def min_path(grid: List[List[int]], k: int) -> List[int]:\n    n = len(grid)\n    val = n * n + 1\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == 1:\n                temp = []\n                if i != 0:\n                    temp.append(grid[i - 1][j])\n                if j != 0:\n                    temp.append(grid[i][j - 1])\n                if i != n - 1:\n                    temp.append(grid[i + 1][j])\n                if j != n - 1:\n                    temp.append(grid[i][j + 1])\n                val = min(temp)\n    ans = []\n    for i in range(k):\n        if i % 2 == 0:\n            ans.append(1)\n        else:\n            ans.append(val)\n    return ans",
    "HumanEval/130": "def tri(n: int) -> List[int]:\n    if n == 0:\n        return [1]\n    seq = [1, 3]\n    for i in range(2, n + 1):\n        if i % 2 == 0:\n            seq.append(i / 2 + 1)\n        else:\n            seq.append(seq[i - 1] + seq[i - 2] + (i + 3) / 2)\n    return seq",
    "HumanEval/131": "def digits(n: int) -> int:\n    product = 1\n    has_odd_digit = False\n    for digit in str(n):\n        if int(digit) % 2 == 1:\n            product *= int(digit)\n            has_odd_digit = True\n    if has_odd_digit:\n        return product\n    else:\n        return 0",
    "HumanEval/132": "def is_nested(s: str) -> bool:\n    open_idx = []\n    close_idx = []\n    for i in range(len(s)):\n        if s[i] == '[':\n            open_idx.append(i)\n        elif s[i] == ']':\n            close_idx.append(i)\n    close_idx.reverse()\n    cnt = 0\n    i = 0\n    l = len(close_idx)\n    for idx in open_idx:\n        if i < l and idx < close_idx[i]:\n            cnt += 1\n            i += 1\n    return cnt >= 2",
    "HumanEval/133": "def sum_squares(lst: List[float]) -> int:\n    sum_of_squares = 0\n    for num in lst:\n        num = math.ceil(num)\n        sum_of_squares += num**2\n    return sum_of_squares",
    "HumanEval/134": "def check_if_last_char_is_a_letter(txt: str) -> bool:\n    if len(txt) == 0:\n        return False\n    else:\n        last_char = txt[-1]\n        if last_char.isalpha() and (len(txt.split()[-1]) == 1):\n            return True\n        else:\n            return False",
    "HumanEval/135": "def can_arrange(arr: List[int]) -> int:\n    index = -1\n    i = 1\n    while i < len(arr):\n        if arr[i] < arr[i - 1]:\n            index = i\n        i += 1\n    return index",
    "HumanEval/136": "def largest_smallest_integers(lst: List[int]) -> List[Optional[int]]:\n    neg_ints = [i for i in lst if i < 0]\n    pos_ints = [i for i in lst if i > 0]\n    if len(neg_ints) == 0:\n        largest_neg = None\n    else:\n        largest_neg = max(neg_ints)\n    if len(pos_ints) == 0:\n        smallest_pos = None\n    else:\n        smallest_pos = min(pos_ints)\n    return [largest_neg, smallest_pos]",
    "HumanEval/137": "def compare_one(a: Any, b: Any) -> Any:\n    a1 = a\n    b1 = b\n    if isinstance(a1, str): \n        a1 = a1.replace(',','.')\n    if isinstance(b1, str): \n        b1 = b1.replace(',','.')\n    if float(a1) == float(b1): \n        return None\n    elif float(a1) > float(b1):\n        return a\n    else:\n        return b",
    "HumanEval/138": "def is_equal_to_sum_even(n: int) -> bool:\n    return n % 2 == 0 and n >= 8",
    "HumanEval/139": "def special_factorial(n: int) -> int:\n    fact_i = 1\n    special_fact = 1\n    for i in range(1, n + 1):\n        fact_i *= i\n        special_fact *= fact_i\n    return special_fact",
    "HumanEval/140": "def fix_spaces(txt: str) -> str:\n    new_txt = \"\"\n    i = 0\n    start, end = 0, 0\n    while i < len(txt):\n        if txt[i] == \" \":\n            end += 1\n        else:\n            if end - start > 2:\n                new_txt += \"-\" + txt[i]\n            elif end - start > 0:\n                new_txt += \"_\" * (end - start) + txt[i]\n            else:\n                new_txt += txt[i]\n            start, end = i + 1, i + 1\n        i += 1\n    if end - start > 2:\n        new_txt += \"-\"\n    elif end - start > 0:\n        new_txt += \"_\"\n    return new_txt",
    "HumanEval/141": "def file_name_check(file_name: str) -> str:\n    suf = [\"txt\", \"exe\", \"dll\"]\n    lst = file_name.split(sep=\".\")\n    if len(lst) != 2:\n        return \"No\"\n    if not lst[1] in suf:\n        return \"No\"\n    if len(lst[0]) == 0:\n        return \"No\"\n    if not lst[0][0].isalpha():\n        return \"No\"\n    t = len([x for x in lst[0] if x.isdigit()])\n    if t > 3:\n        return \"No\"\n    return \"Yes\"",
    "HumanEval/142": "def sum_squares(lst: List[int]) -> int:\n    result = 0\n    for i in range(len(lst)):\n        if i % 3 == 0:\n            result += lst[i] ** 2\n        elif i % 4 == 0:\n            result += lst[i] ** 3\n        else:\n            result += lst[i]\n    return result",
    "HumanEval/143": "def is_prime(n: int) -> bool:\n    if n < 2:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef words_in_sentence(sentence: str) -> str:\n    words = sentence.split()\n    prime_words = []\n    for word in words:\n        if is_prime(len(word)):\n            prime_words.append(word)\n    return \" \".join(prime_words)",
    "HumanEval/144": "def simplify(x: str, n: str) -> bool:\n    a, b = x.split(\"/\")\n    c, d = n.split(\"/\")\n    numerator = int(a) * int(c)\n    denom = int(b) * int(d)\n    if numerator / denom == int(numerator / denom):\n        return True\n    return False",
    "HumanEval/145": "def digits_sum(n: int) -> int:\n    neg = 1\n    if n < 0:\n        n, neg = -1 * n, -1\n    n = [int(i) for i in str(n)]\n    n[0] = n[0] * neg\n    return sum(n)\n\ndef order_by_points(nums: List[int]) -> List[int]:\n    return sorted(nums, key=digits_sum)",
    "HumanEval/146": "def special_filter(nums: List[int]) -> int:\n    count = 0\n    for num in nums:\n        if (\n            num > 10\n            and str(num)[0] in [\"1\", \"3\", \"5\", \"7\", \"9\"]\n            and str(num)[-1] in [\"1\", \"3\", \"5\", \"7\", \"9\"]\n        ):\n            count += 1\n    return count",
    "HumanEval/147": "def get_max_triples(n: int) -> int:\n    a = [i * i - i + 1 for i in range(1, n + 1)]\n    count = 0\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                if (a[i] + a[j] + a[k]) % 3 == 0:\n                    count += 1\n    return count",
    "HumanEval/148": "def bf(planet1: str, planet2: str) -> List[str]:\n    planets = [\n        \"Mercury\",\n        \"Venus\",\n        \"Earth\",\n        \"Mars\",\n        \"Jupiter\",\n        \"Saturn\",\n        \"Uranus\",\n        \"Neptune\",\n    ]\n    if planet1 not in planets or planet2 not in planets:\n        return []\n    index1 = planets.index(planet1)\n    index2 = planets.index(planet2)\n    if index1 > index2:\n        index1, index2 = index2, index1\n    return [p for p in planets[index1 + 1 : index2]]",
    "HumanEval/149": "def sorted_list_sum(lst: List[str]) -> List[str]:\n    even_length_strings = []\n    for string in lst:\n        if len(string) % 2 == 0:\n            even_length_strings.append(string)\n    sorted_list = sorted(even_length_strings, key=lambda x: (len(x), x))\n    return sorted_list",
    "HumanEval/150": "def x_or_y(n: int, x: int, y: int) -> int:\n    if n < 2:\n        return y\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return y\n    return x",
    "HumanEval/151": "def double_the_difference(lst: List[float]) -> int:\n    sum_of_squares = 0\n    for num in lst:\n        if num >= 0 and num % 2 != 0 and num == int(num):\n            sum_of_squares += num**2\n    return sum_of_squares",
    "HumanEval/152": "def compare(game: List[int], guess: List[int]) -> List[int]:\n    return [abs(x - y) for x, y in zip(game, guess)]",
    "HumanEval/153": "def strongest_extension(class_name: str, extensions: List[str]) -> str:\n    max_strength = float(\"-inf\")\n    strongest_extension = \"\"\n    for extension in extensions:\n        cap = sum(1 for c in extension if c.isupper())\n        sm = sum(1 for c in extension if c.islower())\n        strength = cap - sm\n        if strength > max_strength:\n            max_strength = strength\n            strongest_extension = extension\n    return f\"{class_name}.{strongest_extension}\"",
    "HumanEval/154": "def cycpattern_check(a: str, b: str) -> bool:\n    if len(a) < len(b):\n        return False\n    for i in range(len(b)):\n        if b[i:] + b[:i] in a:\n            return True\n    return False",
    "HumanEval/155": "def even_odd_count(num: int) -> List[int]:\n    even_count = 0\n    odd_count = 0\n    for digit in str(abs(num)):\n        if int(digit) % 2 == 0:\n            even_count += 1\n        else:\n            odd_count += 1\n    return [even_count, odd_count]",
    "HumanEval/156": "def int_to_mini_roman(num: int) -> str:\n    roman_numerals = [\n        (1000, \"m\"),\n        (900, \"cm\"),\n        (500, \"d\"),\n        (400, \"cd\"),\n        (100, \"c\"),\n        (90, \"xc\"),\n        (50, \"l\"),\n        (40, \"xl\"),\n        (10, \"x\"),\n        (9, \"ix\"),\n        (5, \"v\"),\n        (4, \"iv\"),\n        (1, \"i\"),\n    ]\n    result = \"\"\n    for value, numeral in roman_numerals:\n        while num >= value:\n            result += numeral\n            num -= value\n    return result",
    "HumanEval/157": "def right_angle_triangle(a: int, b: int, c: int) -> bool:\n    sides = [a, b, c]\n    sides.sort()\n    if sides[0] ** 2 + sides[1] ** 2 == sides[2] ** 2:\n        return True\n    else:\n        return False",
    "HumanEval/158": "def find_max(words: List[str]) -> str:\n    max_unique_chars = 0\n    max_word = \"\"\n    for word in words:\n        unique_chars = len(set(word))\n        if unique_chars > max_unique_chars:\n            max_unique_chars = unique_chars\n            max_word = word\n        elif unique_chars == max_unique_chars:\n            max_word = min(max_word, word)\n    return max_word",
    "HumanEval/159": "def eat(num: int, need: int, remaining: int) -> List[int]:\n    if need <= remaining:\n        return [num + need, remaining - need]\n    else:\n        return [num + remaining, 0]",
    "HumanEval/160": "def do_algebra(operators: List[str], operands: List[int]) -> int:\n    ops = operators.copy()\n    nums = operands.copy()\n    i = len(ops) - 1\n    while i >= 0:\n        if ops[i] == \"**\":\n            nums[i] = nums[i] ** nums[i + 1]\n            nums.pop(i + 1)\n            ops.pop(i)\n        i -= 1\n    i = 0\n    while i < len(ops):\n        if ops[i] == \"*\":\n            nums[i] = nums[i] * nums[i + 1]\n            nums.pop(i + 1)\n            ops.pop(i)\n            i -= 1\n        elif ops[i] == \"//\":\n            nums[i] = nums[i] // nums[i + 1]\n            nums.pop(i + 1)\n            ops.pop(i)\n            i -= 1\n        i += 1\n    i = 0\n    while i < len(ops):\n        if ops[i] == \"+\":\n            nums[i] = nums[i] + nums[i + 1]\n            nums.pop(i + 1)\n            ops.pop(i)\n            i -= 1\n        elif ops[i] == \"-\":\n            nums[i] = nums[i] - nums[i + 1]\n            nums.pop(i + 1)\n            ops.pop(i)\n            i -= 1\n        i += 1\n    return nums[0]",
    "HumanEval/161": "def solve(s: str) -> str:\n    letters = 0\n    for char in s:\n        if char.isalpha():\n            letters += 1\n    if letters == 0:\n        return s[::-1]\n    else:\n        result = \"\"\n        for char in s:\n            if char.isalpha():\n                if char.islower():\n                    result += char.upper()\n                else:\n                    result += char.lower()\n            else:\n                result += char\n        return result",
    "HumanEval/162": "def string_to_md5(txt: str) -> Optional[str]:\n    if not txt:\n        return None\n    md5_hash = hashlib.md5()\n    md5_hash.update(txt.encode('ascii'))\n    md5_encoded = md5_hash.hexdigest()\n    return md5_encoded",
    "HumanEval/163": "def generate_integers(a: int, b: int) -> List[int]:\n    lower = max(2, min(a, b))\n    upper = min(8, max(a, b))\n    return [i for i in range(lower, upper + 1) if i % 2 == 0]"
}